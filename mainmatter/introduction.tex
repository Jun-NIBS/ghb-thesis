% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Introduction}
\labelChapter{introduction}

\enlargethispage{2pt}

Today's processors are built to execute a vast range of \glspl{program}, from
tiny \emph{Hello, world!} samples to large-scale Earth simulations, and they are
built to execute these programs as fast and efficiently as possible.
%
To this end, CPU manufacturers continuously enhance their processors with
sophisticated \glspl{instruction}, allowing complex computations that previously
required many \gls{instruction} to be executed using a single \gls{instruction}.
%
In particular, such \glspl{instruction} are common in \glspl{DSP} that appear in
many contemporary mobile phones.
%
But while the technology behind modern processors continues to advance, the
techniques for selecting the \glspl{instruction} provided by the processors have
not.
%
In fact, the techniques applied in today's state-of-the-art \glspl{compiler} are
essentially the same methods that were applied in the 1980s.
%
Since they assume a much simpler \gls{instruction set}, principally all
sophisticated \glspl{instruction} currently available in modern processors
cannot be selected using these techniques, forcing \gls{compiler} developers to
implement hand-written heuristics that check the applicability of a specific
\gls{instruction} and, if applicable, greedily select it.
%
With over \num{100}~million microprocessors being shipped every
quarter~\cite{Intel:2014:NewsRelease}, through release cycles that grow shorter
and shorter, there is a pressing need for new and improved \gls{instruction
  selection} techniques.
%
Furthermore, the impact and availability of selecting a particular
\gls{instruction} is highly dependent on other \gls{code generation} tasks.
%
For example, moving a computation from one part of the \gls{program} to another
may enable it to be combined with another computation which can then both be
implemented using a single \gls{instruction}.
%
Consequently, in order to generate high-quality code, these tasks must be
performed in unison.

This dissertation addresses these problems by introducing a new approach based
on methods from combinatorial optimization.
%
The approach, called \gls!{universal instruction selection}, relies on a novel
model that is simpler and more flexible compared to non-\glspl{combinatorial
  approach} and captures crucial features ignored by other, existing
combinatorial optimization models for \gls{instruction selection}.
%
Most importantly, the model is the first to combine the task of \gls{global.is}
\gls{instruction selection} with \gls{global code motion} in order to alleviate
selection of sophisticated \glspl{instruction} that would otherwise not have
been applicable.
%
In addition, because control flow is involved the model also integrates
\gls{block ordering} as this is shown to impact \gls{instruction selection} and
vice versa.
%
To enable this model, the dissertation introduces a novel, \gls{graph}-based
representation that unifies data flow and control flow for entire
\glspl{function}.
%
This representation also enables \glspl{instruction} whose behavior contains
both data and control flow to be modeled as \glspl{graph} (for an exact
definition of \glspl{graph} and other related terms, see
\refAppendix{graph-definitions}).
%
The dissertation also proposes extensions to this model for integrating
\gls{instruction scheduling} and \gls{register allocation}, which are two other
\gls{code generation} tasks known to impact \gls{instruction selection} and vice
versa.


\section{Thesis Statement}
\labelSection{intro-thesis-statement}

\begin{statement}
  \Glsdesc{CP} is a flexible, practical, competitive, and
  extensible approach for combining \gls{global.is} \gls{instruction selection},
  \gls{global code motion}, and \gls{block ordering}.
\end{statement}
%
By \emph{flexible}, it means that our approach can handle hardware architectures
with a rich \gls{instruction set}.
%
By \emph{practical}, it means that our approach can select \glspl{instruction}
for \glspl{program} of sufficient complexity and scales to medium-sized
\glspl{function} (measured in hundreds of \glspl{operation}).
%
By \emph{competitive}, it means that our approach generates code of equal or
better quality compared to an existing state-of-the-art \gls{compiler}.
%
By \emph{extensible}, it means that our approach can be extended to integrate
other \gls{code generation} tasks.


\section{Motivation}
\labelSection{intro-motivation}

A \gls!{compiler} is a tool that takes a \gls{program}, written in some
programming language, as input and produces equivalent \gls{assembly code} for a
specific processor, called the \gls!{target machine}, as output.
%
\begin{figure}
  \centering%
  \input{figures/introduction/compiler-overview}

  \caption{Overview of a typical compiler}
  \labelFigure{compiler-overview}
\end{figure}
%
As shown in \refFigure{compiler-overview}, a \gls{compiler} typically consists
of three parts:%
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item a \gls!{frontend}, which performs syntactic and semantic analysis and
    transforms the program into an \gls!{IR}
  \item an \gls!{optimizer} (sometimes called \gls!{middle-end}), which performs
    target-independent optimizations
  \item a \gls!{backend}, which performs \gls{code generation}
\end{inlinelist}.

The \gls{optimizer} is arguably the largest component of any \gls{compiler},
consisting of many tasks such as \gls{constant folding}, \gls{dead code
  elimination}, and \gls{loop unrolling}.
%
Another such optimization is \gls!{global code motion}, where \glspl{operation}
are moved from one \gls{basic block} to another, which is done mainly to move
expensive \glspl{operation} into \glspl{block} with lower execution frequency.

The \gls{backend} also consists of several tasks, of which three
typically are most promiment:%
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item \gls!{instruction selection}, where \glspl{instruction} implementing the
    given \gls{program} are selected
  \item \gls!{register allocation}, where \gls{virtual.temp} \glspl{temporary}
    are assigned to \glspl{register}
  \item \gls!{instruction scheduling}, where \glspl{instruction} are reordered
    to increase instruction-level parallelism
\end{inlinelist}.
%
Another code generation task of interest is \gls!{block ordering}, where the
\glspl{basic block} are rearranged in order to minimize the number of jump
\glspl{instruction}.


\subsubsection{%
  The Need for New Instruction Selection Techniques and Representations%
}

\begin{filecontents*}{isel-gcmotion-example.c}
int i = 0;
while (i < N) {
  int a = A[i];
  int b = B[i];
  int c = a + b;
  if (MAX < c) c = MAX;
  C[i] = c;
  i++;
}
\end{filecontents*}

\begin{figure}
  \centering%
  \subcaptionbox{C code\labelFigure{isel-gcmotion-example-c}}%
                {\lstinputlisting[language=c]{isel-gcmotion-example.c}}%
  \hspace{5mm}%
  \subcaptionbox{Corresponding IR and control-flow graph%
                 \labelFigure{isel-gmotion-example-ir}}%
                [64mm]%
                {\input{figures/introduction/isel-gcmotion-example-ir}}%

  \caption[%
            Example illustrating the need for new techniques and the interaction
            between instruction selection and global code motion%
          ]{%
            Example to illustrate the need for new techniques and the
            interaction between instruction selection and global code motion.
            %
            The program computes the saturated sums of two arrays \irVar{A} and
            \irVar{B} as a new array~\irVar{C}, all of which are assumed to be
            of equal lengths and stored in memory.
            %
            The variables \irVar{N} and \irVar{MAX} are constants representing
            the array length and the upper limit, respectively.
            %
            An integer is assumed to be 4~bytes%
          }
  \labelFigure{isel-gcmotion-example}%
\end{figure}

\labelPage{saturated-arithmetic}

\RefFigure{isel-gcmotion-example} shows a program that computes the saturated
sums of two integer arrays.
%
In \gls!{saturation arithmetic}, the result of an arithmetic \gls{operation}
will always stay within a range fixed by a minimum and maximum value.
%
If the \gls{operation} would produce a value outside of this range, then the
value is set (``clamped'') to the closest limit, thus becoming ``saturated''.

Assume a \gls{target machine} that has an instruction capable of implementing
the saturated-add \gls{operation} used in the \gls{program} shown in
\refFigure{isel-gcmotion-example}.
%
Hence the \gls{instruction} would implement the following five operations:%
%
\begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
  \item the \irAdd{\irVar{a}}{\irVar{b}} addition
  \item the \irLE{\irVar{MAX}}{\irVar{c}} comparison
  \item the conditional jump to either of blocks~\irBlock{b4} and~\irBlock{b5}
  \item the \irAssign{\irVar{c}}{\irVar{MAX}} assignment
  \item the unconditional jump to~\irBlock{b5}
\end{inlinelist}.
%
Selecting this \gls{instruction} can have tremendous impact on performance.
%
Assume, for example, that each \gls{operation} can be implemented using an
\gls{instruction} that takes one cycle to execute. Hence executing one iteration
of the loop takes \num{16}~cycles, and selecting the saturated-add
\gls{instruction} reduces the execution time by \SI{25}{\percent}.

Existing \gls{instruction selection} techniques and representations, however, do
not support selection of such \glspl{instruction}.
%
Since the \glspl{operation} above reside in separate \glspl{block} (\irBlock{b3}
and \irBlock{b4}), making use of the saturated-add \gls{instruction} requries an
\gls{instruction selector} that is capable of processing multiple \glspl{basic
  block} simultaneously.
%
In comparison, \glsshort{traditional approach} \gls{instruction selection}
techniques only consider one \gls{basic block} at a time.
%
Morever, most approaches represent the \glspl{instruction} as \glspl{graph}.
%
As the saturated-add \gls{instruction} contains \glspl{operation} for both data
and control flow, modeling it as a \gls{graph} requires a representation that
captures both data and control flow.
%
In comparison, existing representations only capture data flow.


\subsubsection{For Combining Instruction Selection and Global Code Motion}

Assume that the \gls{target machine} also has a \gls{SIMD.instr}
\gls{instruction} for addition.\!%
%
\footnote{%
  A \gls!{SIMD.instr}[ \gls{instruction}] is an \gls{instruction} that executes
  the same \gls{operation} over multiple sets of input data.%
}
%
Revisiting the example shown in \refFigure{isel-gcmotion-example}, there are
four additions in the \gls{program} (\irAdd{\irVar{A}}{\irTemp{2}},
\irAdd{\irVar{B}}{\irTemp{2}}, \irAdd{\irVar{C}}{\irTemp{2}}, and
\irAdd{\irVar{i}}{\irVar{1}}) which are independent from one another and can
therefore be executed in parallel.
%
Assuming again that all \glspl{instruction} takes one cycle to execute,
implementing these four additions using a single \gls{SIMD.instr}
\gls{instruction} would improve performance by almost \SI{19}{\percent}.
%
This requires that the two additions in block~\irBlock{b5} be moved to
block~\irBlock{b4}, which is the task of \gls{global code motion}.
%
However, as \gls{global code motion} is commonly considered to be a
target-independent optimization, it is often done before \gls{code generation}.
%
Consequently, the \gls{global code mover} may take decisions which are
detrimental for the \gls{instruction selector}.


\subsubsection{For Taking Cost of Data Copying Into Account}

Although selecting \gls{SIMD.instr} \glspl{instruction} may significantly
improve code quality -- like in the previous example -- doing so carelessly may
also have the opposite effect.
%
Assume, for example, that the \gls{SIMD.instr} \gls{instruction} uses a limited
set of registers.
%
If the other selected \glspl{instruction} cannot directly write to and read from
these registers, then additional \glspl{instruction} must be emitted to copy the
values between the general registers and the \gls{SIMD.instr} registers.
%
In the case of the program shown in \refFigure{isel-gcmotion-example}, eight
such \glspl{instruction} would be needed, leading to a slowdown of over
\SI{31}{\percent}.
%
These restrictions must be known by the \gls{instruction selector} to make
effective use of \gls{SIMD.instr} \glspl{instruction}.


\subsubsection{For Combining Instruction Selection and Block Ordering}

\begin{filecontents*}{isel-blorder-example.c}
int f() {
  int a;
  do {
    a = g();
  } while (a == 0);
  return a;
}
\end{filecontents*}

\begin{figure}
  \centering%
  \subcaptionbox{C code\labelFigure{isel-blorder-example-c}}%
                {\lstinputlisting[language=c]{isel-blorder-example.c}}%
  \hspace{5mm}%
  \subcaptionbox{Corresponding IR and control-flow graph%
                 \labelFigure{isel-blorder-example-ir}}%
                [64mm]%
                {\input{figures/introduction/isel-blorder-example-ir}}%

  \vspace{\betweensubfigures}

  \subcaptionbox{%
                  Selecting basic jump instruction, after block ordering.
                  %
                  Cycle count: 6%
                  \labelFigure{isel-blorder-example-code-1}%
                }%
                [34mm]%
                {%
                  \figureFontSize%
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & cmp  & \instrTemp{1} $\leftarrow$
                                 \instrEQ{\instrVar{a}}{\instrVar{0}}\\
                        & jmp  & \instrTemp{1}, \instrBlock{b1}\\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  Selecting complex jump instruction, before block ordering.
                  %
                  Cycle count: 5%
                  \labelFigure{isel-blorder-example-code-2}%
                }%
                [39mm]%
                {%
                  \figureFontSize%
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & jmp  & \instrNE{\instrVar{a}}{\instrVar{0}},
                                 \instrBlock{b2}\\
                    \\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }
  \hfill%
  \subcaptionbox{%
                  Selecting complex jump instruction, after block ordering.
                  %
                  Cycle count: 8%
                  \labelFigure{isel-blorder-example-code-3}%
                }%
                [40mm]%
                {%
                  \figureFontSize%
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & jmp  & \instrNE{\instrVar{a}}{\instrVar{0}},
                                 \instrBlock{b2}\\
                        & jmp  & \instrBlock{b1}\\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }

  \caption[%
            Example illustrating the interaction between instruction
            selection and block ordering%
          ]{%
            Example to illustrate the interaction between instruction
            selection and block ordering.
            %
            The function \irCode{f} calls another function \irCode{g} until it
            returns a non-zero value, and then returns that value%
          }
  \labelFigure{isel-blorder-example}%
\end{figure}

\RefFigure{isel-blorder-example} shows a \gls{function} that keeps calling
another \gls{function} (with side effects) until it returns a non-zero value.
%
Assume that the \gls{target machine} has three \glspl{instruction} for handling
control flow:%
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item a \mbox{{\instrFont jmp} $p$, $b$} \gls{instruction}, which
    branches to block~$b$ if the value in register~$p$ corresponds the Boolean
    value~$\mathit{true}$
  \item a \mbox{{\instrFont jmp} $r \neq 0$, $b$} \gls{instruction}, which
    branches to block~$b$ if the condition \mbox{$r \neq 0$} holds, where $r$
    is a register
  \item a \mbox{{\instrFont jmp} $b$} \gls{instruction}, which
    unconditionally branches to block~$b$
\end{inlinelist}.
%
Assume also that these branch \glspl{instruction} take three cycles compared to
the other \glspl{instruction} in the \gls{target machine}, which take one cycle.

At first glance it appears that only the first jump \gls{instruction} is
selectable for implementing the conditional branch (see
\refFigure{isel-blorder-example-code-1}), leading to a total of six cycles for
the entire \gls{function}.
%
But by flipping the condition and swapping block labels (conditionally jumping
to \irBlock{b2} instead of \irBlock{b1}), the more complex jump
\gls{instruction} becomes selectable (see
\refFigure{isel-blorder-example-code-2}), bringing the cycle count to five
cycles and thus reducing the execution time by almost \SI{17}{\percent}.
%
However, although this decision may appear better at the point of
\gls{instruction selection}, it necessitates an additional jump
\gls{instruction} when ordering the \glspl{block} (because block~\irBlock{b1}
cannot fall-through to the top of itself; see
\refFigure{isel-blorder-example-code-3}).
%
This code takes eight cycles to execute, thus leading to a slowdown of
\SI{33}{\percent}.
%
The \gls{instruction selector} must therefore be aware of additional jump
\glspl{instruction} that may be required when making such decisions.


\section{Approach}
\labelSection{intro-approach}

\begin{figure}
  \centering%
  \input{figures/introduction/approach-overview}

  \caption{Overview of the approach}
  \labelFigure{approach-overview}
\end{figure}

The approach, outlined in \refFigure{approach-overview}, is as follows.
%
The \gls{IR} code of the \gls{program} under compilation is fed to a tool which
builds a \gls{graph}-based representation of the \gls{program}.
%
The \gls{graph} is subjected to a series of transformations and then fed to a
matcher together with the \gls{pattern set} of the specified \gls{target
  machine}.
%
The \gls{pattern set} is built from a \gls!{machine description}, which is a
machine-readable specification of the \gls{target machine}, and contains a
\gls{graph}-based \gls{pattern} for each \gls{instruction}.
%
These \glspl{pattern} have also been subjected to similar transformations.
%
Taking the \gls{graph} and \gls{pattern set} as input, the matcher produces a
set of \glspl{match}.
%
This is fed to a modeler, which constructs a problem instance of the
\gls{constraint model}.
%
The \gls{constraint model} is then solved by a generic off-the-shelf
\gls{constraint solver}.
%
The \gls{solution} is then fed to a code emitter, which produces the code
containing the selected \glspl{instruction}.


\section{Research Methodology}
\labelSection{intro-research-methodology}

\todo{write}


\section{Contributions}
\labelSection{intro-contributions}

The dissertation makes six contributions to the areas of \gls{code generation}
and \gls{CP}:
%
\begin{contributions}
  \item \labelContribution{survey}
    It presents a comprehensive survey that
    \begin{contributions}
      \item \labelContribution{survey-spanning}
        examines over four decades of research on \gls{instruction selection},
        covering a significantly wider scope and timespan compared to existing
        surveys \cite{Cattell:1977, GanapathiEtAl:1982:Survey, Lunell:1983,
          Leupers:2000:Survey, BoulytchevLomov:2001} which are either too old
        or incomplete.
    \end{contributions}
    The survey structures the approaches according to two dimensions:
    \begin{contributions}[resume]
      \item \labelContribution{survey-principles}
        the fundamental \gls{principle} -- \gls{macro expansion}, \gls{tree
          covering}, \gls{DAG covering}, or \gls{graph covering} -- that they
        apply, and
    \end{contributions}
    \begin{contributions}[resume]
      \item \labelContribution{survey-instruction-characteristics}
        the \glspl{instruction characteristic} -- \gls{single-output.ic},
        \gls{multi-output.ic}, \gls{disjoint-output.ic}, \gls{inter-block.ic},
        and \gls{interdependent.ic} -- that they support.
    \end{contributions}
    %
    In addition, the survey
    \begin{contributions}[resume]
      \item \labelContribution{survey-problem-identification}
        identifies connections between \gls{instruction selection} and other
        \gls{code generation} problems that have yet to be investigated.
    \end{contributions}
  \item \labelContribution{representations}
    It introduces a novel \gls{program} and \gls{instruction} representation
    that
    \begin{contributions}
      \item \labelContribution{rep-data-and-control-flow}
        captures both data and control flow for entire \glspl{function} and
        \glspl{instruction},
    \end{contributions}
    which enables
    \begin{contributions}[resume]
      \item \labelContribution{rep-complex-instructions}
        an unprecedented range of instruction behaviors to be captured and
        modeled as \glspl{pattern}.
    \end{contributions}
    In addition, the representation is crucial for
    \begin{contributions}[resume]
      \item \labelContribution{rep-combining-problems}
        combining \gls{instruction selection} and \gls{global code motion} --
        two problems that have until now been considered separately from one
        another -- and solving these two problems in unison.
    \end{contributions}
  \item \labelContribution{constraint-model}
    It introduces a \gls{constraint model} and related transformations for
    \gls{universal instruction selection} which, for the first time, enables
    \begin{contributions}
      \item \labelContribution{cp-uniform-selection}
        uniform selection of data and control \glspl{instruction},
    \end{contributions}
    and integration of
    \begin{contributions}[resume]
      \item \labelContribution{cp-global-instruction-selection}
        \gls{global.is} \gls{instruction selection} with
      \item \labelContribution{cp-global-code-motion}
        \gls{global code motion}.
    \end{contributions}
    In addition, the \gls{constraint model} integrates
    \begin{contributions}[resume]
      \item \labelContribution{cp-data-copying}
        \gls{data copying},
      \item \labelContribution{cp-value-reuse}
        \gls{value reuse}, and
      \item \labelContribution{cp-block-ordering}
        \gls{block ordering}.
    \end{contributions}
  \item \labelContribution{solving-techniques}
    It introduces techniques to improve solving of the \gls{constraint model}.
  \item \labelContribution{experiments}
    It presents thorough experiments demonstrating that the approach scales to
    medium-sized \glspl{program} and yields equal or better code than
    \glspl{traditional approach}.
  \item \labelContribution{integration}
    It outlines how the \gls{constraint model} can be extended to integrate
    other \gls{code generation} tasks, such as \gls{instruction scheduling} and
    \gls{register allocation}.
\end{contributions}
%
\refTable{contributions-per-chapter} shows in which chapters each contribution
is manifested and discussed further.

\begin{table}
  \centering%
  \begin{tabular}{c@{\qquad}*{6}{c}}
    \toprule
      \tabhead chapter
    & \tabhead\refContribution{survey}
    & \tabhead\refContribution{representations}
    & \tabhead\refContribution{constraint-model}
    & \tabhead\refContribution{solving-techniques}
    & \tabhead\refContribution{experiments}
    & \tabhead\refContribution{integration}\\
    \midrule
    \refChapter*{existing-isel-techniques-and-reps}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refChapter*{universal-representation}
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refChapter*{constraint-model}
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refChapter*{solving-techniques}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo\\
    \refChapter*{comparison-with-the-state-of-the-art}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo\\
    \refChapter*{future-work}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes\\
    \refAppendix*{macro-expansion}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refAppendix*{tree-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refAppendix*{dag-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refAppendix*{graph-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \bottomrule
  \end{tabular}

  \caption{Contributions per chapter}
  \labelTable{contributions-per-chapter}
\end{table}


\section{Publications}
\labelSection{intro-publications}

This dissertation is based on material presented in the following publications:


\subsubsection{Books}

\begin{publications}
  \item \labelPublication{survey-book}
    \fullcite{HjortBlindell:2016:Survey}.
\end{publications}


\subsubsection{Conference Papers}

\begin{publications}[resume]
  \item \labelPublication{cp-paper}
    \fullcite{HjortBlindellEtAl:2015:CP}.
    %
    \begin{authorsContribution}
      The author of this dissertation conceived, designed, and implemented the
      work presented in the paper, oversaw the writing of the paper, wrote the
      majority of the text, designed the figures, and assisted in data gathering
      and analysis.
    \end{authorsContribution}
\end{publications}


\subsubsection{Articles}

\begin{publications}[resume]
  \item \labelPublication{cases-paper}
    \fullcite{HjortBlindellEtAl:2017:CASES}.
    %
    \begin{authorsContribution}
      The author conceived, designed, and implemented the work presented in the
      paper, gathered and analyzed the experimental data, oversaw the writing of
      the paper, wrote the majority of the text, and designed the figures.
    \end{authorsContribution}
\end{publications}
%
\refTable{contributions-per-publication} shows the relation between the
contributions and the publications above.

\begin{table}
  \centering%
  \begin{tabular}{c@{\qquad}*{11}{c}}
    \toprule
      \tabhead publication
    & \tabhead\refContribution{survey}
    & \tabhead\refContribution{representations}
    & \multicolumn{6}{c}{\tabhead\refContribution{constraint-model}}
    & \tabhead\refContribution{solving-techniques}
    & \tabhead\refContribution{experiments}
    & \tabhead\refContribution{integration}\\
    \cmidrule(lr){4-9}%
    &
    &
    & \tabhead\refContribution{cp-uniform-selection}
    & \tabhead\refContribution{cp-global-instruction-selection}
    & \tabhead\refContribution{cp-global-code-motion}
    & \tabhead\refContribution{cp-data-copying}
    & \tabhead\refContribution{cp-block-ordering}
    & \tabhead\refContribution{cp-value-reuse}
    &
    &
    &\\
    \midrule
    \refPublication{survey-book}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo\\
    \refPublication{cp-paper}
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo\\
    \refPublication{cases-paper}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportNo\\
    \bottomrule
  \end{tabular}

  \caption{Contributions per publication}
  \labelTable{contributions-per-publication}
\end{table}

The author also participated in the following publications, which are out of
scope for the dissertation:


\subsubsection{Book Chapters, Conference Papers, and Workshop Papers}

\begin{publications}[resume]
  \item \labelPublication{survey-report}
    \fullcite{HjortBlindell:2013:Survey}.
  \item \labelPublication{scopes}
    \fullcite{CastanedaLozanoEtAl:2013:M-SCOPES}.
    %
    \begin{authorsContribution}
      The author assisted in writing the paper.
    \end{authorsContribution}
  \item \labelPublication{lctes}
    \fullcite{CastanedaLozanoEtAl:2014:LCTES}.
    %
    \begin{authorsContribution}
      The author assisted in gathering and analyzing the experimental data, and
      to writing the paper.
    \end{authorsContribution}
  \item \labelPublication{cc}
    \fullcite{CastanedaLozanoEtAl:2016:CC}.
    %
    \begin{authorsContribution}
      The author assisted in writing the paper.
    \end{authorsContribution}
  \item \labelPublication{fdl-2016}
    \fullcite{HjortBlindellEtAl:2016:FDL}.
    %
    \begin{authorsContribution}
      The author conceived, designed, and implemented the work presented in the
      paper, gathered and analyzed the experimental data, oversaw the writing of
      the paper, wrote the majority of the text, and designed the figures.
    \end{authorsContribution}
\end{publications}
%
\refPublication{survey-report} is excluded as it is subsumed and extended by
\refPublication{survey-book}. \refPublication{scopes}--\refPublication{cc} are
excluded as they are only partially related to the dissertation (they apply
\gls{CP} to solve \gls{register allocation} and \gls{instruction scheduling}
without considering \gls{instruction selection}). \refPublication{fdl-2016} is
excluded as it belongs to a different topic entirely (high-level code generation
for graphics processors).


\section{Outline}
\labelSection{intro-outline}

\todo{Describe chapters}

\todo{Add figure illustrating how to read the dissertation}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Conclusions}
\labelChapter{conclusions}

In this dissertation, we have introduced \gls!{universal instruction
  selection},\!%
%
\footnote{%
  The source code is freely available on
  {\relsize{-.5}{\url{github.com/unison-code/uni-instr-sel}}}.%
}
%
a new approach that integrates \gls{global.is} \gls{instruction selection},
\gls{global code motion}, and \gls{block ordering}.
%
By doing so, it addresses the limitations of existing \gls{instruction
  selection} techniques that fail to exploit many of the \glspl{instruction}
provided by modern processors.

To handle the combinatorial nature of these problems, the approach is based on
\glsdesc{CP}.
%
It relies on a novel combinatorial model that is simpler and more flexible
compared to the techniques currently used in modern \glspl{compiler}.
%
In addition, it captures crucial features that are ignored by other
combinatorial approaches.
%
We have also seen that the \glsshort{constraint model} can be extended to
integrate \gls{instruction scheduling} and \gls{register allocation}, which are
two other important tasks of \gls{code generation}.

The \glsshort{constraint model} is enabled by a novel, \gls{graph}-based
representation that unifies data flow and control flow for entire
\glspl{function}.
%
Not only is this representation crucial for combining \gls{instruction
  selection} with \gls{global code motion}, it also enables \glspl{instruction}
whose behavior contains both data and control flow to be modeled as
\glspl{graph}.
%
Hence there is no longer any need for hand-written routines to handle
\glspl{instruction} that violate underlying assumptions about the
\gls{instruction set}.

Through experimental evaluation, we have seen that \gls{universal instruction
  selection} can handle hardware architectures with a rich \gls{instruction set}
and scales up to medium-sized \glspl{function}.
%
For these \glspl{function}, the approach generates code of equal or better
quality compared to the state of the art.
%
In addition, we have seen that there is sufficient data parallelism to be
exploited through selection of \gls{SIMD.instr} \glspl{instruction}, resulting
in significantly better code quality, and that this exploitation is benefitted
from \gls{global code motion}.

Hence \glsdesc{CP} is a flexible, practical, competitive, and extensible
approach for combining \gls{global.is} \gls{instruction selection}, \gls{global
  code motion}, and \gls{block ordering}.

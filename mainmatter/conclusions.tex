% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Conclusions}
\labelChapter{conclusions}

In this dissertation, we have introduced a new approach, called \gls{universal
  instruction selection}, that integrates \gls{global.is} \gls{instruction
  selection}, \gls{global code motion}, and \gls{block ordering}.
%
In doing so, it addresses the limitations of existing \gls{instruction
  selection} techniques that fail to handle many of the \glspl{instruction}
provided by modern processors.

To handle the combinatorial nature of these problems, our approach is based on
\glsdesc{CP}.
%
It relies on a novel combinatorial model that is simpler and more flexible
compared to the techniques currently used by modern \glspl{compiler}.
%
In addition, it captures crucial features that are ignored by other, existing
combinatorial approaches.
%
We have also seen that the \glsshort{constraint model} can be extended to
integrate other tasks of \gls{code generation}, such as \gls{instruction
  scheduling} and \gls{register allocation}.

The \glsshort{constraint model} is enabled by a novel, \gls{graph}-based
representation that unifies data flow and control flow for entire
\glspl{function}.
%
Not only is this representation crucial for combining \gls{instruction
  selection} with \gls{global code motion}, it also enables \glspl{instruction}
whose behavior contains both data and control flow to be modeled as
\glspl{graph}.
%
Hence there is no longer any need for hand-written routines to handle
\glspl{instruction} that violate underlying assumptions about the
\gls{instruction set}.

Through experimental evaluation, we have seen that our approach can handle
hardware architectures with a rich \gls{instruction set} and scales for up to
medium-sized \glspl{function}.
%
For these \glspl{function}, our approach generates code of equal or better
quality compared to the state of the art.
%
In addition, we have seen that there is sufficient data parallelism to be
exploited through selection of \gls{SIMD.instr} \glspl{instruction}, resulting
in significantly better code quality, and that this exploitation is benefitted
from \gls{global code motion}.

Hence \glsdesc{CP} is a flexible, practical, competitive, and extensible
approach for combining \gls{global.is} \gls{instruction selection}, \gls{global
  code motion}, and \gls{block ordering}.

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Comparison with the State of the Art}
\labelChapter{comparison-with-the-state-of-the-art}

\todo{write outline}


\section{Unison \versus LLVM}
\labelSection{comparison-unison-vs-llvm}

We evaluate the impact of our approach by comparing the cost (that is, the total
number of cycles, as described in \refSection{cm-objective-function} on
\refPageOfSection{cm-objective-function}) of \glspl{solution} produced by our
approach with the \glspl{solution} produced by \mbox{\gls{LLVM} 3.8}, an
existing state-of-the-art \gls{compiler}.

The experimental setup is the same as in
\refSection{cm-alt-values-experimental-evaluation} on
\refPageOfSection{cm-alt-values-experimental-evaluation} with three exceptions.
%
First, when filtering we remove all \glspl{function} that have less than less
than \num{50}~\gls{LLVM} \gls{IR} \glspl{instruction} -- anything smaller will
most likely not have enough data parallelism for selection of \gls{SIMD.instr}
\glspl{instruction} -- and greater than \num{150}~\glspl{instruction} --
anything larger will lead to unreasonably long experiment runtimes.
%
To increase the amount of data parallelism, we also remove all \glspl{function}
not containing at least two addition, subtraction, logical and, or logical or
\glspl{instruction}.
%
This leaves a pool of \num{221}~\glspl{function}, from which
\num{20}~\glspl{function} are sampled using the same method as before.
%
Second, when solving we apply time limit of \SI{600}{\s} to the \gls{constraint
  solver}.
%
For any given \gls{function}, the last \gls{solution} found is considered
optimal if and only if the \glsshort{constraint solver} has finished its
execution within the time limit.
%
Third, we apply the cost for the \gls{solution} computed by \gls{LLVM} for a
given \gls{function} as the upper bound for the \gls{cost variable} in the
corresponding instance of the \gls{constraint model}.

\input{\expDir/unison-vs-llvm-hexagon5-cycles-speedup.stats}

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/unison-vs-llvm-hexagon5-cycles-speedup.plot}%
    }%
  }

  \caption[Plot for evaluating the impact of our approach on code quality]%
          {%
            Normalized solution costs for two pattern sets: one without SIMD
            instructions (baseline), and another with such instruction
            (subject).
            %
            GMI:~\printGMI{%
              \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupGmean%
            },
            CI:~\printGMICI{%
              \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupCiMin%
            }{%
              \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupCiMax%
            }.
            %
            The constraint model uses an upper bound computed by LLVM.
            %
            \Glspl{function} whose bars are marked with two dots are those
            for which the \gls{subject} fails to find the optimal solution%
          }
  \labelFigure{unison-vs-llvm-cycles-plot}
\end{figure}

\RefFigure{unison-vs-llvm-cycles-plot} shows the normalized \gls{solution} costs
for our approach, with \gls{LLVM} as \gls{baseline} and our approach as
\gls{subject}.
%
The costs range from
\printCycles{\UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesAvgMin} to
\printCycles{\UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesAvgMax}, with a maximum
coefficient of variation of
\num{\UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesCvMax}.
%
The solving times range from
\printSolvingTime{\UnisonVsLlvmHexagonFiveCyclesSpeedupPrePlusSolvingTimeAvgMin}
to
\printSolvingTime{\UnisonVsLlvmHexagonFiveCyclesSpeedupPrePlusSolvingTimeAvgMax}
with a \gls{CV} of
\num{\UnisonVsLlvmHexagonFiveCyclesSpeedupPrePlusSolvingTimeCvMax}.
%
As the \gls{GMI} is \printGMI{%
  \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
  \UnisonVsLlvmHexagonFiveCyclesSpeedupCyclesRegularSpeedupCiMax%
}, we see that our approach produces \glspl{solution} with significantly lesser
cost than those produced by \gls{LLVM}.
%
\todo{case study}
%
Hence we conclude that our approach generates code of equal or better quality
compared to the state of the art.


\section{Selection of SIMD instructions}
\labelSection{comparison-with-or-without-simds}

\def\patternSetA{\textsc{i}}
\def\patternSetB{\textsc{ii}}

We evaluate the impact of being able to select \gls{SIMD.instr}
\glspl{instruction} by comparing the cost of \glspl{solution} produced from two
\glspl{pattern set}: one derived from \gls{Hexagon} without \gls{SIMD.instr}
\glspl{instruction}, and another with such \glspl{instruction}.
%
We refer to these as \glspl{pattern set}~\patternSetA{} and~\patternSetB,
respectively.

The experimental setup is the same as in \refSection{comparison-unison-vs-llvm}
with two exceptions.
%
First, when filtering we again remove all \glspl{function} that have less than
less than \num{50}~\gls{LLVM} \gls{IR} \glspl{instruction} -- anything smaller
will most likely not have enough data parallelism for selection of
\gls{SIMD.instr} \glspl{instruction} -- and greater than
\num{150}~\glspl{instruction} -- anything larger will lead to unreasonably long
experiment runtimes.
%
But to increase the chance of data parallelism, we also remove all
\glspl{function} not containing at least two addition, subtraction, logical and,
or logical or \glspl{instruction}.
%
This leaves a pool of \num{221}~\glspl{function}, from which
\num{20}~\glspl{function} are sampled using the same method as before.
%
Second, we do not apply an upper bound in this case as that may prevent
interesting \gls{solution} that make use of \gls{SIMD.instr} \gls{instruction}.

\input{\expDir/simd-vs-without-cycles-speedup.stats}

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/simd-vs-without-cycles-speedup.plot}%
    }%
  }

  \caption[Plot for evaluating the impact of SIMD instructions on code quality]%
          {%
            Normalized solution costs for two pattern sets: one without SIMD
            instructions (baseline), and another with such instruction
            (subject).
            %
            GMI:~\printGMI{%
              \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupGmean%
            },
            CI:~\printGMICI{%
              \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMin%
            }{%
              \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMax%
            }.
            %
            \Glspl{function} whose bars are marked with two dots are those
            for which the \gls{subject} fails to find the optimal solution%
          }
  \labelFigure{simd-vs-without-cycles-plot}
\end{figure}

\RefFigure{simd-vs-without-cycles-plot} shows the normalized \gls{solution}
costs for the two \glspl{pattern set} describe above, with \gls{pattern
  set}~\patternSetA{} as \gls{baseline} and \gls{pattern set}~\patternSetB{} as
\gls{subject}.
%
The costs range from
\printMinCycles{%
  \SimdVsWithoutCyclesSpeedupCyclesAvgMin,
  \SimdVsWithoutCyclesSpeedupBaselineCyclesAvgMin
} to
\printMaxCycles{%
  \SimdVsWithoutCyclesSpeedupCyclesAvgMax,
  \SimdVsWithoutCyclesSpeedupBaselineCyclesAvgMax
}, with a \gls{CV} of
\numMaxOf{
  \SimdVsWithoutCyclesSpeedupCyclesCvMax,
  \SimdVsWithoutCyclesSpeedupBaselineCyclesCvMax
}.
%
The solving times from
\printMinSolvingTime{%
  \SimdVsWithoutCyclesSpeedupPrePlusSolvingTimeAvgMin,
  \SimdVsWithoutCyclesSpeedupBaselinePrePlusSolvingTimeAvgMin
} to
\printMaxSolvingTime{%
  \SimdVsWithoutCyclesSpeedupPrePlusSolvingTimeAvgMax,
  \SimdVsWithoutCyclesSpeedupBaselinePrePlusSolvingTimeAvgMax
}, with a \gls{CV} of
\numMaxOf{
  \SimdVsWithoutCyclesSpeedupPrePlusSolvingTimeCvMax,
  \SimdVsWithoutCyclesSpeedupBaselinePrePlusSolvingTimeCvMax
}.
%
As the \gls{GMI} is \printGMI{%
  \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
  \SimdVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMax%
}, we see that the \gls{pattern set}~\patternSetB{} yields \glspl{solution} with
significantly lesser cost than those yielded by \glsshort{pattern
  set}~\patternSetA.
%
The five cases with lesser cost ({\codeFont debug\_print\_str}, {\codeFont
  gl\_read\_alpha}, {\codeFont gx\_curve\_cursor}, {\codeFont mp\_dmul}, and
{\codeFont zero}), our approach is able to combine pairs of additions or
subtractions into \num{2}-way \gls{SIMD.instr} \glspl{instruction}.
%
In addition, in one of these cases ({\codeFont gl\_read\_alpha}) the additions
originally reside in different \glspl{block}, but due to \gls{global code
  motion} our approach is able to move the operations to the same block in order
to implement these using a single \gls{instruction}.
%
\todo{make figure to illustrate the effect}
%
Hence we conclude that there is sufficient data parallelism to be exploited
through selection of \gls{SIMD.instr} \glspl{instruction}, resulting in
significantly better code quality, and that this exploitation is benefitted from
\gls{global code motion}.


\section{Summary}
\labelSection{comparison-summary}

\todo{write}


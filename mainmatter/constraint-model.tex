% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Constraint Model}
\labelChapter{constraint-model}

This chapter introduces the \gls{constraint model} for \gls{universal
  instruction selection}.
%
\RefSectionRange{modeling-global-instruction-selection}{modeling-block-ordering}
introduce the \glspl{variable} and \gls{constraint} for modeling \gls{global.is}
\gls{instruction selection}, \gls{global code motion}, \gls{data copying},
\gls{value reuse}, and \gls{block ordering}, respectively.
%
\RefSection{cm-objective-function} introduces the \gls{objective function}
applied in the \gls{constraint model}.
%
\RefSection{cm-limitations} discusses the \glsshort{constraint model}
limitations.
%
Lastly, \refSection{model-summary} summarizes the chapter.

A \gls{MiniZinc} implementation of the \gls{constraint model} is available in
\refAppendix{minizinc-model}.


\section{Modeling Global Instruction Selection}
\labelSection{modeling-global-instruction-selection}

Modeling \gls{global.is} \gls{instruction selection} entails that all
\glspl{operation} must be \gls{cover}[ed] and all \glspl{datum} must be
\gls{define.d}[d].
%
This could, however, lead to situations resulting in cyclic data dependencies,
which must be forbidden.


\subsection{Covering Operations and Defining Data}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
There are two variants of this problem:
%
\begin{enumerate*}[label=(\arabic*)]
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerate*}
%
The former problem is more common as it is stricter, resulting in simpler models
with smaller \glspl{solution space}.
%
It also allows use of \glspl{constraint} that enable strong \gls{propagation},
which is essential for curbing solving time and increasing scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.
%
Due to the increased complexity of the relaxed version of the problem, we model
exact \gls{cover}[age] in this dissertation.

Similarly, every value and state must be produced by exactly one selected match.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \gls!{define.d}[s] $d$
if there exists an inbound \glsshort{state-flow edge} or \gls{data-flow edge} to
$d$ in the \gls{UP graph} from which $m$ was derived.
%
Similarly, $m$ \gls!{use.d}[s] $d$ if there exists an outbound
\glsshort{state-flow edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph}
of $m$.


\subsubsection{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match} found
for $\mUFGraph$, the set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0,
    1}$} models whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\neg\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt}}, where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} that can cover~$o$.
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[o]$} models which selected \gls{match} \gls{define.d}[s]
\gls{datum}~\mbox{$d \in \mDataSet$\hspace{-1.5pt}}, where $\mDataSet$ denotes
the set of \glspl{datum} in $\mUFGraph$, and \mbox{$\mMatchSet[d] \subseteq
  \mMatchSet$} denotes the set of \glspl{match} that can \gls{define.d}~$d$.


\subsubsection{Constraints}

If an \gls{operation}~$o$ is covered by a \gls{match}~$m$, then that entails
selection of $m$, and vice versa.
%
Hence the \gls{constraint} that every \gls{operation} must be covered is modeled
as
%
\begin{equation}
  \begin{array}{c}
    \mVar{omatch}[o] = m \mEq \mVar{sel}[m] \\
    \forall o \in \mOpSet \hspace{-1pt},
    \forall m \in \mMatchSet[o] \hspace{-1pt}.
  \end{array}
  \labelEquation{operation-coverage}
\end{equation}
%
This \gls{constraint} gives equally strong \gls{propagation} as
\refEquation{pattern-selection-using-gcc}, making it redundant to add the latter
as an \gls{implied.c} \gls{constraint} to the \glsshort{constraint model}.

Likewise, if a \gls{datum}~$d$ is \gls{define.d}[d] by a \gls{match}~$m$, then
that entails selection of $m$, and vice versa.
%
Hence the \gls{constraint} that every \gls{datum} must be \gls{define.d}[d]
is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{dmatch}[d] = m \mEq \mVar{sel}[m] \\
    \forall d \in \mDataSet \hspace{-1.5pt},
    \forall m \in \mMatchSet[d] \hspace{-1pt}.
  \end{array}
  \labelEquation{data-definitions}
\end{equation}
%
We assume the \gls{pattern set} has been extended with a special \gls!{null-def
  pattern}, with \gls{graph} structure \mbox{$\mEdge{b}{d}$} where $b$ is a
\gls{entry block} and $d$ is a \gls{datum}, that defines $d$ at zero cost.
%
This \gls{pattern} is needed for defining \glspl{datum} representing
\gls{function} arguments and constants since these are not produced by any
\gls{operation}.


\subsection{Forbidding Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

In certain cases, selecting \glspl{match} of \glspl{instruction} producing
multiple results -- for example, many modern processors provide memory
\glspl{instruction} that automatically increment or decrement the address value
-- could lead to cyclic data dependencies~\cite{EbnerEtAl:2008}.
%
\begin{filecontents*}{cyclic-data-deps-example-ir.c}
$\ldots$
$\irAssign{\irVar{p}[2]}{\irAdd{\irVar{p}[1]}{\irVar{4}}}$
$\irStore{\irVar{q}[1]}{\irVar{p}[2]}$
$\irAssign{\irVar{q}[2]}{\irAdd{\irVar{q}[1]}{\irVar{4}}}$
$\irStore{\irVar{p}[1]}{\irVar{q}[2]}$
\end{filecontents*}%
%
\begin{figure}
  \subcaptionbox{IR\labelFigure{cyclic-data-deps-example-ir}}%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {cyclic-data-deps-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF graph, covered by two matches derived from an
                  auto-increment store instruction.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{cyclic-data-deps-example-uf-graph}%
                }%
                [62mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-uf-graph%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Dependency graph%
                  \labelFigure{cyclic-data-deps-example-dep-graph}%
                }%
                [32mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-dep-graph%
                  }%
                }

  \caption{Example illustrating cyclic data dependencies}%
  \labelFigure{cyclic-data-deps-example}%
\end{figure}
%
An example of such a situation is given in \refFigure{cyclic-data-deps-example}.
%
If both \glspl{match} are selected, then either value~\irVar{p}[2] or
value~\irVar{q}[2] will be \gls{use.d}[d] before it is available (depending on
the instruction order), thus resulting in incorrect code.
%
Consequently, such combinations must be identified and forbidden.

We detect such combinations -- which could involve more than two \glspl{match}
-- by first constructing a \gls!{dependency graph}, where each \gls{node}
represents a \gls{match} and each \gls{edge}~$\mEdge{n}{m}$ indicates
that \gls{match}~$m$ \gls{use.d}[s] \glspl{datum} produced by \gls{match}~$n$.
%
\Glspl{phi-match} are not taken into consideration as they always yield a
\gls{cycle} but is not a true data dependency.
%
A \gls{cycle} in this \gls{graph} corresponds a combination of \glspl{match}
which will lead to a cyclic data dependency if all \glspl{match} are selected.
%
Hence, we find all \glspl{cycle} in the \gls{dependency graph} -- we applied
\citeauthor{Johnson:1975}'s algorithm for this task~\cite{Johnson:1975} -- and
add \glspl{constraint} forbidding selection of all \glspl{match} appearing in a
\gls{cycle}.


\subsubsection{Constraints}

Given a set~\mbox{$\mForbiddenCombSet \subseteq \mPowerset{\mMatchSet}$} of
\glspl{cycle} found for the \gls{dependency graph} built from a \gls{UF graph}
and \gls{match set}, the \gls{constraint} forbidding cyclic data dependencies is
modeled as
%
\begin{equation}
  \sum_{m \in f} \mVar{sel}[m] < \mCard{f}
  \mQuantSep
  \forall f \in \mForbiddenCombSet.
  \labelEquation{cyclic-data-deps}
\end{equation}


\section{Modeling Global Code Motion}
\labelSection{modeling-global-code-motion}

The \gls{global code motion} problem entails that \glspl{datum} must be placed
in \glspl{block} such that each definition of a \gls{datum}~$d$ precedes all
\gls{use.d}[s] of~$d$.
%
This condition can be expressed in terms of \gls{block} dominance.
%
Given a \gls{function}~$f$, a \gls{block}~$b$ in $f$ \gls!{dominate.b}[s]
another \gls{block}~$c$ in $f$ if $b$ appears on every control-flow path from
$f$'s \gls{entry block} to $c$ (see \refFigure{block-dominance-example} for an
example).
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{block-dominance-example-cfg}}%
                [34mm]%
                {%
                  \input{%
                    figures/constraint-model/block-dominance-example%
                  }%
                }%
  \hfill%
  \subcaptionbox{Dominance\labelFigure{block-dominance-example-doms}}%
                {%
                  \figureFont\figureFontSize%
                  \begin{tabular}{cc}
                    \toprule
                      \tabhead block
                    & \tabhead dominates\\
                    \midrule
                      \irBlock{entry}
                    & $\mSet{\irBlock{entry}, \irBlock{A}, \irBlock{B},
                        \irBlock{C}, \irBlock{D}, \irBlock{E}}$\\
                      \irBlock{A}
                    & $\mSet{\irBlock{A}, \irBlock{B}, \irBlock{C},
                        \irBlock{D}}$\\
                      \irBlock{B}
                    & $\mSet{\irBlock{B}}$\\
                      \irBlock{C}
                    & $\mSet{\irBlock{C}}$\\
                      \irBlock{D}
                    & $\mSet{\irBlock{D}}$\\
                      \irBlock{E}
                    & $\mSet{\irBlock{E}}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \mbox{}

  \caption{Example of block dominance}
  \labelFigure{block-dominance-example}
\end{figure}%
%
By definition, a \gls{block} always \gls{dominate.b}[s] itself.
%
Hence a placement of \glspl{match} into \glspl{block} is a \gls{solution} to the
\gls{global code motion} problem if each \gls{datum}~$d$ is \gls{define.d}[d] by
some selected \gls{match} placed in a \gls{block}~$b$, and every
non-\gls{phi-match} \glsshort{use.d}[ing] $d$ is placed in a \gls{block}
\gls{dominate.b}[d] by~$b$.
%
The \glspl{phi-match} must be excluded since, due to the \glspl{definition
  edge}, at least one \gls{datum} used by such \glspl{match} must be
\gls{define.d}[d] in a \gls{block} that does not \gls{dominate.b} the
\gls{block} wherein the \gls{phi-match} must be placed.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{oplace}[o] \in \mBlockSet$} models in
which \gls{block} \gls{operation}~$o$ is placed, where $\mBlockSet$ denotes the
set of \glspl{block} in $\mUFGraph$.
%
Likewise, the set of \glspl{variable} \mbox{$\mVar{dplace}[d] \in \mBlockSet$}
models in which \gls{block} the definition of \gls{datum}~$d$ is placed.


\subsubsection{Constraints}

Intuitively, all \glspl{operation} covered by a \gls{match}~$m$ must be placed
in the same \gls{block} wherein $m$ itself is placed.
%
Hence, if \mbox{$\mCovers(m) \subseteq \mOpSet$} denotes the set of
\glspl{operation} covered by \gls{match}~$m$, then this \gls{constraint} is
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o_1] = \mVar{oplace}[o_2] \\
    \forall m \in \mMatchSet,
    \forall o_1\hspace{-1pt}, o_2 \in \mCovers(m).
  \end{array}
  \labelEquation{operation-placement}
\end{equation}
%
This also enables the placement of $m$ to be deduced from any of the
corresponding $\mVar{oplace}$~\glspl{variable}.

We prevent control-flow \glspl{operation} from being moved to another
\gls{block}, which in all likelihood would break \gls{program} semantics, by
forcing selected \glspl{match} with control flow to be placed in the \gls{block}
matched by the \gls{UP graph}'s \gls{entry block}.
%
Hence, if \mbox{$\mEntry(m) \subseteq \mBlockSet$} returns either the empty set
or a set containing only the \gls{entry block} of match~$m$ (when the \gls{UP
  graph} of $m$ has such a node), then this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o] = b\hspace{-1.2pt} \\
    \forall m \in \mMatchSet,
    \forall o \in \mCovers(m),
    \forall b \in \mEntry(m).
  \end{array}
  \labelEquation{preventing-control-flow-op-moves}
\end{equation}

As stated previously, each \gls{datum}~$d$ must be \gls{define.d}[d] in some
\gls{block}~\mbox{$b \in \mBlockSet$} such that $b$ \gls{dominate.b}[s] every
\gls{block} wherein $d$ is \gls{use.d}[d], excluding \gls{use.d}[s] made by the
\glspl{phi-match}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} denote the set of \glspl{datum}
\gls{define.d}[d] respectively \gls{use.d}[d] by \gls{match}~$m$.
%
Let also \mbox{$\mDom(b) \subseteq \mBlockSet$} denote the set of \glspl{block}
\gls{dominate.b}[d] by \gls{block}~$b$.
%
With these definitions together with the fact that the placement of a
\gls{match} is inferred via its $\mVar{oplace}$~\glspl{variable}, the
\gls{constraint} can naively be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in \mDom(\mVar{oplace}[o]) \\
    \forall m \in \mPhiMatchCompSet,
    \forall d \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{naive-dom}
\end{equation}
%
where $\mPhiMatchCompSet$ denotes the set~$\mMatchSet$ without the
\glspl{phi-match}.
%
This implementation, however, has a number of flaws that will be explained and
addressed in \refChapter{solving-techniques}.
%
We therefore only use \refEquation{naive-dom} for sake of describing the
\glsshort{constraint model}, keeping in mind that a refined version is applied
in practice.

Next, we need to constrain the $\mVar{dplace}$~\glspl{variable} to depend on
where a selected \gls{match} is placed.
%
Intuitively, every \gls{datum} \gls{define.d}[d] by a \gls{match}~$m$ should be
placed in the same \gls{block} as $m$ together with all \glspl{operation}
covered by~$m$.
%
This alone, however, could result in an over-constrained \glsshort{constraint
  model} that prevents selection of certain \glspl{match}.
%
For example, assume a \gls{match}~$m$ of the \gls{UP graph} shown in
\refFigure{up-graph-examples-add-graph} on
\refPageOfFigure{up-graph-examples-add-graph}, where the \glspl{block node}
\irBlock{entry}, \irBlock{clamp}, and \irBlock{end} are matched to \glspl{block}
in $\mUFGraph$ labeled \irBlock{A}, \irBlock{B}, and \irBlock{C}, respectively.
%
Because of \refEquation{preventing-control-flow-op-moves}, $m$ must be placed in
the \irBlock{A}~\gls{block}.
%
But because of \refEquation{def-edges}, one of its \glspl{value node} must be
placed in the \irBlock{B}~\gls{block}.
%
Consequently, for such conditions the \gls{constraint} is relaxed as follows.
%
We say that a \gls{match} \gls!{span.b}[s] the \glspl{block} matched by the
\gls{UP graph}'s \glspl{block node} (hence $m$ \gls{span.b}[s] \glspl{block}
\irBlock{A}, \irBlock{B}, and~\irBlock{C}).
%
We also say that a \gls{match} \gls!{consume.b}[s] any matched \glspl{block}
where the corresponding \gls{block node} has both \gls{inbound.e} and
\gls{outbound.e} control-flow \glspl{edge} in the \gls{UP graph} (hence $m$
\gls{consume.b}[s] \gls{block}~\irBlock{B}).
%
Consequently, every \gls{datum}~$d$ \gls{define.d}[d] by a \gls{match}~$m$ must
be placed in the same \gls{block} as $m$ only if $m$ \gls{span.b}[s] no
\glspl{block}, otherwise $d$ may be \gls{define.d}[d] in any of the
\glspl{block} \gls{span.b}[ned] by~$m$.
%
If \mbox{$\mSpans(m) \subseteq B$} denotes the set of \glspl{block}
\gls{span.b}[ned] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d] \in \mSet{\mVar{oplace}[o]} \cup \mSpans(m) \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m),
    \forall o \in \mCovers(m).
  \end{array}
  \labelEquation{spanning}
\end{equation}

\Glsshort{consume.b}[ing] a \gls{block} entails that the corresponding
\gls{instruction} assumes full control of the control flow to and from that
\gls{block}, which in turn means no \glspl{operation} covered by other
\glspl{match} may be placed in that \gls{block}.
%
Hence, if \mbox{$\mConsumes(m) \subseteq B$} denotes the set of \glspl{block}
\gls{consume.b}[d] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{oplace}[o] \neq b \\
    \forall m \in \mMatchSet,
    \forall o \in \mOpSet \setminus \mCovers(m),
    \forall b \in \mConsumes(m).
  \end{array}
  \labelEquation{consumption}
\end{equation}

Lastly, the restrictions imposed by the \glspl{definition edge} are modeled as
%
\begin{equation}
  \mVar{dplace}[d] = b
  \mQuantSep
  \forall \mEdge{d}{b} \in \mFunctionDefEdgeSet,
  \labelEquation{def-edges}
\end{equation}
%
where $\mFunctionDefEdgeSet$ denotes the set of \glspl{definition edge} in
$\mUFGraph$.
%
It is assumed that the \glspl{edge} in $\mFunctionDefEdgeSet$ have been
reoriented such that all \glspl{source} are either \glsshort{state node} or
\glspl{value node} and all \glspl{target} are \glspl{block node}.


\section{Modeling Data Copying}
\labelSection{modeling-data-copying}

The cost of \gls{data copying} is taken into account by keeping track of the
storage requirements for the data used and produced by the selected
\glspl{match}.
%
The idea is as follows.
%
For each value~$v$ in the \gls{UF graph}, let a \gls{variable}~$\mVar{x}$ decide
in which \gls{location} provided by the \gls{target machine} $v$ is stored.
%
In this context a \gls!{location} is an abstract representation, typically
representing a \gls{register} but it could also indicate that the value is for
example stored in memory.
%
A \gls{match}~$m$ that either \gls{use.d}[s] or \gls{define.d}[s] $v$ and
requires $v$ to be in one of a set~$L$ of \glspl{location} can then enforce, if
selected, that \mbox{$\mVar{x} \in L$}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{loc}[d] \in \mLocationSet \cup
  \mSet{\mIntLocation}$} models in which \gls{location} \gls{datum}~$d$ is
available, where $\mLocationSet$ denotes the \gls!{location set} provided by the
\gls{target machine} and $\mIntLocation$ denotes a special \gls{location} for
values that cannot be reused across \glspl{instruction}.
%
The special \gls{location} is used for \glspl!{intermediate value}, which are
values produced within an \gls{instruction} and can only be accessed by this
very \gls{instruction}.
%
For example, the address computed by a memory load \gls{instruction} with a
sophisticated addressing mode is produced within the pipeline and thus cannot be
reused by other \glspl{instruction}.
%
A value which is not an \gls{intermediate value} is called an \gls!{exterior
  value}, meaning it can be accessed by other \glspl{instruction}.


\subsubsection{Constraints}

Every \gls{datum} must be made available in a \gls{location} that is compatible
for all selected \glspl{match}.
%
If \mbox{$\mStores(m, d) \subseteq \mLocationSet \cup \mSet{\mIntLocation}$}
denotes the set of compatible \glspl{location} (including the special
\gls{location} for intermediate values) for a \gls{datum}~$d$ which is either
\gls{define.d}[d] or \gls{use.d}[d] by a \gls{match}~$m$, then this
\gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[d] \in \mStores(m, d) \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{compatible-locations}
\end{equation}

As expected, \glspl{phi-match} require the \glspl{location} of all its
\glspl{datum} to be the same.
%
This \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[d_1] = \mVar{loc}[d_2] \\
    \forall m \in \mPhiMatchSet \hspace{-.8pt},
    \forall d_1 \hspace{-.8pt}, d_2 \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{phi-match-locations}
\end{equation}

\subsection{Copy Extension}

Depending on the \gls{target machine}, \refEquation{compatible-locations} can
result in an over-constrained \glsshort{constraint model}.
%
For example, in many \glspl{target machine} the \gls{SIMD.instr}
\glspl{instruction} use a different set of \glspl{register} than the other,
general \glspl{instruction}.
%
In such situations, the \glspl{match} derived from the \gls{SIMD.instr}
\glspl{instruction} and the \glspl{match} derived from the general
\glspl{instruction} will have non-overlapping \glspl{location} on the same
\glspl{datum} (that is, \mbox{$\mStores(m_1, d) \cap \mStores(m_2, d) =
  \mEmptySet$}), preventing selection of such \glspl{match}.

Since non-overlapping \glspl{location} entails the need for copy
\glspl{instruction}, we extend the \gls{UF graph} with \glspl!{copy node}
through a process called \gls!{copy extension}.
%
For each \gls{data-flow edge}~$\mEdge{v}{o}$, where $v$ is a \gls{value node}
and $o$ is an \gls{operation}, we remove this \gls{edge} and insert a new
\gls{copy node}~$c$, \gls{value node}~$v'$, and \glspl{data-flow edge} such that
\mbox{$\mEdge{v}{\mEdge{c}{\mEdge{v'}{o}}}$}.
%
\Glspl{match} covering exactly one \gls{copy node} are called \glspl!{copy
  match}.
%
If $o$ is a \gls{phi-node} then the corresponding \gls{definition edge}
connected to $v$ -- this is the \gls{edge} with the same \gls{outbound.en}
\gls{edge number} as the \gls{data-flow edge} -- is also moved to $v'$.
%
This is to ensure that the placement restrictions are applied only on the
\glspl{datum} actually used by the \glspl{phi-function} (that is, the copied
value and not the original value).
%
We also extend the \gls{pattern set} with a special \gls!{null-copy pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, that covers $c$ at
zero cost provided that \mbox{$\mVar{loc}[v] = \mVar{loc}[v']$}.
%
Obviously, \glspl{match} derived from the \gls{null-copy pattern} -- we call
these \glspl!{null-copy match} -- emit nothing if selected.
%
If the \gls{null-copy match} cannot be selected for covering a particular
\gls{copy node}, then this means an appropriate copy \gls{instruction} must be
emitted whose cost will be accounted for.

In order to retain matching of \glspl{pattern}, we also need to perform
\gls{copy extension} on every \gls{UP graph} in the \gls{pattern set}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original UP graph%
                  \labelFigure{copy-extending-pattern-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After copy extension%
                  \labelFigure{copy-extending-pattern-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of copy-extending a pattern}
  \labelFigure{copy-extending-pattern-example}
\end{figure}
%
See for example \refFigure{copy-extending-pattern-example}.
%
The \gls{UP graph} captures the behavior of an \gls{instruction} that adds two
values~\irVar{r} and~\irVar{s} and then shifts the result by one bit to the
right (\refFigure{copy-extending-pattern-example-before}).
%
Since we want to preserve the ability of selecting copy \glspl{instruction} for
moving \glspl{datum} between \glspl{instruction}, we only copy-extend the values
in a \gls{UP graph} which are both \gls{define.d}[d] and \gls{use.d}[d] by the
\gls{pattern}.
%
We also copy-extend any constant values since these obviously do not require a
separate copy \gls{instruction} to be used by the \gls{pattern}.
%
The resulting \gls{UP graph} will now yield the same \glspl{match} as before
\gls{copy extension} (\refFigure{copy-extending-pattern-example-after}).


\subsubsection{Constraints}

Intuitively, selecting a \gls{null-copy match} that \gls{use.d}[s] a
\gls{datum}~$d_1$ to \gls{define.d} another \gls{datum}~$d_2$ means that $d_1$
and $d_2$ are \gls{define.d}[d] in the same \gls{block}.
%
This matters when \glspl{datum} are \gls{use.d} by \glspl{phi-function}.
%
For example, assume a \gls{datum}~$d_1$ \gls{define.d} in some \gls{block} $b_1$
and that there is another \gls{datum}~$d_2$ which is a copy of $d_1$ and has a
\gls{definition edge} requiring $d_2$ to be \gls{define.d} in \gls{block}~$b_2$.
%
If $d_2$ is \gls{define.d}[d] by a \gls{null-copy match}~$m$, then $m$ must be
placed in $b_2$ in order for $d_2$ to be \gls{define.d} in $b_2$.
%
Since $m$ is a \gls{null match}, meaning it will not emit any
\glspl{instruction}, any uses $d_2$ must be replaced by $d_1$.
%
But this violates the \glspl{constraint} implied by the \glspl{phi-function}
because $d_1$ is \gls{define.d}[d] in $b_1$ and not $b_2$.

If \mbox{$\mNullCopyMatchSet \subseteq \mMatchSet$} denotes the set of
\glspl{null-copy match}, then the \gls{constraint} above is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d_1] = \mVar{dplace}[d_2] \\
    \forall m \in \mNullCopyMatchSet \hspace{-.8pt},
    \forall d_1 \in \mUses(m),
    \forall d_2 \in \mDefines(m).
  \end{array}
  \labelEquation{same-dplace-for-null-copy-matches}
\end{equation}


\subsection{Handling Calling Conventions}

The method for handling \gls{data copying} can also be used for handling calling
conventions of the specific \gls{target machine}.
%
\Glspl{constraint} that callee arguments (that is, arguments to the
\gls{function} under compilation) must reside in a specific \gls{location} are
modeled as
%
\begin{equation}
  \mVar{loc}[d] \in \mArgLoc(d)
  \mQuantSep
  \forall d \in \mArgSet,
  \labelEquation{function-args}
\end{equation}
%
where \mbox{$\mArgSet \subseteq \mDataSet$} denotes the set of \gls{function}
arguments in $\mUFGraph$ and \mbox{$\mArgLoc(d) \subseteq \mLocationSet$}
denotes the set of \glspl{location} in which argument~$d$ resides.
%
Arguments residing on the stack can be signified by introducing another special
\gls{location}, thus requiring a memory load \gls{instruction} in order to be
used by other \glspl{instruction}.

\Glspl{location} for caller arguments (that is, arguments to \glspl{function}
calls made from within the \gls{function} under compilation) can be enforced
either through \refEquation{function-args} or through
\refEquation{compatible-locations}.
%
If the calling convention depends on the \gls{instruction} selected then the
former is needed, otherwise the latter is more suitable as the restrictions can
be enforced before a \gls{match} is selected.\!%
%
\footnote{%
  If exactly one \gls{match}~$m$ can cover a given \gls{function} call
  \gls{node}, then both \glspl{constraint} provide the same amount of
  \gls{propagation} as \mbox{$\mVar{sel}[m] = 1$} will always hold for the
  implication in \refEquation{compatible-locations}.
}


\section{Modeling Value Reuse}
\labelSection{modeling-value-reuse}

Code quality can be increased if \glspl{instruction} are allowed to reuse copies
of values, which is a crucial feature to be expected in the code emitted by any
modern \gls{instruction selector}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  A UF graph with two matches%
                  \labelFigure{value-reuse-example-uf-graph}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-uf-graph}}%
  \hfill%
  \subcaptionbox{%
                  UF graph after copy extension%
                  \labelFigure{value-reuse-example-after-ce}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-after-ce}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Redundant copying of values%
                  \labelFigure{value-reuse-example-redundant-copies}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    value-reuse-example-redundant-copies%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Reuse of copied value%
                  \labelFigure{value-reuse-example-one-copy}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/value-reuse-example-one-copy%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of value reuse}
  \labelFigure{value-reuse-example}
\end{figure}
%
See for example \refFigure{value-reuse-example}.
%
Originally, the \gls{UF graph} has a value~\irVar{v} which is used by two
\glspl{operation} coverable by \glspl{match}~$m_1$ and~$m_2$
(\refFigure{value-reuse-example-uf-graph}).
%
After \gls{copy extension}, $m_1$ and $m_2$ use their own private copy --
\irVar{v}[1] and \irVar{v}[2], respectively -- of \irVar{v}
(\refFigure{value-reuse-example-after-ce}).
%
Assume that both $m_1$ and $m_2$ require its copy of \irVar{v} to reside in a
\gls{location} different from \irVar{v} -- \irVar{v} may reside on the stack,
for instance -- which means that selection of $m_1$ or $m_2$ also entails
emission of a copy \gls{instruction}.
%
With the \glsshort{constraint model} introduced thus far, two copy
\glspl{instruction} will be emitted if both $m_1$ and $m_2$ are selected
(\refFigure{value-reuse-example-redundant-copies}).
%
However, if \irVar{v}[1] and \irVar{v}[2] could reside in the same
\gls{location} then either of the values could be reused by either \gls{match},
thus necessitating only one copy \gls{instruction}
(\refFigure{value-reuse-example-one-copy}).
%
We call this notion \gls!{value reuse}.

In this dissertation, we discuss two methods for reusing values: \gls{match
  duplication} and \glspl{alternative value}.
%
We first introduce each in turn and then present experiments showing that one is
superior to the other.


\subsection{Match Duplication}

The idea behind \gls!{match duplication} is to duplicating appropriate
\glspl{match} in the \gls{match set} where \gls{value reuse} is possible.
%
We first say that two values~$v_1$ and~$v_2$ are \gls!{copy-related.d} if and
only if they are copies of the same value and $v_1$ and $v_2$ have the same data
type (the second clause is necessary as copies of constants may be of different
data types and are therefore not interchangeable).
%
Then, for each \gls{match}~$m$, we create a new \gls{match} for each permutation
of \glspl{datum} that are \gls{copy-related.d} to the \glspl{input datum} in
$m$, where an \gls!{input datum} is a \gls{datum} \gls{use.d}[d] but not
\gls{define.d}[d] by~$m$.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{match-duplication-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After match duplication%
                  \labelFigure{match-duplication-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of match duplication}
  \labelFigure{match-duplication-example}
\end{figure}
%
See for example \refFigure{match-duplication-example}.
%
The \gls{match set} contains a \gls{match}~$m$ that uses value~\irVar{v}[1],
which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{match-duplication-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we duplicate $m$ to instead
use \irVar{v}[2], resulting in match~$m'$
(\refFigure{match-duplication-example-after}).

The main advantage of \gls{match duplication} is that no changes need to be done
for the \gls{constraint model}; the decision of which value to use (and reuse)
depends entirely on the selection of \glspl{match}.
%
However, this comes at a cost of inflating the \gls{match set}, which in turn
inflates the \gls{search space}.
%
If a \gls{match} has $k$~\glspl{input datum}, each with $n$~\gls{copy-related.d}
values, then $\mBigO(n^k)$ new \glspl{match} will be created.
%
Although the decision of \gls{value reuse} is intuitively orthogonal to the
decisions of selecting a \gls{match} and placing it into a \glspl{block}, these
decisions must be remade for each new \gls{match}, thereby enlarging the
\gls{search space} with many symmetric \glspl{solution}.


\subsection{Alternative Values}

Instead of expanding the \gls{match set} (like in \gls{match duplication}), we
can postpone the decision of which \gls{input datum} to use for a particular
\gls{match} and integrate it as part of the \gls{constraint model}.
%
The idea is as follows.
%
For each \gls{match}~$m$, let every \glspl{input datum}~$d$ in $m$ be mapped to
any \gls{datum} that is \gls{copy-related.d} to~$d$.
%
In other words, unlike before when a \gls{match} was \mbox{1-to-1} mapping
between \glspl{node} in the \gls{UP graph} and \glspl{node} in the \gls{UF
  graph}, we now allow certain mappings to be a \mbox{1-to-$n$} mapping.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{alt-values-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-without%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  With alternative values%
                  \labelFigure{alt-values-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-with%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of alternative values}
  \labelFigure{alt-values-example}
\end{figure}
%
See for example \refFigure{alt-values-example}.
%
Again, the \gls{match set} contains a \gls{match}~$m$ that uses
value~\irVar{v}[1], which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{alt-values-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we extend the mapping from
$n$ to \irVar{v}[1] to include \irVar{v}[2], where $n$ is the corresponding
\gls{value node} in the \gls{UP graph} of~$m$
(\refFigure{alt-values-example-after}).
%
In this context, \irVar{v}[1] and \irVar{v}[2] are said to be
\glspl!{alternative value} to~$m$.
%
For convenience, we assume that the set of \glspl{alternative value} for each
non-\gls{input datum}~$d$ in a \gls{match} contains only the \glsshort{state
  node} or \gls{value node} to which $d$ is already mapped.

Special care must be taken to \glspl{match} derived from the \gls{phi-pattern}.
%
Assume, for example, that the \gls{match}~$m$ using value~\irVar{v}[1] in
\refFigure{alt-values-example-before} is a \gls{phi-match}.
%
This means that \irVar{v}[1] will participate in a \gls{definition edge},
forcing \irVar{v}[1] to be \gls{define.d}[d] in some \gls{block}.
%
If $m$ is extended as in \refFigure{alt-values-example-after}, then $m$ is
allowed to make use of value~\irVar{v}[2], which does not participate in the
\gls{definition edge} and hence could break \gls{program} semantics.
%
There are two approaches to fixing this problem:
%
\begin{figure}
  \centering%
  \input{figures/constraint-model/ext-phi-pattern}

  \caption{Extended $\mPhi$-pattern}
  \labelFigure{ext-phi-pattern}
\end{figure}
%
\begin{inlinelist}[label=(\roman*), itemjoin={; }, itemjoin*={; or\ }]
  \item either all \glspl{phi-match} are excluded from being extended with
    \glspl{alternative value}
  \item the \gls{phi-pattern} is extended with \glspl{block node} and
    \glspl{definition edge}, as shown in \refFigure{ext-phi-pattern}, which
    allows the value placement restrictions to be captured as part of the
    \gls{match}
\end{inlinelist}.
%
The former is simpler but interferes with an \gls{implied.c} \gls{constraint}
(\refEquation{kill-matches-symmetry-breaking}) to be introduced in
\refChapter{solving-techniques}, which may remove potentially optimal
\glspl{solution}.
%
Consequently, we apply the latter.
%
The extended \gls{phi-pattern} assumes that no value is used more than once by
the same \gls{phi-node}, and that no pair of values used by the same
\gls{phi-node} have \glspl{definition edge} to the same \gls{block}.
%
These invariants can be achieved by transforming the \gls{function} before
\gls{pattern matching}.

After having extended the \gls{match set} with \glspl{alternative value}, the
next step is to extend the \gls{constraint model} with an another level of
indirection wherever a \gls{constraint} refers to a \gls{datum}.


\subsubsection{Variables}

Assume first that each \glsshort{define.d}[ition] or \glsshort{use.d}[age] of
\glspl{datum} within each \gls{match} incurs a unique \gls!{operand}.
%
Consequently, instead of \glsshort{define.d}[ing] and \glsshort{use.d}[ing]
\glspl{datum}, we now assume that all \glspl{match} \gls{define.d} and
\gls{use.d} \glspl{operand}.
%
Hence the set of \glspl{variable} \mbox{$\mVar{alt}[p] \in \mDataSet[p]$} models
to which \gls{datum} \gls{operand}~\mbox{$p \in \mOperandSet$} is mapped, where
\mbox{$\mDataSet[p] \subseteq \mDataSet$} denotes the set of \glspl{alternative
  value} for~$p$, and $\mOperandSet$ denotes the set of \glspl{operand} incurred
by~$\mMatchSet$.


\subsubsection{Constraints}

As stated previously, the aim is to add another level of indirection whenever a
\gls{constraint} refers to a \gls{datum}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} now denote the set of \glspl{operand}
(instead of \glspl{datum}) \gls{define.d}[d] respectively \gls{use.d}[d] by
\gls{match}~$m$.
%
With these new definitions, Eqs.\thinspace\refEquation*{naive-dom},
\refEquation*{spanning}, and~\refEquation*{compatible-locations} are adjusted
accordingly (the changes are highlighted in grey):
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mDom(\mVar{oplace}[o]) \\
    \forall m \in \mPhiMatchCompSet,
    \forall \hlDiff{p} \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{naive-dom-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in
      \mSet{\mVar{oplace}[o]} \cup \mSpans(m) \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{spanning-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mStores(m, \hlDiff{p}) \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m) \cup \mUses(m),
  \end{array}
  \labelEquation{compatible-locations-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[\hlDiff{\mVar{alt}[p_1]}] = \mVar{loc}[\hlDiff{\mVar{alt}[p_2]}]
    \\
    \forall m \in \mPhiMatchSet,
    \forall \hlDiff{p}_1 \hspace{-.8pt}, \hlDiff{p}_2 \in
      \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{phi-match-locations-alt}
\end{equation}

Due to these changes there may be \glspl{datum} that is not \gls{use.d}[d] by
any \gls{match}, yet \refEquation{data-definitions} still requires that every
\gls{datum} must be \gls{define.d}[d] by some \gls{match}.
%
We address this by extending the \gls{pattern set} with a \gls!{kill pattern}
(shaped like \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, where $v$ and $v'$ are
\glspl{value node} and $c$ is a \gls{copy node}).
%
\Glspl{match} derived from this \gls{pattern} are called \glspl!{kill match},
which have zero cost and emit nothing if selected.
%
A \gls{datum} is said to be \gls!{killed.d} if and only if it is
\gls{define.d}[d] by a \gls{kill match}, and non-\glspl{kill match} are only
allowed to make use of not \gls{killed.d} \glspl{datum}.

To model whether a \gls{datum} is \gls{killed.d}, we extend the \gls{location
  set} with a special \gls{location}~$\mKilledLocation$ and require that a
\gls{kill match}~$m$ is selected if and only if the \gls{location} of the
\gls{datum} \gls{define.d}[d] by $m$ is $\mKilledLocation$.
%
This is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mEq \mVar{loc}[\mVar{alt}[p]] = \mKilledLocation \\
    \forall m \in \mKillMatchSet,
    \forall p \in \mDefines(m).
  \end{array}
  \labelEquation{killed-data}
\end{equation}
%
where $\mKillMatchSet$ denotes the set of \glspl{kill match}.

Lastly, we need to enforce the value placements appearing in the
\glspl{phi-match}.
%
Let $\mMatchDefEdgeSet$ denote this set of value placements, encoded as a
tuple~\mbox{$\mTuple{m, b, p}$} for each \gls{definition edge} between a
\gls{block}~$b$ and an operand~$p$ appearing in \gls{match}~$m$.
%
These \glspl{constraint} are then modeled as
%
\begin{equation}
  \mVar{sel}[m] \mImp \mVar{dplace}[\mVar{alt}[p]] = b
  \mQuantSep
  \forall \mTuple{m, b, p} \in \mMatchDefEdgeSet.
  \labelEquation{match-def-edges}
\end{equation}


\subsection{Experimental Evaluation}
\labelSection{cm-alt-values-experimental-evaluation}

We evaluate the two methods for \gls{value reuse} by comparing the time it takes
to solve two versions of the \gls{constraint model} -- one based on \gls{match
  duplication} and another based on \glspl{alternative value} -- for the set of
sampled \glspl{function}.
%
To evalute the impact of \gls{value reuse}, we compare the cost of the optimal
\gls{solution} produced by one of the \glsplshort{constraint model} above (since
both methods are \gls{solution}-preserving, it does not matter which is
selected) with the cost of the optimal \gls{solution} produced by a
\gls{constraint model} without \gls{value reuse}.


\subsubsection{Setup}

Each \gls{constraint model} is implemented in \mbox{\gls{MiniZinc}
  2.1.6}~\cite{NethercoteEtAl:2007} -- a high-level \gls{constraint} modeling
language -- and solved using \gls{Chuffed}~\cite{Chu:2011} -- a \gls{lazy clause
  learning} \glsshort{constraint solver}, which is included in \gls{MiniZinc} --
on a Linux machine with an \gls{Intel} Xeon W3530 at \SI{2.80}{\GHz} and
\SI{16}{\giga\byte} main memory.

As input, we use a subset of the \glspl{function} in
\gls{MediaBench}~\cite{LeeEtAl:1997} -- a benchmark suite for embedded systems
-- and the \glspl{instruction} in \gls{Hexagon}~V5 -- a \gls{DSP} with a rich
\gls{instruction set}.
%
The \glspl{function} are compiled into \gls{LLVM} \gls{IR} code -- the
intermediate format used by \gls{LLVM} -- using \mbox{\gls{LLVM} 3.8} with
optimization flag~\texttt{-O3}.
%
Out of the initial pool of \num{6313}~\glspl{function}, we remove those that
operate on non-integer data types (such as floating point and vector data types)
as these are not yet supported by the current toolchain.
%
We also remove all \glspl{function} that have less than less than ten~\gls{LLVM}
\gls{IR} \glspl{instruction} -- anything smaller will most likely not be
benefitted by \gls{value reuse} -- and greater than \num{50}~\glspl{instruction}
-- anything larger will lead to unreasonably long solving times.
%
This leaves a pool of \num{453}~\glspl{function}, which will lead to untractable
experiment runtimes if all are included.
%
We therefore draw a limited number of samples from this pool.
%
To get a diverse set of samples, we apply \gls{k-means
  clustering}~\cite{PhansalkarEtAl:2005} to divide the \glspl{function} into
twenty clusters based on the application from which the \gls{function} is
derived (intuitively, \glspl{function} from different applications should
exhibit different characteristics), its size in number of \gls{LLVM} \gls{IR}
\glspl{instruction} (to evaluate how the methods behave as the \glspl{function}
grow larger), and its number of memory \glspl{instruction} (due to its many
addressing modes, many of which allowing constants to be loaded as part of the
\gls{instruction}, these constitute a large part of the complex
\glspl{instruction} in the \gls{instruction set}).
%
Then, from each cluster one \gls{function} is randomly selected, giving a total
of twenty \glspl{function}.
%
Since we are measuring solving time, which could be affected by other factors,
we run each experiment ten times and then take the arithmetic average.
%
When summarizing ratios, we instead take the geometric mean as it is more
appropriate in such cases~\cite{FlemingWallace:1986}.


\subsubsection{Normalizing Measurements}

\newcommand{\speedupCase}[1]{\textrm{\textsc{#1}}}

When we are interested in the relative difference between the measurements, we
normalize all values to those obtained from one \glsshort{constraint model}
which has been chosen as the \gls!{baseline}.
%
In this context, the other \glsplshort{constraint model} are called the
\glspl!{subject}.

For time measurements, the most typical method for normalization is to calculate
the \gls!{speedup}, which is computed as
%
\begin{equation}
  S = \frac{t_b}{t_a}
  \labelEquation{speedup-normalization}
\end{equation}
%
where $t_a$ and $t_b$ denotes time measurements obtained for a given problem
instance from \gls{subject} \glsshort{constraint model}~$a$ and \gls{baseline}
\glsshort{constraint model}~$b$.
%
A value greater than $1$ means $a$ is faster than $b$, a value less than $1$
means $b$ is faster than $a$, and a value of exactly $1$ means $a$ and $b$ take
the same time to solve a given \gls{function}.
%
Since the normalized values are centered around $1$, then intuitively the
normalized value when $a$ is twice as fast as $b$ should be equally far away
from $1$ as the normalized value when $b$ is twice as fast as $a$.
%
With \refEquation{speedup-normalization}, however, this is not the case.
%
See for example \refFigure{speedup-comparison-traditional}, illustrating two
cases: \speedupCase{i}, where $a$ is twice as fast as $b$; and \speedupCase{ii},
where $b$ is twice as fast as $a$.
%
\begin{figure}
  \renewcommand{\functionName}[1]{{\Large\speedupCase{#1}}}%
  \renewcommand{\plotSpeedupTicsFont}{\large}%
  \renewcommand{\barValueFont}{\scriptsize}%

  \def\insertSpeedupExamplePlot#1{%
    \maxsizebox{30mm}{!}{%
      \trimbox{18pt 8pt 74mm 45mm}{%
        \input{figures/constraint-model/speedup-example-#1.plot}%
      }%
    }%
  }%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Values normalized using speedup
                  (\refEquation{speedup-normalization})%
                  \labelFigure{speedup-comparison-traditional}%
                }%
                [40mm]%
                {%
                  \insertSpeedupExamplePlot{traditional}%
                }%
  \hfill%
  \subcaptionbox{%
                  Values normalized using zero-centered normalization
                  (\refEquation{zero-centered-normalization})%
                  \labelFigure{speedup-comparison-normalized}%
                }%
                [50mm]%
                {%
                  \insertSpeedupExamplePlot{normalized}%
                }%
  \hfill%
  \mbox{}

  \caption[Comparison between two methods for normalizing measurements]%
          {%
            Comparison between the two methods for normalizing measurements.
            %
            The comparison is done for two problem instances: one where the
            subject is twice as fast as the baseline (\speedupCase{i}), and
            another where the baseline is twice as fast as the subject
            (\speedupCase{ii})%
          }%
  \labelFigure{speedup-comparison}%
\end{figure}
%
We therefore normalize the values using a different method~[\todo{source?}]
when plotting such values.
%
In this dissertation the method is called \gls!{zero-centered normalization},
which is computed as
%
\begin{equation}
  S =
  \left\{
  \begin{array}{ll}
    \frac{t_b - t_a}{t_a} & \text{if $t_b \geq t_a$,} \\
    \frac{t_b - t_a}{t_b} & \text{otherwise.}
  \end{array}
  \right.
  \labelEquation{zero-centered-normalization}
\end{equation}
%
As seen in \refFigure{speedup-comparison-normalized}, this method results in
normalized values that are centered around $0$ (hence its name) and, unlike the
\gls{speedup} method, are equally far apart in the case of \speedupCase{i} and
\speedupCase{ii}.
%
Hence, a normalized value \mbox{$v \geq 0$} in \gls{zero-centered normalization}
corresponds a \gls{speedup} of \mbox{$v + 1$}.

\Gls{zero-centered normalization} is also applied when comparing \gls{solution}
costs as they represent an estimate of the time it would take to execute the
code yielded by the \glspl{solution} (our current implementation is not yet able
to hook back into \gls{LLVM} in order to generate executable code).

When summarizing normalized values, however, we do not use \gls{zero-centered
  normalization} as the geometric mean cannot be computed for such values.
%
In such cases, we instead use the values normalized using the \gls{speedup}
method as the geometric mean can be computed for such values, which we call the
\gls!{GMI}.
%
A result is considered positive or negative if the \gls{GMI} is greater than
respectively less than~\num{1}.
%
In terms of solving time, for example, a \gls{subject} method~$a$ leads to an
overall reduction over another \gls{baseline} method~$b$ if the \gls{GMI} is
greater than~\num{1}.
%
If the \gls{GMI} is close to~\num{1}, it may not be clear whether the result is
statistically significant.
%
In such cases, we compute the \num{95}\textsuperscript{th} \gls{CI} for the
\gls{GMI} using percentile bootstrapping with \num{100000} iterations.
%
If the \gls{CI} contains~\num{1}, then we cannot statistically conclude whether
the result is positive or negative.


\subsubsection{Match Duplication vs. Alternative Values}

We evaluate the two methods of \gls{value reuse} by comparing the solving time
exhibited by a \gls{constraint model} based on \gls{match duplication} and
another \glsshort{constraint model} based on \glspl{alternative value} for the
set of \glspl{function} selected from \gls{MediaBench}.
%
Since \gls{match duplication} yields an exponential increase in number of
\glspl{match} compared to \glspl{alternative value}, we expect the latter to
lead to an overall reducation in solving time.
%
Hence the \gls{GMI} should be greater than~\num{1}.

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/alt-values-vs-match-dup-pre+solving-time-speedup.plot}%
    }%
  }

  \caption[%
            Plot for evaluating match duplication's and alternative values'
            impact on solving time%
          ]%
          {%
            Normalized solving times (incl.\ presolving time) for two
            constraint models that supports value reuse, one based on match
            duplication (baseline) and another based on alternative values
            (subject)%
          }
  \labelFigure{alt-values-vs-match-dup-solving-time-plot}
\end{figure}

\input{\expDir/alt-values-vs-match-dup-pre+solving-time-speedup.stats}

\RefFigure{alt-values-vs-match-dup-solving-time-plot} shows the normalized
solving times (including presolving time) for the two \glspl{constraint
  model} described above, with the \glsshort{constraint model} based on
\gls{match duplication} serving as \gls{baseline} and the \glsshort{constraint
  model} based on \glspl{alternative value} serving as \gls{subject}.
%
All \glspl{function} are solved to optimality.
%
The solving times range from
\SIMinOf{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupSolvingTimeAvgMin,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMin
}{\s}
to
\SIMinOf{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupSolvingTimeAvgMax,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMax
}{\s}
with a maximum coefficient of variation of
\numMaxOf{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeCvMax,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselinePrePlusSolvingTimeCvMax
}.
%
As the \gls{GMI} is \printGMI{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
}{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
}, we conclude that \glsplshort{constraint model} based on
\glspl{alternative value} yield significantly lower solving times than those
based on \gls{match duplication}.
%
In one case ({\codeFont reg2rsaref}), for example, the solving time differs by
nearly a factor of~$50$, which is due to a high rate of \gls{copy-related.d}
values for which \glspl{alternative value} yield only \num{94}~\glspl{match}
whereas \gls{match duplication} yields \num{537}~\glspl{match}.
%
Hence, when implementing \gls{value reuse}, \glspl{alternative value} is a
better design choice over \gls{match duplication}.


\subsubsection{Impact of Value Reuse}

We evaluate the impact of \gls{value reuse} by comparing the cost (that is, the
total number of cycles, as described in \refSection{cm-objective-function}) of
the optimal \glspl{solution} produced by a \gls{constraint model} with
\gls{value reuse} support (based on \glspl{alternative value}) and another
without this support for the set of \glspl{function} selected from
\gls{MediaBench}.
%
Since \gls{value reuse} reduces the number of selected copy \glspl{instruction},
we expect the former to lead to an overall reduction in cost.
%
Hence the \gls{GMI} should be greater than~\num{1}.

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/alt-values-vs-without-cycles-speedup.plot}%
    }%
  }

  \caption[Plot for evaluating value reuse's impact on code quality]%
          {%
            Normalized optimal solution costs for two constraint models, one
            without value reuse support (baseline) and another with such support
            (subject)%
          }
  \labelFigure{alt-values-vs-without-cycles-plot}
\end{figure}

\input{\expDir/alt-values-vs-without-cycles-speedup.stats}

\RefFigure{alt-values-vs-without-cycles-plot} shows the normalized
\gls{solution} costs for the two \glspl{constraint model} describe above, with
the \glsshort{constraint model} without \gls{value reuse} support serving as
\gls{baseline} and the \glsshort{constraint model} with \gls{value reuse}
support serving as \gls{subject}.
%
All \glspl{function} are solved to optimality.
%
The costs range from
\numMinOf[round-precision=0]{%
  \AltValuesVsWithoutCyclesSpeedupCyclesAvgMin,
  \AltValuesVsWithoutCyclesSpeedupBaselineCyclesAvgMin
}~cycles to
\numMaxOf[round-precision=0]{%
  \AltValuesVsWithoutCyclesSpeedupCyclesAvgMax,
  \AltValuesVsWithoutCyclesSpeedupBaselineCyclesAvgMax
}~cycles.
%
As the \gls{GMI} is \printGMI{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMax%
}, we conclude that \glsplshort{constraint model} supporting \gls{value reuse}
produce \glspl{solution} with considerably lower cost than those without.
%
In one case ({\codeFont putseqdispext}), for example, where two constants are
frequently used as arguments to \gls{function} call \glspl{instruction} and thus
cannot be loaded as immediates, the cycle count is reduced from \num{256}~cycles
to \num{208}~cycles.
%
Hence, the impact of \gls{value reuse} is significant in reducing the number of
copy \glspl{instruction} and, subsequently, lowering cost.


\section{Modeling Block Ordering}
\labelSection{modeling-block-ordering}

Ordering the \glspl{block} in a \gls{function} entails finding a sequence~$s$
such that each \gls{block} appears exactly once in~$s$\hspace{-.8pt}.
%
Depending on the control-flow \glspl{instruction} selected, some \glspl{block}
may need to be adjacent.
%
For example, assume a \gls{block}~$b$ that branches to either of two
\glspl{block}~$c$ and~$d$ depending on whether a condition holds.
%
Assume also that the conditional branching in $b$ is implemented using an
\gls{instruction} that branches to $c$ if the condition holds, otherwise it
continues the execution with the next \gls{instruction} in the \gls{assembly
  code}.
%
This notion of execution is called \gls!{fall-through}, and due to this, $d$
must be placed immediately after $b$ in the sequence.

For some combinations of \glspl{function} and \glspl{target machine} with
\gls{fall-through} \glspl{instruction}, there exist no valid \gls{block}
sequence without inserting one or more additional jump \glspl{instruction}.
%
\begin{figure}
  \setlength{\opNodeDist}{20pt}%
  \tikzset{
    block node/.append style={
      minimum width=2cm,
      minimum height=.9\opNodeSize,
    },
  }%

  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{jump-insert-example-cfg}}%
                [34mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-cfg}%
                }%
  \hfill%
  \subcaptionbox{%
                  Valid block sequences, after jump insertion%
                  \labelFigure{jump-insert-example-solutions}%
                }%
                [65mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-sol1}%
                  \hspace{6mm}%
                  \input{figures/constraint-model/jump-insert-example-sol2}%
                }%
  \hfill%
  \mbox{}

  \caption[Example that requires additional jump instructions]%
          {%
            Example that requires additional jump instructions.
            %
            It is assumed that the conditional {\instrFont br}~instruction
            falls through to the next instruction if the condition is false%
          }
  \labelFigure{jump-insert-example}
\end{figure}
%
See for example \refFigure{jump-insert-example}.
%
\Glspl{block}~\irBlock{A} and~\irBlock{B} both contain control-flow
\glspl{instruction} that branches to the beginning of \irBlock{B} if the
condition holds, otherwise they should branches to block~\irBlock{C}
(\refFigure{jump-insert-example-cfg}).
%
Because of the fall-through \gls{constraint}, \irBlock{A} and \irBlock{B} cannot
both have \irBlock{C} as its successor \gls{block}.
%
Hence an additional jump \gls{instruction} that directly branches to \irBlock{C}
must be inserted after the control-flow \gls{instruction} in either \irBlock{A}
or~\irBlock{B} (\refFigure{jump-insert-example-solutions}).

In this dissertation, we discuss two methods for inserting jump
\glspl{instruction} when required: \gls{branch extension} and \glspllong{DTB
  pattern}.
%
We first introduce the \glspl{variable} and \glspl{constraint} for modeling
\gls{block ordering} before introducing each method in turn, and then present
experiments showing that one is superior to the other.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{succ}[b] \in \mBlockSet$} models the
successor of block~$b$\hspace{-.5pt}.
%
For example, if \mbox{$\mVar{succ}[b] = b'$}, then \gls{block}~$b'$ will appear
immediately after \gls{block}~$b$ in the \gls{block ordering} sequence.


\subsubsection{Constraints}

A \gls{solution} to the \gls{block ordering} problem is a sequence of
\gls{block} successors such that they form a \gls{cycle}.
%
Using the \gls{circuit constraint} defined in
\refChapter{constraint-programming} on \refPageOfDefinition{circuit}, this
\gls{constraint} is modeled as
%
\begin{equation}
  \mCircuit(\mVar{succ}[b_1], \ldots, \mVar{succ}[b_n]),
  \labelEquation{block-order}
\end{equation}
%
where \mbox{$b_1, \ldots, b_n = \mBlockSet$}.

If a \gls{match}~$m$ with an \gls{entry block} is derived from an
\gls{instruction} that performs a \gls{fall-through} to \gls{block}~$b$, then
the \gls{constraint} can naively be modeled as \mbox{$\mVar{sel}[m] \mImp
  \mVar{succ}[\mEntry(m)] = b$}.
%
However, this \gls{constraint} is too limiting as it disallows empty
\glspl{block} to be placed between $\mEntry(m)$ and~$b$\hspace{-.5pt}, thus
forcing redundant jump \glspl{instruction} to be emitted.
%
A \gls{block}~$b$ is considered empty if either no \glspl{match} are placed in
$b$ or every \gls{match} in $b$ is a \gls!{null match}, which is a \gls{match}
that emits nothing if selected.
%
As empty \glspl{block} are not uncommon to appear in the \gls{function} under
compilation -- especially when having performed \gls{global code motion} -- this
has a significant impact on code quality.
%
Hence we extend the naive implementation into a disjunction, where the second
clause captures \glspl{fall-through} via single empty \glspl{block}.
%
Let $\mFallThroughSet$ denote a set of pairs~$\mPair{m}{b}$, where $m$ is a
\gls{match} and $b$ is a \gls{block} through which $m$ will fall if selected,
and let $\mNullMatchSet$ denote the set of \glspl{null match}.
%
With these definitions, the \gls{fall-through} \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{succ}[\mEntry(m)] = b \mOr \mbox{} \\
    \big(
      \mVar{succ}[\mVar{succ}[\mEntry(m)]] = b
      \mAnd
      \mEmptyBlock(\mVar{succ}[\mEntry(m)])
    \big) \\
    \forall \mPair{m}{b} \in \mFallThroughSet,
  \end{array}
  \labelEquation{fall-through}
\end{equation}
%
where
%
\begin{equation}
  \mEmptyBlock(b)
  \equiv
  \mVar{oplace}[o] \neq b
  \mOr
  \mVar{omatch}[o] \in \mNullMatchSet
  \mQuantSep
  \forall o \in \mOpSet\hspace{-.8pt}.
\end{equation}

If a \gls{block}~$b$ unconditionally branches to another \gls{block}~$b'$ and
$b'$ appears immediately after $b$ in the \gls{block} sequence, then a jump
\gls{instruction} is redundant.
%
To prevent emission of such jump \glspl{instruction}, we extend the \gls{pattern
  set} with a special \gls!{null-jump pattern}, with \gls{graph} structure
\mbox{$\mEdge{b}{\mEdge{c}{b'}}$}, that covers a \gls{control node}~$c$ at zero
cost provided that \mbox{$\mVar{succ}[b] = b'$}.

\Glspl{fall-through} to or via the \gls{function}'s \gls{entry block} is never
allowed since that \gls{block} must always be placed first in the \gls{block}
sequence.
%
If $\mFunctionEntryBlock$ denotes the \gls{function}'s \gls{entry block}, then
this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{succ}[\mEntry(m)] \neq \mFunctionEntryBlock \\
    \forall \mPair{m}{\_} \in \mFallThroughSet.
  \end{array}
  \labelEquation{no-fall-through-to-fun-entry}
\end{equation}


\subsection{Branch Extension}

One method of inserting jump \glspl{instruction} is to extend the \gls{UF graph}
with additional \glsshort{block node} and \glspl{control node}.
%
The idea is as follows.
%
For each \gls{control-flow edge}~$\mPair{c}{b}$, where $c$ is a \gls{control
  node} and $b$ is a \gls{block node}, we remove this \gls{edge} and insert a
new \gls{block node}~$b'$ and \gls{control node}~$c'$, and \glspl{control-flow
  edge} such that \mbox{$\mEdge{c}{\mEdge{b'}{\mEdge{c'}{b}}}$}.
%
If the new \glspl{control node} are indeed redundant, then each such \gls{node}
can be covered by a \gls{match} derived from the \gls{null-jump pattern},
causing the new \glspl{block} to become empty and appear immediately before the
target \gls{block}.
%
Like with \gls{copy extension}, to retain matching \gls{branch extension} must
also be performed on each \gls{UF graph} in the \gls{pattern set}.

The disadvantage of \gls{branch extension} is that it inflates the \gls{search
  space}.
%
The number of \glsshort{block node} and \glspl{control node} both increase by
$\mBigO(nk)$, where $n$ is the number of \glspl{block} before \gls{branch
  extension} and $k$ is the highest number of \gls{outbound.e}
\glspl{control-flow edge} from a \gls{control node} in the \gls{UF graph}.
%
This leads to more \glspl{operation} to be covered and more \glspl{block}
wherein an \gls{operation} may be placed.
%
In addition, as the majority of the new \glspl{block} will be empty, situations
often arise where a control-flow \gls{instruction} could successfully fall
through more than one \gls{block}.
%
Because of \refEquation{fall-through}, however, it can only fall through at most
one empty \gls{block}, causing emission of redundant jump \glspl{instruction}
that would not have been emitted had \gls{branch extension} not been performed.


\subsection{Dual-target Branch Patterns}

\def\jmpPattern{p_{\textsc{jmp}}}%

\glsreset{DTB pattern}

Another method is to extend the \gls{pattern set} with so-called \glspl!{DTB
  pattern}.
%
Given a \gls{pattern set}~$S$, first find the \gls{pattern}~\mbox{$\jmpPattern
  \in S$} which corresponds to a unconditional jump \gls{instruction} that
directly branches to a given label (it is reasonable to assume such a
\gls{pattern} always exist for any given \gls{target machine}).
%
Let \mbox{$\mCost(p)$} and \mbox{$\mEmits(p)$} denote the cost of pattern~$p$
respectively the sequence of \glspl{instruction} emitted by $p$ if selected.
%
Then, for each \gls{pattern}~\mbox{$p \in S$} which corresponds to a conditional
jump \gls{instruction} that falls through to a given block~$b$, add to $S$ a new
\gls{pattern}~$p'$ that is a copy of $p$ but has no \gls{fall-through}
\gls{constraint}, emits $\mEmits(p)$ followed by $\mEmits(\jmpPattern)$, and has
cost \mbox{$\mCost(p) + \mCost(\jmpPattern)$}.
%
\begin{figure}
  \subcaptionbox{%
                  A pattern that falls through to the \irBlock{false} block%
                  \labelFigure{dual-target-branch-pattern-example-original}%
                }%
                [68mm]%
                {%
                  \begin{tabular}{c}
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true} & $2$\\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  New pattern, without fall-through%
                  \labelFigure{dual-target-branch-pattern-example-copy}%
                }%
                [52mm]%
                {%
                  \begin{tabular}{c}
                    \newcommand{\fallthruString}{}%
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true}
                      & $2 + \mCost\hspace{.4pt}(\jmpPattern)$\\
                        $\mEmits(\jmpPattern)$
                      & \\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }

  \caption{Example of creating a DTB pattern}%
  \labelFigure{dual-target-branch-pattern-example}
\end{figure}
%
An example is shown in \refFigure{dual-target-branch-pattern-example}.
%
Because a \gls{DTB pattern} has no \gls{fall-through} \gls{constraint}, it
essentially models a conditional jump \gls{instruction} capable of directly
branching to two \glspl{block} (hence the name).

Consequently, if a \gls{pattern set} contains $k$~\glspl{pattern} with
\gls{fall-through} \glspl{constraint} and a \gls{UF graph} contains
$n$~\glspl{control node} representing conditional jumps, then using \glspl{DTB
  pattern} will enlarge the \gls{match set} by $\mBigO(nk)$~\glspl{match}.
%
Unlike \gls{branch extension}, however, the \gls{UF graph} does not need to be
extended with additional \glspl{block} wherein \glspl{operation} may be placed,
which results in a significantly smaller \gls{search space}.


\subsection{Experimental Evaluation}

We evaluate the two methods for inserting jump \glspl{instruction} by comparing
the solving times exhibited and the cost of the optimal \glspl{solution}
produced by two versions of the \gls{constraint model} -- one based on
\gls{branch extension} and another based on \glspl{DTB pattern} -- for the set
of sampled \glspl{function}.

The experiment setup is the same as in
\refSection{cm-alt-values-experimental-evaluation} with a few exceptions.
%
When filtering, we remove all \glspl{function} that have less than less than
\num{20}~\gls{LLVM} \gls{IR} \glspl{instruction} -- anything smaller will most
likely not require any additional jump \glspl{instruction} -- and greater than
\num{100}~\glspl{instruction} -- anything larger will lead to needlessly long
experiment runtimes.
%
This leaves a pool of \num{413}~\glspl{function}, from which
\num{20}~\glspl{function} are sampled using the same method.
%
When clustering, however, the \glspl{function} are grouped according to number
of \glspl{block} instead of number of memory \glspl{instruction} (to evaluate
how the methods behave as the number of blocks grow larger).

Since \gls{branch extension} yields a larger number of \glspl{block} compared to
\glspl{DTB pattern}, many of which will be empty and thereby
causing emission of redundant jump \glspl{instruction}, we expect the latter to
lead to both shorter solving times and better code quality.
%
Hence the \gls{GMI} for both should be greater than~\num{1}.

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{%
        \expDir/%
        dual-target-patterns-vs-branch-ext-pre+solving-time-speedup.plot%
      }%
    }%
  }

  \caption[%
            Plot comparing solving times for two constraint models supporting
            jump instruction insertion%
          ]%
          {%
            Normalized solving times (incl.\ presolving time) for two
            constraint models that supports jump insertion, one based on branch
            extension (baseline) and another based on DTB patterns (subject)%
          }
  \labelFigure{%
    dual-target-branch-patterns-vs-branch-extension-solving-time-plot%
  }
\end{figure}

\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/dual-target-patterns-vs-branch-ext-cycles-speedup.plot}%
    }%
  }

  \caption[%
            Plot comparing optimal solution costs for two constraint models
            supporing jump instruction insertion%
          ]%
          {%
            Normalized optimal solution costs for two constraint models that
            supports jump insertion, one based on branch extension (baseline)
            and another based on DTB patterns (subject)%
          }
  \labelFigure{dual-target-branch-patterns-vs-branch-extension-cycles-plot}
\end{figure}

\input{%
  \expDir/dual-target-patterns-vs-branch-ext-pre+solving-time-speedup.stats%
}

\input{\expDir/dual-target-patterns-vs-branch-ext-cycles-speedup.stats}

Figures~\refFigure*{%
  dual-target-branch-patterns-vs-branch-extension-solving-time-plot}
and~\refFigure*{dual-target-branch-patterns-vs-branch-extension-cycles-plot}
shows the normalized solving times (including presolving time) and
\gls{solution} costs, respectively, for the two \glspl{constraint model}
described above, with the \glsshort{constraint model} based on \gls{branch
  extension} serving as \gls{baseline} and the \glsshort{constraint model} based
on \glspl{DTB pattern} serving as \gls{subject}.
%
All \glspl{function} are solved to optimality and arranged in increasing order
of number of conditional branch \glspl{instruction}.
%
The solving times range from
\SIMinOf{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeAvgMin,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMin
}{\s}
to
\SIMaxOf{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeAvgMax,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMax
}{\s}
with a maximum coefficient of variation of
\numMaxOf{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeCvMax,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeCvMax
}, and the costs range from
\numMinOf[round-precision=0]{
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesAvgMin,
  \DualTargetPatternsVsBranchExtCyclesSpeedupBaselineCyclesAvgMin
}~cycles to
\numMaxOf[round-precision=0]{
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesAvgMax,
  \DualTargetPatternsVsBranchExtCyclesSpeedupBaselineCyclesAvgMax
}~cycles.
%
As the \gls{GMI} for solving time is \printGMI{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
}{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
}, we conclude that \glsplshort{constraint model} based on \glspl{DTB pattern}
yield significantly lower solving times than those based on \gls{branch
  extension}.
%
We also see clearly from the plot that when the number of conditional branch
\glspl{instruction} increases -- up to \num{13}, in the case of {\codeFont
  nextkeypacket} -- the \gls{search space} for \gls{branch extension} grows
faster than for \glspl{DTB pattern}.
%
In addition, as the \gls{GMI} for cost is \printGMI{%
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
    \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMax%
}, we conclude that, in some cases, \glspl{DTB pattern} result in optimal
\glspl{solution} with slightly lower cost compared with \gls{branch extension}.
%
Hence, when implementing insertion of jump \glspl{instruction}, \glspl{DTB
  pattern} is a better design choice over \gls{branch extension}.


\section{Objective Function}
\labelSection{cm-objective-function}

In \gls{instruction selection} most \glspl{compiler} optimize for performance,
meaning they attempt to minimize the total cost -- this is typically the
\gls{instruction} latency -- of the selected \glspl{match} per \gls{block}~$b$
while factoring in the execution frequency of~$b$.
%
The intuition is that the \glspl{instruction} selected for ``hot'' \glspl{block}
-- that is, those which are part of a loop with many iterations -- will have
greater impact than those selected for scarcely executed \glspl{block}.
%
In this chapter we introduce a straightforward but naive implementation of the
\gls{objective function}, which will be refined in the next chapter.


\subsubsection{Variables}

The \gls{cost variable} \mbox{$\mVar{cost} \in \mathbb{N}$} models the total
cost of the selected \glspl{match}.
%
It is assumed the total cost can never be negative.


\subsubsection{Constraints}

A straightforward implementation of the \gls{objective function} described above
can be modeled as
%
\begin{equation}
  \mVar{cost} =
  \sum_{m \in \mMatchSet}
  \mVar{sel}[m] \times \mCost(m) \times \mFreq(\mBlockOf(m)),
  \labelEquation{naive-objective-function}
\end{equation}
%
where \mbox{$\mCost(m) \in \mNatNumSet$} denotes the cost of \gls{match}~$m$,
\mbox{$\mFreq(b) \in \mNatNumSet$} denotes the execution frequency of
block~$b$\!,\hspace{-1pt}%
%
\footnote{%
  In order to contain the size of the \gls{domain} of the \gls{cost variable},
  the execution frequencies must often be scaled down.
  %
  In our experiments, limiting the execution frequencies to \num{1000} proved
  sufficient.
}
%
and
%
\begin{equation}
  \mBlockOf(m)
  \equiv
  \left\{
  \begin{array}{ll}
      \mVar{oplace}[\mMin(\mCovers(m))]
    & \text{if } \mCovers(m) \neq \mEmptySet, \\
      \mVar{dplace}[\mVar{alt}[\mMin(\mDefines(m))]]
    & \text{otherwise}.
  \end{array}
  \right.
  \labelEquation{block-of-function}
\end{equation}
%
However, as previously stated \refEquation{naive-objective-function} is a naive
implementation and we therefore use a refined version, introduced in
\refChapter{solving-techniques}, which offers much stronger \gls{propagation}.


\section{Limitations}
\labelSection{cm-limitations}

The \gls{constraint model} described in this chapter has several limitations
that affect code quality.
%
Consequently, a \gls{solution} that is considered optimal with respect to this
\glsshort{constraint model} may still be inferior to the code produced by an
\gls{instruction selector} without these limitations.
%
The first limitation concerns \gls{recomputation} of values, the second concerns
elimination of common subexpressions, and the third concerns implicit sign and
zero extensions and truncations.


\subsubsection{Recomputation}

For some combinations of \glspl{function} and \glspl{target machine}, it may be
beneficial to \glsshort!{recomputation} values appearing in common
subexpressions instead of reusing it.
%
\begin{filecontents*}{recomputation-example-ir.c}
$\irAssign{a}{x + y}$
store a, $\ldots$
$\ldots$
store a, $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \subcaptionbox{Code snippet\labelFigure{recomputation-example-ir}}%
                [25mm]%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {recomputation-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF subgraph, covered by two matches derived from a
                  store instruction with base-plus-index addressing mode.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{recomputation-example-graph}%
                }%
                [74mm]%
                {%
                  \input{figures/constraint-model/recomputation-example-graph}%
                }%
  \hfill%
  \mbox{}

  \caption{%
    Example illustrating when recomputation is preferred over value reuse%
  }%
  \labelFigure{recomputation-example}
\end{figure}
%
See for example \refFigure{recomputation-example}.
%
The \gls{function} performs two memory stores using the same address
value~\irVar{a} (\refFigure{recomputation-example-ir}).
%
If the \gls{target machine} provides a memory \gls{instruction} with
base-plus-index addressing mode (that is, the address to be used is the sum of
the values appearing in a base and an index \gls{register}), then no
add~\gls{instruction} is needed for computing~\irVar{a}.
%
In the context of \gls{instruction selection}, this means letting the
\gls{operation} representing the addition to be covered by more than one
\gls{match} (\refFigure{recomputation-example-graph}).
%
However, Eqs.\thinspace\refEquation*{operation-coverage}
and~\refEquation*{data-definitions} require that every \gls{operation} and
\gls{datum} must be covered respectively \gls{define.d}[d] by exactly one
selected \gls{match}, thus forbidding such \glspl{solution}.
%
Although these \glspl{constraint} can be relaxed to allow \glspl{operation} and
\glspl{datum} to be covered respectively \gls{define.d}[d] by at least one
selected \gls{match}, many of the solving techniques introduced in this
dissertation which are needed for scalability and robustness rely on exact
\gls{cover}[age].


\subsubsection{If-Conversions}

In most cases, performing a branch incurs a performance penalty.
%
Some architectures therefore allow the \glspl{instruction} to be predicated with
a boolean flag for optional execution, which allows \glspl{function} with
if-then-else structures to be transformed into linear code.
%
This process is called \gls!{if-conversion}.

Although the \gls{universal representation} enables predicated versions of the
\glspl{instruction} to be captured as \glspl{pattern}, selection of such
\glspl{pattern} is typically prevented by the \gls{constraint model}.
%
\begin{filecontents*}{if-conversions-example-ir.c}
entry:
  $\ldots$
  if p goto body
  else goto end;
body:
  $\irAssign{a}{x + y}$
  $\irAssign{b}{v + w}$
end:
  $\ldots$
\end{filecontents*}
%
\begin{filecontents*}{if-conversions-example-instrs.c}
entry:
  $\ldots$
  if (p) add a, x, y
  if (p) add b, v, w
  $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \begin{minipage}{36mm}%
    \centering%
    \subcaptionbox{Code snippet\labelFigure{if-conversions-example-ir}}%
                  [28mm]
                  {%
                    \lstinputlisting[language=c,mathescape]%
                                    {if-conversions-example-ir.c}%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Assembly code with predicated instructions%
                    \labelFigure{if-conversions-example-instrs}%
                  }{%
                    \lstinputlisting[mathescape]%
                                    {if-conversions-example-instrs.c}%
                  }
  \end{minipage}%
  \hfill\hfill\hfill%
  \adjustbox{valign=M}{%
    \subcaptionbox{%
                    UF subgraph, covered by two matches derived predicated
                    add instructions%
                    \labelFigure{if-conversions-example-graph}%
                  }{%
                    \input{%
                      figures/constraint-model/if-conversions-example-graph%
                    }%
                  }%
  }%
  \hfill%
  \mbox{}

  \caption{%
    Example illustrating if-conversions%
  }%
  \labelFigure{if-conversions-example}
\end{figure}
%
See for example \refFigure{if-conversions-example}.
%
Assume a \gls{function} containing two sums, \irVar{a} and~\irVar{b}, which are
conditionally computed given a certain predicate~\irVar{p}
(\refFigure{if-conversions-example-ir}).
%
Because this constitutes an if-then-else structure, this code snippet is eligble
for \gls{if-conversion} (\refFigure{if-conversions-example-instrs}).
%
Representing the predicated versions of add~\glspl{instruction} as
\glspl{pattern} gives rise to two \glspl{match}, $m_1$ and~$m_2$, which can
collectively cover the \glsshort{computation node} and \glspl{control node} in
the corresponding \gls{UF graph} (\refFigure{if-conversions-example-graph}).
%
However, since $m_1$ and $m_2$ both cover the same \glspl{control node}, only
one of the \glspl{match} can be selected (due to
Eqs.\thinspace\refEquation*{operation-coverage}
and~\refEquation*{data-definitions}).
%
In addition, because both \glspl{match} \gls{consume.b} the \irBlock{body}
\gls{block}, no other \glspl{operation} may be placed in \irBlock{body} if
either is selected (due to \refEquation{consumption}).
%
This means either both or none of the \glspl{match} must be selected.
%
Together with the \gls{constraint} of exact \gls{cover}[age], in all
\glspl{solution} neither of $m_1$ or $m_2$ is selected.
%
This problem can be fixed by relaxing the \gls{constraint} of exact
\gls{cover}[age], but as in the case of \gls{recomputation} this inhibits many
of the necessary solving techniques.


\subsubsection{Implicit Sign or Zero Extensions}

In cases where the \gls{function} contains sign or zero extensions, depending on
the hardware the \gls{constraint model} may produce code with redundant
\glspl{instruction}.
%
\begin{figure}
  \centering%
  \input{figures/constraint-model/implicit-extensions-graph}

  \caption{Example illustrating implicit sign or zero extensions}%
  \labelFigure{implicit-extensions-example}
\end{figure}
%
See for example \refFigure{implicit-extensions-example}, which depicts a
\glsshort{UF graph}~\gls{subgraph} coverable by \glspl{match}~$m_1$, $m_2$,
and~$m_3$.
%
Assume that {\irFont foo} represents a \gls{function} call and that \irVar{a},
\irVar{b}, and \irVar{c} represent 8-bit values stored in 32-bit
\glspl{register}.
%
As is common, $m_3$ will be derived from an \gls{instruction} that checks
whether the full contents of two \glspl{register} are equal.
%
Consequently, as a precaution the upper bytes of the \glspl{register} need to be
zero-extended (that is, those bits are all set to~0) before doing the
comparison.
%
While this is certainly necessary for the \gls{register} of \irVar{a} as nothing
can be assumed about the value returned by {\irFont foo}, it may be redundant
for the register of \irVar{b}.
%
For example, $m_2$ may be derived from a single-byte load \gls{instruction} that
clears the entire \gls{register} before loading the value.
%
But since this information is lost in the \gls{constraint model}, $m_3$ must
assume both \glspl{register} need to be zero-extended.

One solution to this problem is to extend the \gls{pattern set} with additional
\glspl{pattern} that capture these situations.
%
For example, merging the \glspl{pattern} of $m_2$ and $m_3$ results in a
\gls{match} which, if selected, emits the \gls{instruction} of $m_2$ followed by
the \glspl{instruction} of $m_3$ without the redundant clearing of \irVar{b}.
%
Depending on the \gls{instruction set}, however, this may result in an
exponential number of \glspl{pattern}.
%
If the \gls{instruction set} contains $n$~\glspl{instruction} with implicit
extensions and $m$~\gls{instruction} each taking $k$~values that must first be
sign- or zero-extended, then this will result in $\mBigO(n^k m)$ additional
\glspl{pattern}.

Another solution is to apply the same mechanism used in \gls{copy extension}.
%
In the same manner as with \glspl{copy node}, first the \gls{UF graph} is
extended with \glspl!{extension node}.
%
Hence, for each \gls{data-flow edge}~$\mEdge{v}{o}$, where $v$ is a \gls{value
  node} and $o$ is an \gls{operation}, we remove this \gls{edge} and insert a
new \gls{extension node}~$e$, \gls{value node}~$v'$, and \glspl{data-flow edge}
such that \mbox{$\mEdge{v}{\mEdge{e}{\mEdge{v'}{o}}}$}.
%
Then the \gls{constraint model} is extended with two sets of \glspl{variable},
\mbox{$\mVar{sext}[d] \in \mSet{0, 1}$} and \mbox{$\mVar{zext}[d] \in \mSet{0,
    1}$}, denoting whether a value has been sign- respectively zero-extended.
%
We also extend the \gls{pattern set} with a special \gls!{null-extend pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{e}{v'}}$}, that covers $e$ at
zero cost provided that \mbox{$(\mVar{sext}[v] \mOr \neg\mVar{sext}[v']) \mAnd
  (\mVar{zext}[v] \mOr \neg\mVar{zext}[v'])$} holds.
%
Obviously, a \gls{match} derived from the \gls{null-extend pattern} emits
nothing if selected.
%
If the \gls{null-extend pattern} cannot be selected for covering a particular
\gls{extension node}, then this means an appropriate extension \gls{instruction}
must be emitted.


\section{Summary}
\labelSection{model-summary}

In this chapter, we have introduced a \gls{constraint model} that integrates the
problems of \gls{global.is} \gls{instruction selection}, \gls{global code
  motion}, \gls{data copying}, \gls{value reuse}, and \gls{block ordering}.
%
We have also discussed the limitations of this \glsshort{constraint model} and
how these impact the assembly code that can be produced.

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\makeglossaries

\newterm{assembly code}
\newterm{backend}
\newterm{block ordering}
\newterm{code generation}
\newterm[integrated.cg]{integrated}[parent={code generation}]
\newterm{compiler}
\newterm{compiler intrinsic}
\newterm{condition code}[see={status flag}]
\newterm{condition flag}[see={status flag}]
\newterm{constant folding}
\newterm{data copying}
\newterm{dead code elimination}
\newterm{frontend}
\newterm{global code motion}
\newterm{global code mover}
\newterm{instruction compaction}
\newterm{instruction selection}
\newterm[local.is]{local}[parent={instruction selection}]
\newterm[global.is]{global}[parent={instruction selection}]
\newterm{instruction selector}
\newterm{instruction scheduler}
\newterm{instruction scheduling}
\newterm{IR}%
        [description={intermediate representation},
         first={intermediate representation~(IR)}]
\newterm{loop unrolling}
\newterm{middle-end}[see={optimizer}]
\newterm{optimizer}[see={middle-end}]
\newterm{peephole optimization}
\newterm{peephole optimizer}
\newterm{register allocation}
\newterm{register allocator}
\newterm{register spilling}
\newterm{saturation arithmetic}
\newterm{SSA}%
        [first={static single assignment~(SSA)}]
\newterm{status flag}
\newterm{value reuse}

\newterm{basic block}[see={block}]
\newterm{block}[see={basic block}]
\newterm{entry block}[user1={entry}]
\newterm{function}
\newterm[phi-function]{\mbox{$\mPhi$-function}}[sort={$\mPhi$-function}]
\newterm{program}

\newterm{ARM}
\newacronym{ASIP}{application-specific instruction set processor}
\newterm{AVX}[see={Intel}]
\newacronym{CISC}{complex instruction-set computer}
\newterm{Cortex-M7}[see={ARM}]
\newacronym{DSP}{digital signal processor}
\newterm{Hexagon}
\newterm{instruction}
\newacronym[SIMD.instr]%
           {SIMD}%
           {single-instruction, multiple-data}%
           [parent={instruction}]
\newterm{instruction set}
\newterm{Intel}
\newterm{LLVM}
\newterm{machine description}
\newterm{MIPS}
\newterm{register}
\newacronym{RISC}{reduced instruction-set computer}
\newterm{SSE}[see={Intel}]
\newterm{target machine}[user1={target}]
\newterm{temporary}[plural={temporaries}]
\newterm[virtual.temp]{virtual}[parent={temporary}]
\newterm{TI}
\newterm{TMS320C55x}[see={TI}]
\newacronym{VLIW}{very long instruction word}
\newterm{X86}[see={Intel}]

\newterm{context-free grammar}
\newterm{grammar}[see={machine grammar}]
\newterm[normal form.g]{normal form}[parent={grammar}, user1={normal-form}]
\newterm{machine grammar}[see={grammar}]
\newterm{nonterminal}
\newterm{production}
\newterm{rule}
\newterm[base.r]{base}[parent={rule}]
\newterm[chain.r]{chain}[parent={rule}]
\newterm[complex.r]{complex}[parent={rule}]
\newterm[proxy.r]{proxy}[parent={rule}]
\newterm[simple.r]{simple}[parent={rule}]
\newterm[split.r]{split}[parent={rule}]
\newterm{rule pattern}[user1={pattern}]
\newterm{rule reduction}
\newterm{rule result}[user1={result}]
\newterm{state}
\newterm{state table}
\newterm{terminal}

\newterm{block DAG}[user1={block}]
\newterm{Click-Paleczny graph}
\newterm{control-flow edge}[user1={control-flow}]
\newterm{control-flow graph}[user1={control-flow}]
\newterm{cover}
\newterm[least-cost.c]{least-cost}[parent={cover}]
\newterm{data-flow edge}[user1={data-flow}]
\newterm{data-flow graph}[user1={data-flow}]
\newterm{datum}[plural={data}]
\newterm{expression tree}
\newterm{function graph}[user1={function}]
\newterm{interference graph}
\newterm{match}[plural=matches]
\newterm[complex.m]{complex}[parent={match}]
\newterm{match set}
\newterm{matching}[see={pattern matching}]
\newterm{overlap}
\newterm{operation}
\newterm{pattern}[see={pattern graph}]
\newterm[complex.p]{complex}[parent={pattern}]
\newterm[proxy.p]{proxy}[parent={pattern}]
\newterm[simple.p]{simple}[parent={pattern}]
\newterm{pattern graph}[see={pattern}]
\newterm{pattern matching}[user3={pattern-matching}, see={matching}]
\newterm{pattern selection}[see={selection}]
\newterm[optimal.ps]{optimal}[parent={pattern selection}]
\newterm{pattern set}
\newterm{sea-of-nodes IR}
\newterm{selection}[see={pattern selection}]
\newterm{SSA graph}

\newterm{copy extension}
\newterm{block node}[user1={block}]
\newterm{computation node}[user1={computation}]
\newterm{control node}[user1={control}]
\newterm{definition edge}
\newterm{dependency graph}
\newterm{state node}[user1={state}]
\newterm{state-flow edge}[user1={state-flow}]
\newterm{universal representation}
\newterm{UF graph}[first={universal function (UF) graph}, user1={UF}]
\newterm{UP graph}[first={universal pattern (UP) graph}, user1={UP}]
\newterm{value node}[user1={value}]

\newterm{BURS}%
        [first=bottom-up rewriting system~(BURS)]
\newterm{combinatorial approach}%
        [user1={combinatorial}, plural={combinatorial approaches}]
\newterm{Davidson-Fraser approach}
\newterm{maximum munch}
\newterm{traditional approach}%
        [user1={traditional}, plural={traditional approaches}]

\newterm{decision variable}[see={variable}, user1={variable}, user2={variables}]
\newterm{solver}

\newterm{CP}%
        [description={constraint programming},
         first={constraint programming~(CP)}]
\newterm{branch and bound}[user3={branch-and-bound}]
\newterm{branching strategy}[plural={branching strategies}]
\newterm{circuit constraint}[user1={circuit}]
\newterm{cost variable}
\newterm{constraint}
\newterm[binary.c]{binary}[parent={constraint}]
\newterm[dominance breaking.c]{dominance breaking}[parent={constraint}]
\newterm[global.c]{global}[parent={constraint}]
\newterm[implied.c]{implied}[parent={constraint}]
\newterm[symmetry breaking.c]{symmetry breaking}[parent={constraint}]
\newterm{constraint propagation}[see={propagation}]
\newterm{constraint model}[user1={model}, user2={models}]
\newterm{constraint solver}[user1={solver}, see={solver}]
\newterm{constraint store}[see={store}]
\newterm[stronger.cs]{stronger}[parent={constraint store}]
\newterm{distinct constraint}[user1={distinct}]
\newterm{domain}
\newterm{failure}[user1={failed}]
\newterm{filtering algorithm}[see={propagator}]
\newterm{first-fail principle}
\newterm{fixpoint}
\newterm{global cardinality constraint}
\newterm{presolving}
\newterm{propagation}[see={constraint propagation}]
\newterm{propagator}[see={filtering algorithm}]
\newterm{bounds consistency}[user1={bounds}, user3={bounds-consistent}]
\newterm[decreasing.p]{decreasing}[parent={propagator}]
\newterm{domain consistency}[user1={domain}, user3={domain-consistent}]
\newterm[monotonic.p]{monotonic}[parent={propagator}]
\newterm{value consistency}[user1={value}, user3={value-consistent}]
\newterm{search}
\newterm{search space}
\newterm{search tree}
\newterm{solution}
\newterm{solution space}
\newterm{store}[see={constraint store}]
\newterm{table constraint}[user1={table}]
\newterm{variable}
\newterm[assigned.v]{assigned}[parent={variable}]

\newterm{magic sequence problem}

\newterm{MIS}%
        [first={maximal independent set~(MIS)},
         firstplural={maximal independent sets~(MISs)}]
\newterm{MWIS}%
        [first={maximal/minimal weighted independent set~(MWIS)},
         firstplural={maximal/minimal weighted independent sets (MWISs)}]

\newterm{PBQP}%
        [first={partitioned Boolean quadratic problem~(PBQP)}]
\newterm{QAP}%
        [first={quadratic assignment problem~(QAP)}]

\newterm{IP}%
        [first={integer programming~(IP)}]
\newterm{Horn clause}
\newterm{integer linear programming}

\newterm{SAT}%
        [first={Boolean satisfiability~(SAT)}]

\newterm{child}[see={node}]
\newterm{cycle}
\newacronym{DAG}{directed acyclic graph}
\newterm{edge}
\newterm[inbound.e]{inbound}[parent={edge}, see={ingoing.e}]
\newterm[ingoing.e]{ingoing}[parent={edge}, see={inbound.e}]
\newterm[outbound.e]{outbound}[parent={edge}, see={outgoing.e}]
\newterm[outgoing.e]{outgoing}[parent={edge}, see={outbound.e}]
\newterm{edge number}
\newterm[inbound.en]{inbound}[parent={edge number}]
\newterm[outbound.en]{outbound}[parent={edge number}]
\newterm{edge splitting}[user1={split}]
\newterm{forest}
\newterm{graph}
\newterm[connected.g]{connected}[parent={graph}]
\newterm[directed.g]{directed}[parent={graph}]
\newterm[ordered.g]{ordered}[parent={graph}]
\newterm[simple.g]{simple}[parent={graph}]
\newterm[strongly connected.g]{strongly connected}[parent={graph}]
\newterm[undirected.g]{undirected}[parent={graph}]
\newterm[weakly connected.g]{weakly connected}[parent={graph}]
\newterm{graph homomorphism}
\newterm{graph isomorphism}
\newterm{independent set}
\newterm{isomorphism}[see={subgraph isomorphism}, user1={isomorphic}]
\newterm{leaf}[plural={leaves}, see={node}]
\newterm{loop edge}[see={loop}]
\newterm{loop}[see={loop edge}]
\newterm{multigraph}
\newterm{node}
\newterm[adjacent.n]{adjacent}[parent={node}]
\newterm[connected.n]{connected}[parent={node}]
\newterm[fixed.n]{fixed}[parent={node}]
\newterm{node duplication}[user1={duplicat}]% The short term is without the
                                            % ending 'e' in order to be used in
                                            % words like 'duplicate' and
                                            % 'duplicating'.
\newterm{parent}[see={node}]
\newterm{path}
\newterm{root}[see={node}]
\newterm{source}
\newterm{subgraph}
\newterm{subgraph isomorphism}[see={isomorphism}, user3={subgraph-isomorphism}]
\newterm{subtree}[see={tree}]
\newterm{super node}
\newterm{target}
\newterm{topological sort}
\newterm{tree}
\newterm[directed.t]{directed}[parent={tree}]
\newterm[rooted directed.t]{rooted directed}[parent={tree}]
\newterm{vertex}[plural={vertices}, see={node}]

\newterm[Glasgow]{\toolFont{Glasgow}}[sort={Glasgow}]
\newterm[LAD]{\toolFont{LAD}}[sort={LAD}]
\newterm[VF2]{\toolFont{VF2}}[sort={VF2}]

\newterm{FRT}%
        [first=factorized register transfer (FRT),
         firstplural=factorized register transfers (FRTs)]

\newterm{principle}
\newterm{macro}
\newterm{macro expander}[user3={macro-expan}]% The short term is without the
                                             % ending 'sion' in order to be used
                                             % in words like 'expanding'.
\newterm{macro expansion}
\newterm[naive.me]{naive}[parent={macro expansion}]
\newterm{tree covering}
\newterm{DAG covering}
\newterm{graph covering}

\newterm{template}
\newterm{expand procedure}

\newterm{instruction characteristic}%
        [user1={characteristic}, user2={characteristics}]
\newterm[single-output.ic]%
        {single-output}%
        [parent={instruction characteristic}]
\newterm[multi-output.ic]%
        {multi-output}%
        [parent={instruction characteristic}]
\newterm[disjoint-output.ic]%
        {disjoint-output}%
        [parent={instruction characteristic}]
\newterm[inter-block.ic]%
        {inter-block}%
        [parent={instruction characteristic}]
\newterm[interdependent.ic]%
        {interdependent}%
        [parent={instruction characteristic}]

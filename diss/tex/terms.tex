% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\makeglossaries

\newterm{compiler}
\newterm{frontend}
\newterm{backend}
\newterm{middle-end}[see={optimizer}]
\newterm{optimizer}[see={middle-end}]
\newterm{code generation}
\newterm{constant folding}
\newterm{dead code elimination}
\newterm{loop unrolling}
\newterm{instruction selector}
\newterm{register allocator}
\newterm{instruction scheduler}
\newterm{global code mover}

\newterm{instruction selection}
\newterm[local.is]{local}[parent={instruction selection}]
\newterm[global.is]{global}[parent={instruction selection}]
\newterm{global code motion}
\newterm{data copying}
\newterm{block ordering}
\newterm{value reuse}
\newterm{register allocation}
\newterm{instruction scheduling}

\newterm{program}
\newterm{function}
\newterm{basic block}[see={block}]
\newterm{block}[see={basic block}]
\newterm{instruction}
\newterm[SIMD.instr]%
        {SIMD}%
        [first={single-instruction, multiple-data (SIMD)}, parent={instruction}]
\newterm{instruction set}
\newterm{machine description}
\newterm{register}
\newterm{temporary}[plural={temporaries}]
\newterm[virtual.temp]{virtual}[parent={temporary}]
\newterm{target machine}[user1={target}]
\newterm[phi-function]{\mbox{$\mPhi$-function}}[sort={$\mPhi$-function}]

\newterm{context-free grammar}
\newterm{machine grammar}[see={grammar}]
\newterm{grammar}[see={machine grammar}]
\newterm{terminal}
\newterm{nonterminal}
\newterm[normal form.g]{normal form}[parent={grammar}, user1={normal-form}]
\newterm{production}
\newterm{rule}
\newterm[base.r]{base}[parent={rule}]
\newterm[chain.r]{chain}[parent={rule}]
\newterm{rule pattern}[user1={pattern}]
\newterm{rule reduction}
\newterm{rule result}[user1={result}]
\newterm{state}

\newterm{cover}
\newterm[least-cost.c]{least-cost}[parent={cover}]
\newterm{data-flow graph}
\newterm{block DAG}[user1={block}]
\newterm{expression tree}
\newterm{function graph}[user1={function}]
\newterm{pattern}[see={pattern graph}]
\newterm{pattern graph}[see={pattern}]
\newterm{pattern matching}
\newterm{pattern selection}
\newterm[optimal.ps]{optimal}[parent={pattern selection}]
\newterm{pattern set}
\newterm{match}[plural=matches]
\newterm{match set}
\newterm{overlap}
\newterm{operation}
\newterm{sea-of-nodes IR}
\newterm{transitive closure}
\newterm{transitive reduction order}
\newterm{UF graph}[first={universal function (UF) graph}]

\newterm{constraint}
\newterm{constraint programming}
\newterm{constraint propagation}[see={propagation}]
\newterm{propagation}[see={constraint propagation}]
\newterm{constraint model}[user1={model}, user2={models}]
\newterm{constraint solver}[user1={solver}]
\newterm{solution}
\newterm{solution space}
\newterm{variable}

\newterm{maximum munch}
\newterm{combinatorial approach}%
        [user1={combinatorial}, plural={combinatorial approaches}]
\newterm{traditional approach}%
        [user1={traditional}, plural={traditional approaches}]

\newterm{node}
\newterm[fixed.n]{fixed}[parent={node}]
\newterm{edge}
\newterm{graph}
\newterm{subgraph}

\newacronym{BURS}{bottom-up rewriting system}
\newacronym{DAG}{directed acyclic graph}
\newacronym{DSP}%
           {digital signal processor}%
           [firstplural={digital signal processors (DSPs)}]
\newacronym{IR}{intermediate representation}
\newacronym{SSA}{static single assignment}

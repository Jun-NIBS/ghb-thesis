% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter[Modeling Global Instruction Selection]
        {Modeling Global\\ Instruction Selection}
\labelChapter{modeling-global-instruction-selection}

This chapter describes the part of the \gls{constraint model} which captures
\gls{global.is} \gls{instruction selection}.
%
\RefSection{modeling-operation-coverage-and-data-definitions} describes modeling
of \gls{operation} coverage and \glspl{datum} definitions.
%
\RefSection{forbidding-cyclic-data-dependencies} describes how to forbid
selection of \glspl{match} that will lead to cyclic data dependencies.



\section{Modeling Operation Coverage and Data Definitions}
\labelSection{modeling-operation-coverage-and-data-definitions}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
There are two variants of this problem:
%
\begin{enumerate*}[label=(\arabic*)]
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerate*}
%
The former problem is more common as it is stricter, resulting in simpler models
with smaller \glspl{solution space}.
%
It also allows use of \glspl{constraint} that enable strong \gls{propagation},
which is essential for curbing solving time and increasing scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.
%
Due to the increased complexity of the relaxed version of the problem, we model
exact coverage in this dissertation.

Similarly, every value and state must be produced by exactly one selected match.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \emph{defines} $d$ if
there exists an inbound \glsshort{state-flow edge} or \gls{data-flow edge} to
$d$ in the \gls{UP graph} from which $m$ was derived.
%
Similarly, $m$ \emph{uses} $d$ if there exists an outbound \glsshort{state-flow
  edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph} of $m$.



\subsubsection{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match} found
for $\mUFGraph$, the set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0,
    1}$} models whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\neg\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt}}, where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} that can cover~$o$.
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[o]$} models which selected \gls{match} defines \gls{datum}~\mbox{$d
  \in \mDatumSet$\hspace{-1.5pt}}, where $\mDatumSet$ denotes the set of
\glspl{datum} in $\mUFGraph$, and \mbox{$\mMatchSet[d] \subseteq \mMatchSet$}
denotes the set of \glspl{match} that can define~$d$.



\subsubsection{Constraints}

The \gls{constraint} that every \gls{operation} must be covered is modeled as
%
\begin{equation}
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m],
  \forall o \in \mOpSet \hspace{-1pt},
  \forall m \in \mMatchSet[o] \hspace{-1pt}.
  \labelEquation{operation-coverage}
\end{equation}
%
Hence an \gls{operation}~$o$ is covered by a match~$m$ if and only if $m$ is
selected.

Likewise, the \gls{constraint} that every \gls{datum} must be defined is modeled
as
%
\begin{equation}
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m],
  \forall d \in \mDatumSet \hspace{-1.5pt},
  \forall m \in \mMatchSet[d].
  \labelEquation{data-definitions}
\end{equation}
%
Hence a \gls{datum}~$d$ is defined by a match~$m$ if and only if $m$ is
selected.



\section{Forbidding Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

\subsubsection{Constraints}

\begin{equation}
  \sum_{m \in f} \mVar{sel}[m] < \mCard{f},
  \forall f \in \mForbiddenCombSet
  \labelEquation{cyclic-data-deps}
\end{equation}

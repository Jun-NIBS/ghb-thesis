% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter[Modeling Global Instruction Selection]
        {Modeling Global\\ Instruction Selection}
\labelChapter{modeling-global-instruction-selection}

This chapter describes the part of the \gls{constraint model} which captures
\gls{global.is} \gls{instruction selection}.
%
\RefSection{modeling-operation-coverage-and-data-definitions} describes modeling
of \gls{operation} coverage and \glspl{datum} definitions.
%
\RefSection{forbidding-cyclic-data-dependencies} describes how to forbid
selection of \glspl{match} that will lead to cyclic data dependencies.



\section{Modeling Operation Coverage and Data Definitions}
\labelSection{modeling-operation-coverage-and-data-definitions}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
There are two variants of this problem:
%
\begin{enumerate*}[label=(\arabic*)]
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerate*}
%
The former problem is more common as it is stricter, resulting in simpler models
with smaller \glspl{solution space}.
%
It also allows use of \glspl{constraint} that enable strong \gls{propagation},
which is essential for curbing solving time and increasing scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.
%
Due to the increased complexity of the relaxed version of the problem, we model
exact coverage in this dissertation.

Similarly, every value and state must be produced by exactly one selected match.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \emph{defines} $d$ if
there exists an inbound \glsshort{state-flow edge} or \gls{data-flow edge} to
$d$ in the \gls{UP graph} from which $m$ was derived.
%
Similarly, $m$ \emph{uses} $d$ if there exists an outbound \glsshort{state-flow
  edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph} of $m$.



\subsubsection{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match} found
for $\mUFGraph$, the set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0,
    1}$} models whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\neg\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt}}, where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} that can cover~$o$.
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[o]$} models which selected \gls{match} defines \gls{datum}~\mbox{$d
  \in \mDataSet$\hspace{-1.5pt}}, where $\mDataSet$ denotes the set of
\glspl{datum} in $\mUFGraph$, and \mbox{$\mMatchSet[d] \subseteq \mMatchSet$}
denotes the set of \glspl{match} that can define~$d$.



\subsubsection{Constraints}

The \gls{constraint} that every \gls{operation} must be covered is modeled as
%
\begin{equation}
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m],
  \forall o \in \mOpSet \hspace{-1pt},
  \forall m \in \mMatchSet[o] \hspace{-1pt}.
  \labelEquation{operation-coverage}
\end{equation}
%
In other words, an \gls{operation}~$o$ is covered by a match~$m$ if and only if
$m$ is selected.

Likewise, the \gls{constraint} that every \gls{datum} must be defined is modeled
as
%
\begin{equation}
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m],
  \forall d \in \mDataSet \hspace{-1.5pt},
  \forall m \in \mMatchSet[d] \hspace{-1pt}.
  \labelEquation{data-definitions}
\end{equation}
%
In other words, a \gls{datum}~$d$ is defined by a match~$m$ if and only if $m$
is selected.



\section{Forbidding Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

In certain cases, selecting \glspl{match} of \glspl{instruction} producing
multiple results -- for example, many modern processors provide memory
\glspl{instruction} that automatically increment or decrement the address value
-- could lead to cyclic data dependencies~\cite{EbnerEtAl:2008}.
%
\begin{filecontents*}{cyclic-data-deps-example-ir.c}
$\ldots$
$\irAssign{\irVar{p}[2]}{\irAdd{\irVar{p}[1]}{\irVar{4}}}$
$\irStore{\irVar{q}[1]}{\irVar{p}[2]}$
$\irAssign{\irVar{q}[2]}{\irAdd{\irVar{q}[1]}{\irVar{4}}}$
$\irStore{\irVar{p}[1]}{\irVar{q}[2]}$
\end{filecontents*}%
%
\begin{figure}
  \subcaptionbox{IR\labelFigure{cyclic-data-deps-example-ir}}%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {cyclic-data-deps-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF graph, covered by two matches derived from an
                  auto-increment store instruction.
                  %
                  For brevity, the state node are not included%
                  \labelFigure{cyclic-data-deps-example-uf-graph}%
                }%
                [62mm]%
                {%
                  \input{%
                    figures/modeling-global-instruction-selection/%
                    cyclic-data-deps-example-uf-graph%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Dependency graph%
                  \labelFigure{cyclic-data-deps-example-dep-graph}%
                }%
                [32mm]%
                {%
                  \input{%
                    figures/modeling-global-instruction-selection/%
                    cyclic-data-deps-example-dep-graph%
                  }%
                }

  \caption{Example illustrating cyclic data dependencies}%
  \labelFigure{cyclic-data-deps-example}%
\end{figure}
%
An example of such a situation is given in \refFigure{cyclic-data-deps-example}.
%
If both \glspl{match} are selected, then either value~\irVar{p}[2] or
value~\irVar{q}[2] will be used before it is available (depending on the
instruction order), thus resulting in incorrect code.
%
Consequently, such combinations must be identified and forbidden.

We detect such combinations -- which could involve more than two \glspl{match}
-- by first constructing a \gls!{dependency graph}, where each \gls{node}
represents a \gls{match} and each directed \gls{edge}~$\mPair{n}{m}$ indicates
that \gls{match}~$m$ uses \glspl{datum} produced by \gls{match}~$n$.
%
A \gls{cycle} in this \gls{graph} corresponds a combination of \glspl{match}
which will lead to a cyclic data dependency if all \glspl{match} are selected.
%
Hence, we find all \glspl{cycle} in the \gls{dependency graph} -- we applied
\citeauthor{Johnson:1975}'s algorithm for this task~\cite{Johnson:1975} -- and
add \glspl{constraint} forbidding selection of all \glspl{match} appearing in a
\gls{cycle}.



\subsubsection{Constraints}

Given a set~\mbox{$\mForbiddenCombSet \subseteq \mPowerset{\mMatchSet}$} of
\glspl{cycle} found for the \gls{dependency graph} built from a \gls{UF graph}
and \gls{match set}, the \gls{constraint} forbidding cyclic data dependencies is
modeled as
%
\begin{equation}
  \sum_{m \in f} \mVar{sel}[m] < \mCard{f},
  \forall f \in \mForbiddenCombSet.
  \labelEquation{cyclic-data-deps}
\end{equation}
%
In other words, the number of selected \glspl{match} must be strictly less than
the number of \gls{match} appearing in the \gls{cycle}.

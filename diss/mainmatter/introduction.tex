% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Introduction}

\todo{write chapter outline}

\section{Overview}

\begin{figure}
  \centering%
  \input{figures/introduction/compiler-overview}

  \caption{Overview of a typical compiler}
  \labelFigure{compiler-overview}
\end{figure}

A \gls!{compiler} is a tool that takes a \gls!{program}, written in some
programming language, as input and produces equivalent assembly code for a
specific \gls!{target machine} as output.
%
As shown in \refFigure{compiler-overview}, a compiler typically consists of
three parts:%
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item a \gls!{frontend}, which performs syntactic and semantic analysis and
    transforms the program into an \gls!{IR}
  \item an \gls!{optimizer} (sometimes called \gls!{middle-end}), which performs
    target-independent optimizations
  \item a \gls!{backend}, which performs \gls{code generation}
\end{inlinelist}.

The \gls{optimizer} is arguably the largest component of any \gls{compiler},
consisting of many tasks such as \gls{constant folding}, \gls{dead code
  elimination}, and \gls{loop unrolling}.
%
Another such optimization is \gls!{global code motion}, where \glspl{operation}
are moved from one \gls{basic block} to another, which is done mainly to move
expensive \glspl{operation} into \glspl{block} with lower execution frequency.

The \gls{backend} also consists of several tasks, of which three
typically are most promiment:%
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item \gls!{instruction selection}, where \glspl{instruction} implementing the
    given \gls{program} are selected
  \item \gls!{register allocation}, where \gls{virtual.temp} \glspl{temporary}
    are assigned to \glspl{register}
  \item \gls!{instruction scheduling}, where \glspl{instruction} are reordered
    to increase instruction-level parallelism
\end{inlinelist}.
%
Another code generation task of interest is \gls!{block ordering}, where the
\glspl{basic block} are rearranged in order to minimize the number of jump
\glspl{instruction}.

This dissertation focuses primarily on the first \gls{code generation} problem
by introducing a combinatorial optimization model for \gls{instruction
  selection}, which is simpler and more flexible compared to traditional
approaches, and captures crucial features -- like \gls{data copying} -- which
are ignored by existing combinatorial optimization models.
%
The model select \glspl{instruction} globally for entire
\glspl{function} and enables selection of complex \glspl{instruction} not
supported by existing approaches.
%
In addition, it integrates \gls{global code motion} as it is shown that moving
\glspl{operation} across \glspl{basic block} can alleviate \gls{instruction
  selection}.
%
To this end, the dissertation also introduces a new, graph-based representation
that unifies data flow and control flow for entire \glspl{function}, which
enables complex \glspl{instruction} to be modeled as graphs.
%
Moreover, the representation is crucial for modeling \gls{global.is}
\gls{instruction selection} and \gls{global code motion} as a combinatorial
optimization model.

It is also shown in this disseration that \gls{block ordering} impacts
\gls{instruction selection} (and vice versa).
%
Consequently, the model also integrates \gls{block ordering}, which results in
better code compared to traditional approaches.

Lastly, the dissertation touches upon the other two \gls{code generation}
problems by proposing ideas on how to extend the model to integrate
\gls{instruction scheduling} and \gls{register allocation}.



\section{Motivation}

\begin{filecontents*}{isel-gcmotion-example.c}
int i = 0;
while (i < N) {
  int a = A[i];
  int b = B[i];
  int c = a + b;
  if (MAX < c) c = MAX;
  C[i] = c;
  i++;
}
\end{filecontents*}

\begin{figure}
  \centering%
  \subcaptionbox{C code\labelFigure{isel-gcmotion-example-c}}%
                {\lstinputlisting[language=c]{isel-gcmotion-example.c}}%
  \hspace{5mm}%
  \subcaptionbox{Corresponding \gls{IR} and control-flow graph%
                 \labelFigure{isel-gmotion-example-ir}}%
                [64mm]%
                {\input{figures/introduction/isel-gcmotion-example-ir}}%

  \caption[%
            An example illustrating the interaction between instruction
            selection and global code motion%
          ]{%
            An example to illustrate the interaction between instruction
            selection and global code motion.
            %
            The program computes the saturated sums of two arrays \irVar{A} and
            \irVar{B} as a new array~\irVar{C}, all of which are assumed to be
            of equal lengths and stored in memory.
            %
            The variables \irVar{N} and \irVar{MAX} are constants representing
            the array length and the upper limit, respectively.
            %
            An integer is assumed to be 4~bytes%
          }
  \labelFigure{isel-gcmotion-example}%
\end{figure}

\paragraph{For global instruction selection and new representations}

\RefFigure{isel-gcmotion-example} shows a program that computes the saturated
sums of two integer arrays.
%
In saturation arithmetic, the result of an arithmetic \gls{operation} will
always stay within a range fixed by a minimum and maximum value.
%
If the \gls{operation} would produce a value outside of this range, then the
value is set (``clamped'') to the closest limit, thus becoming ``saturated''.

Assume a \gls{target machine} that has an instruction capable of implementing
the saturated-add \gls{operation} used in the \gls{program} shown in
\refFigure{isel-gcmotion-example}.
%
Hence the \gls{instruction} would implement the following five operations:
%
\begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
  \item the \irAdd{\irVar{a}}{\irVar{b}} addition
  \item the \irLE{\irVar{MAX}}{\irVar{c}} comparison
  \item the conditional jump to either of blocks~\irBlock{b4} and~\irBlock{b5}
  \item the \irAssign{\irVar{c}}{\irVar{MAX}} assignment
  \item the unconditional jump to~\irBlock{b5}
\end{inlinelist}.
%
Selecting this \gls{instruction} can have tremendous impact on performance.
%
Assume, for example, that each \gls{operation} can be implemented using an
\gls{instruction} that takes one cycle to execute. Hence executing one iteration
of the loop takes \num{16}~cycles, and selecting the saturated-add
\gls{instruction} reduces the execution time by \SI{25}{\percent}.

Existing \gls{instruction selection} techniques and representations, however, do
not support selection of such \glspl{instruction}.
%
Since the \glspl{operation} above reside in separate \glspl{block} (\irBlock{b3}
and \irBlock{b4}), making use of the saturated-add \gls{instruction} requries an
\gls{instruction selector} that is capable of processing multiple \glspl{basic
  block} simultaneously.
%
In comparison, traditional \gls{instruction selection} techniques only consider
one \gls{basic block} at a time.
%
Morever, most approaches represent the \glspl{instruction} as graphs.
%
As the saturated-add \gls{instruction} contains \glspl{operation} for both data
and control flow, modeling it as a graph requires a representation that captures
both data and control flow.
%
In comparison, existing representations only capture data flow.



\paragraph{For combining instruction selection and global code motion}

Assume that the \gls{target machine} also has an instruction capable of
performing multiple add \glspl{operation} (these are called \gls!{SIMD.instr}[
  \glspl{instruction}]).
%
Revisiting the example shown in \refFigure{isel-gcmotion-example}, there are
four additions in the \gls{program} (\irAdd{\irVar{A}}{\irTemp{2}},
\irAdd{\irVar{B}}{\irTemp{2}}, \irAdd{\irVar{C}}{\irTemp{2}}, and
\irAdd{\irVar{i}}{\irVar{1}}) which are independent from one another and can
therefore be executed in parallel.
%
Assuming against that all \glspl{instruction} takes one cycle to execute,
implementing these four additions using a single \gls{SIMD.instr}
\gls{instruction} would improve performance by almost \SI{19}{\percent}.
%
This requires that the two additions in block~\irBlock{b5} be moved to
block~\irBlock{b4}, which is the task of \gls{global code motion}.
%
However, as \gls{global code motion} is commonly considered to be a
target-independent optimization, it is often done before \gls{code generation}.
%
Consequently, the \gls{global code mover} may take decisions which are
detrimental for the \gls{instruction selector}.



\paragraph{For taking the cost of data copying into account}

Although selecting \gls{SIMD.instr} \glspl{instruction} may significantly
improve code quality -- like in the previous example -- doing so carelessly may
also have the opposite effect.
%
Assume, for example, that the \gls{SIMD.instr} \gls{instruction} uses a limited
set of registers.
%
If the other selected \glspl{instruction} cannot directly write to and read from
these registers, then additional \glspl{instruction} must be emitted to copy the
values between the general registers and the \gls{SIMD.instr} registers.
%
In the case of the program shown in \refFigure{isel-gcmotion-example}, eight
such \glspl{instruction} would be needed, leading to a slowdown of over
\SI{31}{\percent}.
%
These restrictions must be known by the \gls{instruction selector} to make
effective use of \gls{SIMD.instr} \glspl{instruction}.



\paragraph{For combining instruction selection and block ordering}

\begin{filecontents*}{isel-blorder-example.c}
int f() {
  int a;
  do {
    a = g();
  } while (a == 0);
  return a;
}
\end{filecontents*}

\begin{figure}
  \centering%
  \subcaptionbox{C code\labelFigure{isel-blorder-example-c}}%
                {\lstinputlisting[language=c]{isel-blorder-example.c}}%
  \hspace{5mm}%
  \subcaptionbox{Corresponding \gls{IR} and control-flow graph%
                 \labelFigure{isel-blorder-example-ir}}%
                [64mm]%
                {\input{figures/introduction/isel-blorder-example-ir}}%

  \vspace{\baselineskip}

  \subcaptionbox{%
                  Selecting basic jump instruction, after block ordering.
                  %
                  Cycle count: 6%
                  \labelFigure{isel-blorder-example-code-1}%
                }%
                [34mm]%
                {%
                  \small
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & cmp  & \instrTemp{1} $\leftarrow$
                                 \instrEQ{\instrVar{a}}{\instrVar{0}}\\
                        & jmp  & \instrTemp{1}, \instrBlock{b1}\\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  Selecting complex jump instruction, before block ordering.
                  %
                  Cycle count: 5%
                  \labelFigure{isel-blorder-example-code-2}%
                }%
                [39mm]%
                {%
                  \small
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & jmp  & \instrNE{\instrVar{a}}{\instrVar{0}},
                                 \instrBlock{b2}\\
                    \\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }
  \hfill%
  \subcaptionbox{%
                  Selecting complex jump instruction, after block ordering.
                  %
                  Cycle count: 8%
                  \labelFigure{isel-blorder-example-code-3}%
                }%
                [40mm]%
                {%
                  \small
                  \begin{tabular}{%
                                   @{}>{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{\hspace{4pt}}%
                                   >{\instrFont}l@{}%
                                 }
                    b1: & call & a $\leftarrow$ g()\\
                        & jmp  & \instrNE{\instrVar{a}}{\instrVar{0}},
                                 \instrBlock{b2}\\
                        & jmp  & \instrBlock{b1}\\
                    b2: & ret  & \instrVar{a}
                  \end{tabular}%
                }

  \caption[%
            An example illustrating the interaction between instruction
            selection and block ordering%
          ]{%
            An example to illustrate the interaction between instruction
            selection and block ordering.
            %
            The function \irCode{f} calls another function \irCode{g} until it
            returns a non-zero value, and then returns that value%
          }
  \labelFigure{isel-blorder-example}%
\end{figure}

\RefFigure{isel-blorder-example} shows a \gls{function} that keeps calling
another \gls{function} (with side effects) until it returns a non-zero value.
%
Assume that the \gls{target machine} has three \glspl{instruction} for handling
control flow:
%
\begin{inlinelist}[itemjoin={; }, itemjoin*={; and}]
  \item a \mbox{{\instrFont jmp} $p$, $b$} \gls{instruction}, which
    branches to block~$b$ if the value in register~$p$ corresponds the Boolean
    value~$\mathit{true}$
  \item a \mbox{{\instrFont jmp} $r \neq 0$, $b$} \gls{instruction}, which
    branches to block~$b$ if the condition \mbox{$r \neq 0$} holds, where $r$
    is a register
  \item a \mbox{{\instrFont jmp} $b$} \gls{instruction}, which
    unconditionally branches to block~$b$
\end{inlinelist}.
%
Assume also that these branch \glspl{instruction} take three cycles compared to
the other \glspl{instruction} in the \gls{target machine}, which take one cycle.

At first glance it appears that only the first jump \gls{instruction} is
selectable for implementing the conditional branch (see
\refFigure{isel-blorder-example-code-1}), leading to a total of six cycles for
the entire \gls{function}.
%
But by flipping the condition and swapping block labels (conditionally jumping
to \irBlock{b2} instead of \irBlock{b1}), the more complex jump
\gls{instruction} becomes selectable (see
\refFigure{isel-blorder-example-code-2}), bringing the cycle count to five
cycles and thus reducing the execution time by almost \SI{17}{\percent}.
%
However, although this decision may appear better at the point of
\gls{instruction selection}, it necessitates an additional jump
\gls{instruction} when ordering the \glspl{block} (because block~\irBlock{b1}
cannot fall-through to the top of itself; see
\refFigure{isel-blorder-example-code-3}).
%
This code takes eight cycles to execute, thus leading to a slowdown of
\SI{33}{\percent}.
%
The \gls{instruction selector} must therefore be aware of additional jump
\glspl{instruction} that may be required when making such decisions.

\section{Thesis Statement}

This dissertation proposes an approach where the tasks of \gls{instruction
  selection}, \gls{global code motion}, and \gls{block ordering} are combined
and solved using a combinatorial optimization technique called \gls!{constraint
  programming}.
%
Its thesis can be summarized as follows:
%
\begin{statement}
  \Glstext{constraint programming} is a flexible, practical, competitive, and
  extensible approach for combining \gls{global.is} \gls{instruction selection},
  \gls{global code motion}, and \gls{block ordering}.
\end{statement}
%
By \emph{flexible}, it means that the approach can handle more than one hardware
architecture.
%
By \emph{practical}, it means that the approach can select \glspl{instruction}
for \glspl{program} of sufficient complexity and scales to medium-sized
\glspl{function}.
%
By \emph{competitive}, it means that the approach generates code of equal or
better quality compared to an existing state-of-the-art \gls{compiler}.
%
By \emph{extensible}, it means that the approach can be extended to integrate
other, related tasks of \gls{code generation}.



\section{Approach}

\begin{figure}
  \centering%
  \input{figures/introduction/approach-overview}

  \caption{Overview of the approach}
  \labelFigure{approach-overview}
\end{figure}

The approach, outlined in \refFigure{approach-overview}, is as follows.
%
The \gls{IR} code of the \gls{program} under compilation is fed to a tool which
builds a graph-based representation of the \gls{program}.
%
The graph is subjected to a series of transformations and then fed to a matcher
together with the \gls{pattern set} of the specified \gls{target machine}.
%
The \gls{pattern set} is built from a \gls{machine description} and contains a
graph-based pattern for each \gls{instruction}, which have also been subjected
to similar transformations.
%
Taking the graph and \gls{pattern set} as input, the matcher produces a set of
\glspl{match}.
%
This is fed to a modeler, which constructs a problem instance of the
\gls{constraint model}.
%
The \glsshort{constraint model} is then solved by a generic off-the-shelf
\gls{constraint solver}.
%
The \gls{solution} is then fed to a code emitter, which produces the code
containing the selected \glspl{instruction}.



\section{Research methods}

\todo{write}

\section{Contributions}

The dissertation makes six contributions to the areas of \gls{code generation}
and \gls{constraint programming}:
%
\begin{contributions}
  \item \labelContribution{survey}
    a comprehensive and structured survey that covers over four decades of
    research in \gls{instruction selection};
  \item \labelContribution{representations}
    a \gls{program} and \gls{instruction} representation that enables
    \begin{contributions}
      \item \labelContribution{rep-uniformity}
        uniform treatment of data- and control-flow \glspl{operation}, and
      \item \labelContribution{rep-complex-instructions}
        modeling and pattern matching of complex \glspl{instruction} as
        \glspl{pattern}, and
      \item \labelContribution{rep-combining-problems}
        modeling of \gls{global.is} \gls{instruction selection} and \gls{global
          code motion} as a \gls{constraint model};
    \end{contributions}
  \item \labelContribution{constraint-model}
    a \gls{constraint model} and related transformations that, for the first
    time, integrates
    \begin{contributions}
      \item \labelContribution{cp-global-instruction-selection}
        \gls{global.is} \gls{instruction selection} with
      \item \labelContribution{cp-global-code-motion}
        \gls{global code motion},
    \end{contributions}
    and also integrates
    \begin{contributions}[resume]
      \item \labelContribution{cp-data-copying}
        \gls{data copying},
      \item \labelContribution{cp-block-ordering}
        \gls{block ordering}, and
      \item \labelContribution{cp-value-reuse}
        \gls{value reuse};
    \end{contributions}
  \item \labelContribution{solving-techniques}
    solving techniques that enable practical solving of the \gls{constraint
      model};
  \item \labelContribution{experiments}
    thorough experiments demonstrating that the approach scales to medium-sized
    \glspl{program} and yields better code than traditional approaches; and
  \item \labelContribution{integration}
    an initial design showing how the \gls{constraint model} can be extended to
    integrate other \gls{code generation} tasks, such as \gls{instruction
      scheduling} and \gls{register allocation}.
\end{contributions}
%
\refTable{contributions-per-chapter} shows in which chapters each contribution
is manifested and discussed further.

\begin{table}
  \centering%
  \begin{tabular}{c@{\qquad}*{12}{c}}
    \toprule
      \tabhead Chapter
    & \tabhead\refContribution{survey}
    & \multicolumn{3}{c}{\tabhead\refContribution{representations}}
    & \multicolumn{5}{c}{\tabhead\refContribution{constraint-model}}
    & \tabhead\refContribution{solving-techniques}
    & \tabhead\refContribution{experiments}
    & \tabhead\refContribution{integration} \\
    \cmidrule(lr){3-5}%
    \cmidrule(lr){6-10}%
    &
    & \tabhead\refContribution{rep-uniformity}
    & \tabhead\refContribution{rep-complex-instructions}
    & \tabhead\refContribution{rep-combining-problems}
    & \tabhead\refContribution{cp-global-instruction-selection}
    & \tabhead\refContribution{cp-global-code-motion}
    & \tabhead\refContribution{cp-data-copying}
    & \tabhead\refContribution{cp-block-ordering}
    & \tabhead\refContribution{cp-value-reuse}
    &
    &
    & \\
    \midrule
    \refChapter*{current-instruction-selection-techniques}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{universal-representations}
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{pattern-matching}
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{modeling-global-instruction-selection}
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{modeling-global-code-motion}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{modeling-data-copying}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{modeling-block-ordering}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{modeling-value-reuse}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{solving-techniques}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo
    & \supportNo \\
    \refChapter*{comparison-against-the-state-of-the-art}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo \\
    \refChapter*{integrating-other-code-generation-tasks}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes \\
    \refChapter*{macro-expansion}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{tree-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{dag-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refChapter*{graph-covering}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \bottomrule
  \end{tabular}

  \caption{Contributions per chapter}
  \labelTable{contributions-per-chapter}
\end{table}

\section{Publications}

This dissertation is based on material presented in the following publications:
%
\begin{publications}
  \item \labelPublication{survey-book}
    \fullcite{HjortBlindell:2016:Survey}.
  \item \labelPublication{cp-paper}
    \fullcite{HjortBlindellEtAl:2015:CP}.
  \item \labelPublication{cases-paper}
    \fullcite{HjortBlindellEtAl:2017:CASES}.
\end{publications}
%
\refTable{contributions-per-publication} shows the relation between the
contributions and the publications above.
%
\begin{table}
  \centering%
  \begin{tabular}{c@{\qquad}*{10}{c}}
    \toprule
      \tabhead Publication
    & \tabhead\refContribution{survey}
    & \tabhead\refContribution{representations}
    & \multicolumn{5}{c}{\tabhead\refContribution{constraint-model}}
    & \tabhead\refContribution{solving-techniques}
    & \tabhead\refContribution{experiments}
    & \tabhead\refContribution{integration} \\
    \cmidrule(lr){4-8}%
    &
    &
    & \tabhead\refContribution{cp-global-instruction-selection}
    & \tabhead\refContribution{cp-global-code-motion}
    & \tabhead\refContribution{cp-data-copying}
    & \tabhead\refContribution{cp-block-ordering}
    & \tabhead\refContribution{cp-value-reuse}
    &
    &
    & \\
    \midrule
    \refPublication{survey-book}
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo \\
    \refPublication{cp-paper}
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportNo \\
    \refPublication{cases-paper}
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportNo
    & \supportYes
    & \supportYes
    & \supportYes
    & \supportNo \\
    \bottomrule
  \end{tabular}

  \caption{Contributions per publication}
  \labelTable{contributions-per-publication}
\end{table}

The author also participated in the following publications, which are out of
scope for the dissertation:

\begin{publications}[resume]
  \item \labelPublication{survey-report}
    \fullcite{HjortBlindell:2013:Survey}.
  \item \labelPublication{lctes}
    \fullcite{CastanedaLozanoEtAl:2014:LCTES}.
  \item \labelPublication{cc}
    \fullcite{CastanedaLozanoEtAl:2016:CC}.
  \item \labelPublication{fdl-2016}
    \fullcite{HjortBlindellEtAl:2016:FDL}.
\end{publications}
%
\refPublication{survey-report} is excluded as it is subsumed and extended by
\refPublication{survey-book}. \refPublication{lctes} and \refPublication{cc} are
excluded as they are only partially related to the dissertation (they apply
\gls{constraint programming} to solve \gls{register allocation} and
\gls{instruction scheduling}). \refPublication{fdl-2016} is excluded as it
belongs to a different topic entirely (high-level code generation for graphics
processors).

\section{Outline}

\todo{Describe chapters}
\todo{Add figure illustrating how to read the dissertation}

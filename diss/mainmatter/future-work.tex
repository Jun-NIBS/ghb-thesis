% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Future Work}
\labelChapter{future-work}

This chapter discusses future work on how to extend the \gls{constraint model}
to incorporate other problems related to \gls{code generation}.
%
\RefSection{fw-isched} proposes an extension of the \gls{constraint model} for
integrating \gls{instruction scheduling}.
%
Based on this idea, \RefSection{fw-reg-alloc} proposes an extension for
integrating \gls{register allocation}.


\section{Integrating Instruction Scheduling}
\labelSection{fw-isched}

As described in \refChapter{introduction}, apart from \gls{instruction
  selection} the other two main problems of \gls{code generation} are
\gls{instruction scheduling} and \gls{register allocation}.
%
More importantly, it is well known that these three problems interact with one
another.
%
Hence, future work includes extending the \gls{constraint model} introduced in
this dissertation to integrate these problems.

In this context, the \gls{instruction scheduling} problem can be defined as
follows.
%
Given a \gls{block}~$b$ and a set of selected \glspl{match} placed in
$b$\hspace{-1pt}, assign to each \gls{match}~$m$ an issue cycle $c_m$ such that
\mbox{$c_m \!+ \mLat(m) \leq c_{m'}$}, where $\mLat(m)$ denotes the latency of
$m$\hspace{-1pt}, holds for every \gls{match}~$m'$ that \gls{use.d}[s]
\glspl{datum} \gls{define.d}[d] by $m$\hspace{-1pt}.
%
To model this problem, we require two new \glspl{variable}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{cycle}[m] \in \mNatNumSet$} models at
which cycle a \gls{match}~$m$ is scheduled, and the set of \glspl{variable}
\mbox{$\mVar{sched}[m, b] \in \mSet{0, 1}$} models whether $m$ is to be
scheduled in \gls{block}~$b$\hspace{-1pt}.


\subsubsection{Constraints}

If a selected \gls{match}~$m_1$ \gls{define.d}[s] a \gls{datum}~$d$ which is
used by another selected \gls{match}~$m_2$ and $m_1$ and $m_2$ are both placed
in the same \gls{block}, then $m_1$ must be scheduled before~$m_2$.
%
This can be modeled as
%
\begin{equation}
  \hspace*{-1em}
  \begin{array}{c}
    \mVar{sel}[m_1] \mAnd \mVar{sel}[m_2]
    \mAnd \mBlockOf(m_1) = \mBlockOf(m_2)
    \mAnd \mVar{alt}[p_1] = \mVar{alt}[p_2] \\
    \mbox{} \mImp
    \mVar{cycle}[m_1] + \mLat(m_1) \leq \mVar{cycle}[m_2] \\
    \forall m_1 \hspace{-1pt}, m_2 \in \mMatchSet,
    \forall p_1 \in \mDefines(m_1),
    \forall p_2 \in \mUses(m_2) \setminus \mDefines(m_2)
    \text{ \st }
    m_1 \neq m_2 \hspace{-.8pt},
  \end{array}
  \labelEquation{precedence}
\end{equation}
%
where \mbox{$\mBlockOf(m) \in \mBlockSet$} denotes the block wherein $m$ is
placed (see \refEquation{block-of-function}).

If the \gls{target machine} is a \gls{VLIW} architecture, then special care must
be taken to ensure that the resource capacities are not exceeded by the
\glspl{instruction}.
%
In this context, a resource capacity could be the number of \glspl{issue slot}
(that is, the number of \glspl{instruction} that can run in parallel; this is
called \gls!{bundling}) or the number of functional units available.\!%
%
\footnote{%
  Non-\gls{VLIW} architectures can be modeled using the same approach by setting
  the number of \glspl{issue slot} to 1.%
}
%
To model these restrictions, we will apply the same approach as in
\cite{CastanedaLozanoEtAl:2014:LCTES} and use the \gls!{cumulative constraint},
which constrains the scheduling times for a given set of tasks such that the
capacity of a given resource is not exceeded~\cite{SchuttEtAl:2011}.
%
\begin{figure}
  \centering%
  \input{figures/future-work/cumulative-example}

  \caption[Example illustrating the cumulative constraint]%
          {%
            Example of a solution to the cumulative constraint.
            %
            Each box represents a task%
          }
  \labelFigure{cumulative-example}
\end{figure}
%
An example is shown in \refFigure{cumulative-example}.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Cumulative Constraint]
  Let \mbox{$c \in \mNatNumSet$} represent the capacity of a resource to be used
  by $k$ optional tasks.
  %
  For each task~$i$, let \mbox{$\mVar{s}_i \in \mNatNumSet$} be a \gls{variable}
  representing the time at which $i$ is scheduled to start, \mbox{$l_i \in
    \mNatNumSet$} represent its latency, \mbox{$u_i \in \mNatNumSet$} represent
  the amount of resource required by~$i$, and \mbox{$\mVar{b}_i \in \mSet{0,
      1}$} be a \gls{variable} representing whether $i$ is scheduled.
  %
  Then
  %
  \begin{displaymath}
    \begin{array}{c}
      \mCumulative(
        c \hspace{-1pt},
        \mTuple{
          \mVar{s}_1 \hspace{-.8pt},
          l_1 \hspace{-.8pt},
          u_1 \hspace{-.8pt},
          \mVar{b}_1
        } \hspace{-1pt},
        \ldots,
        \mTuple{
          \mVar{s}_k \hspace{-.8pt},
          l_k \hspace{-.8pt},
          u_k \hspace{-.8pt},
          \mVar{b}_k
        }
      )
      \equiv \mbox{} \\
      \mSetBuilder*{%
                     \langle d_{\mVar{s}_1} \hspace{-.8pt}, \ldots, d_{\mVar{s}_k}
                             \hspace{-.8pt},
                             d_{\mVar{b}_1} \hspace{-.8pt}, \ldots, d_{\mVar{b}_k}
                             \hspace{-1pt}
                     \rangle
                   }%
                   {
                     \begin{array}{@{}l@{}}
                       \forall_{\! i} \: d_{\mVar{s}_i} \in \mDomain(\mVar{s}_i),
                       \forall_{\! i} \: d_{\mVar{b}_i} \in \mDomain(\mVar{b}_i)
                       \text{ \st} \\
                       \forall_{\! 1 \,\leq\, t \,<\, \mMax(\cup_i \mDomain(\mVar{s}_i))}
                         \displaystyle
                         \hspace{-1.2em}
                         \sum_{%
                                \substack{
                                  \forall{i} \text{ \st} \\
                                  d_{\mVar{s}_i} \,\leq\, t \,<\,
                                  d_{\mVar{s}_i} \hspace{-.8pt}+\, l_i
                                }
                              }
                         \hspace{-1.2em}
                           d_{\mVar{b}_i} \times u_i
                         \leq c
                     \end{array}
                   }\!.
    \end{array}
  \end{displaymath}
  \labelDefinition{cumulative}
\end{definition}

If \mbox{$\mCapOf(r) \in \mNatNumSet$} denotes the capacity of a
resource~\mbox{$r \in \mResourceSet$}, where $\mResourceSet$ denotes the set of
resources in the \gls{target machine}, \mbox{$\mLat(m) \in \mNatNumSet$} denotes
the latency of a \gls{match}~$m$\hspace{-.8pt}, and \mbox{$\mResourceUse(m, r)
  \in \mNatNumSet$} denotes the amount of $r$ used by $m$\hspace{-.8pt}, then
the \gls{constraint} can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mCumulative
    \!
    \left(
      \hspace{1pt}
      \mCapOf(r),
      \cup_{m \in \mMatchSet}
      \mTuple{
        \mVar{cycle}[m],
        \mLat(m),
        \mResourceUse(m, r),
        \mVar{sched}[m \hspace{-.8pt}, b]
      }
    \right) \\
    \forall r \in \mResourceSet,
    \forall b \in \mBlockSet \!.
  \end{array}
  \labelEquation{resource-capacities}
\end{equation}

Lastly, a \gls{match}~$m$ must be scheduled in \gls{block}~$b$ if and only if
$m$ is selected and placed in $b$, which can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sched}[m, b]
    \mEq
    \mVar{sel}[m] \mAnd \mBlockOf(m) = b \\
    \forall b \in \mBlockSet,
    \forall m \in \mMatchSet.
  \end{array}
  \labelEquation{optional-scheduling}
\end{equation}


\section{Integrating Register Allocation}
\labelSection{fw-reg-alloc}

In this context, \gls{register allocation} can be described as the problem of
assigning a location to each \gls{datum}~$d$ such that the value in the location
is preserved until the last use of~$d$.
%
Like with \gls{instruction selection}, this problem can be considered either at
\gls{local.ra} or \gls{global.ra}.
%
In \gls!{local.ra} \gls{register allocation}, \glspl{register} are allocated to
the variables in the \gls{function} one \gls{block} at a time, whereas
\gls!{global.ra} \gls{register allocation} does so for the entire
\gls{function}.
%
We begin by discussing the \gls{local.ra} problem and then extend it into the
\gls{global.ra} problem.


\subsection{Local Register Allocation}

\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Scheduled instructions%
                  \labelFigure{local-reg-alloc-example-ir}%
                }%
                [38mm]%
                {%
                  \input{figures/future-work/reg-alloc-example-styles}%
                  \adjustbox{valign=M}{%
                    \rotatebox{90}{cycles}%
                  }%
                  \setlength\extrarowheight{\gridYSize-11pt}%
                  \begin{tabular}{@{\hspace{3pt}}cl@{}}
                    1 & \irAssign{\irVar{b}}{\ldots} \\
                    2 & \irAssign{\irVar{c}}{\ldots \irVar{a} \ldots} \\
                    3 & \irAssign{\irVar{d}}%
                                 {\ldots \irVar{a}, \irVar{b} \ldots} \\
                    \raisebox{0pt}[\gridYSize-2pt]{\vdots} &
                  \end{tabular}

                  \vspace*{3.5pt}
                }%
  \hfill\hfill%
  \subcaptionbox{%
                  Live ranges%
                  \labelFigure{local-reg-alloc-example-live-ranges}%
                }{%
                  \input{%
                    figures/future-work/local-reg-alloc-example-live-ranges%
                  }%
                }%
  \hfill\hfill%
  \subcaptionbox{%
                  Rectangle packing problem%
                  \labelFigure{local-reg-alloc-example-rect-packing}%
                }%
                [42mm]%
                {%
                  \input{%
                    figures/future-work/local-reg-alloc-example-rect-packing%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption[Example of local register allocation]%
          {%
            Example of local register allocation.
            %
            It is assumed that variables~\irVar{a}, \irVar{c}, and \irVar{d}
            each fit inside a single register whereas variable \irVar{b}
            requires two adjacent registers%
          }
  \labelFigure{local-reg-alloc-example}
\end{figure}

We will describe the problem using the example is shown in
\refFigure{local-reg-alloc-example}.
%
Assume a set of \glspl{instruction} in a given \gls{block} that have been
scheduled (\refFigure{local-reg-alloc-example-ir}).
%
From the schedule a \gls!{live range} is computed for each variable, which is
the point in time where the variable is defined until the point where it is last
used (\refFigure{local-reg-alloc-example-live-ranges}).
%
If two variables have overlapping \glspl{live range}, then they cannot be
assigned the same \gls{register} as one of the values would be overwritten
before its last use.
%
By representing each variable by a rectangle, the problem of assigning
\glspl{register} can be modeled as a rectangle packing
problem~\cite{Quintao-PereiraPalsberg:2008}
(\refFigure{local-reg-alloc-example-rect-packing}).
%
The height of each rectangle corresponds to variable's \gls{live range}, and the
width corresponds to the size of the value (that is, the number of
\glspl{register} it requires).

For simplicity, let us assume for now that we only consider \glspl{function}
containing a single \gls{block}, which removes the need of having to deal with
\glspl{live range} spanning multiple \glspl{block}.
%
Also, since the \glspl{live range} depend on the schedule, we build upon the
\gls{constraint model} proposed in \refSection{fw-isched}.


\subsubsection{Variables}

The two sets of \glspl{variable} \mbox{$\mVar{start}[d] \in \mNatNumSet$} and
\mbox{$\mVar{end}[d] \in \mNatNumSet$} models the start respectively end of the
\gls{live range} for a \gls{datum}~$d$\hspace{-1pt}.
%
Note that the \gls{register} to which $d$ is assigned is already modeled by the
$\mVar{loc}$~\glspl{variable}.
%
In addition, the set of \glspl{variable} \mbox{$\mVar{alive}[d] \in \mSet{0,
    1}$} models whether $d$ is alive (in other words, $d$ is not
\gls{killed.d}), and the set of \glspl{variable}
\mbox{$\mVar{using}[m \hspace{-1pt}, d] \in \mSet{0, 1}$} models whether
\gls{match}~$m$ uses \gls{datum}~$d$\hspace{-1pt}.


\subsubsection{Constraints}

First, we constrain the $\mVar{alive}$~\glspl{variable} according to the
definition of what it means for \glspl{datum} to be \gls{killed.d}, which is
modeled as
%
\begin{equation}
  \mVar{alive}[d]
  \mEq
  \mVar{loc}[d] = \mKilledLocation
  \mQuantSep
  \forall d \in \mDataSet \!.
  \labelEquation{alive}
\end{equation}

Now, if a \gls{datum}~$d$ is not \gls{killed.d}, then the start of a \gls{live
  range} for a \gls{datum}~$d$ is determined by the \gls{match}
\glsshort{define.d}[ing] $d$\hspace{-1pt}.
%
Otherwise, the start is set to zero.
%
This can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{alive}[d]
    \mImp
    \mVar{start}[d] = \mVar{cycle}[\mVar{dmatch}[m]] \\
    \forall d \in \mDataSet \!,
    \forall m \in \mMatchSet[d] \hspace{-.8pt},
  \end{array}
  \labelEquation{local-live-range-start}
\end{equation}
%
\begin{equation}
  \neg\mVar{alive}[d]
  \mImp
  \mVar{start}[d] = 0
  \mQuantSep
  \forall d \in \mDataSet \!.
  \labelEquation{local-killed-range-start}
\end{equation}

Similarly, the end of a \gls{live range} for a live \gls{datum}~$d$ is
determined by the \gls{match} making the last \gls{use.d} of $d$\hspace{-1pt}.
%
If there is no use of $d$, then $\mVar{end}[d]$ is set to $\mVar{start}[d]$ as
to not affect \gls{register allocation} and \gls{instruction scheduling}.
%
This can jointly be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{end}[d] =
    \mMax\!
    \left(
      \cup_{m \,\in\, \mUsersOf(d)} \,
      \mVar{cycle}[m]
      \times
      \mVar{using}[m \hspace{-1pt}, d]
      \cup
      \mSet{\mVar{start}[d]}
    \right) \\
    \forall d \in \mDataSet \!.
  \end{array}
  \labelEquation{local-live-range-end}
\end{equation}
%
where
%
\begin{equation}
  \mUsersOf(d)
  \equiv
  \mSetBuilder{m}%
              {
                m \in \mMatchSet,
                \exists p \in \mUses(m)
                \text{ \st } d \in \mDataSet[p]
              }.
  \labelEquation{users-of-function}
\end{equation}

A \gls{match}~$m$ makes use of a \gls{datum}~$d$ if and only if $m$ is selected
and one of its \glspl{operand} are connected to $d$\hspace{-1pt}, which can be
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{using}[m \hspace{-1pt}, d]
    \mEq
    \mVar{sel}[m] \mAnd \mVar{alt}[p] = d \\
    \forall d \in \mDataSet \!,
    \forall m \in \mMatchSet,
    \forall p \in \mUses(m).
  \end{array}
  \labelEquation{local-m-using-d}
\end{equation}

To model the rectangle packing problem, we use the \gls!{no-overlap constraint}
(often also called the \gls!{diffn constraint}), which enforces that no two
rectangles may overlap \todo{insert citation}.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[No-Overlap Constraint]
  For each rectangle~$i$, let \mbox{$\mVar{xl}_i, \mVar{xr}_i, \mVar{yl}_i,
    \mVar{yu}_i \in \mNatNumSet$} be \glspl{variable} representing the
  rectangle's left, right, lower, respectively upper boundary.
  %
  Then
  %
  \begin{displaymath}
    \begin{array}{c}
      \mNoOverlap(
        \mTuple{
          \mVar{xl}_1 \hspace{-.8pt},
          \mVar{xr}_1 \hspace{-.8pt},
          \mVar{yl}_1 \hspace{-.8pt},
          \mVar{yu}_1 \hspace{-.8pt}
        } \hspace{-1pt},
        \ldots,
        \mTuple{
          \mVar{xl}_k \hspace{-.8pt},
          \mVar{xr}_k \hspace{-.8pt},
          \mVar{yl}_k \hspace{-.8pt},
          \mVar{yu}_k \hspace{-.8pt}
        }
      )
      \equiv \mbox{} \\
      \mSetBuilder*{%
                     \left\langle
                       \begin{array}{@{}c@{}}
                         d_{\mVar{xl}_1} \hspace{-.8pt}, \ldots, d_{\mVar{xl}_k}
                         \hspace{-.8pt},
                         d_{\mVar{xr}_1} \hspace{-.8pt}, \ldots, d_{\mVar{xr}_k}
                         \hspace{-.8pt}, \\
                         d_{\mVar{yl}_1} \hspace{-.8pt}, \ldots, d_{\mVar{yl}_k}
                         \hspace{-.8pt},
                         d_{\mVar{yu}_1} \hspace{-.8pt}, \ldots, d_{\mVar{yu}_k}
                       \end{array}
                     \right\rangle
                   }%
                   {
                     \begin{array}{@{}l@{}}
                       \forall_{\! i} \: d_{\mVar{xl}_i} \in \mDomain(\mVar{xl}_i),
                       \forall_{\! i} \: d_{\mVar{xr}_i} \in \mDomain(\mVar{xr}_i),
                       \\
                       \forall_{\! i} \: d_{\mVar{yl}_i} \in \mDomain(\mVar{yl}_i),
                       \forall_{\! i} \: d_{\mVar{yu}_i} \in \mDomain(\mVar{yu}_i)
                       \text{ \st} \\
                       \begin{array}{@{}r@{\:}l@{}}
                           \forall_{\! 1 \,\leq\, i \,<\, j \,\leq\, k}
                         & \mVar{xr_i} \leq \mVar{xl_j} \mOr
                           \mVar{xl_i} \geq \mVar{xr_j} \mOr \mbox{} \\
                         & \mVar{yu_i} \leq \mVar{yl_j} \mOr
                           \mVar{yl_i} \geq \mVar{yu_j}
                       \end{array}
                     \end{array}
                   }\!.
    \end{array}
  \end{displaymath}
  \labelDefinition{no-overlap}
\end{definition}
%
Thus the rectangle packing problem can be modeled as
%
\begin{equation}
  \mNoOverlap\!
  \left(
    \cup_{d \,\in\, \mDataSet}
      \mTuple{
         \mVar{start}[d],
         \mVar{end}[d],
         \mVar{loc}[d],
         \mVar{loc}[d] + \mWidthOf(d)
      }
  \right)\!,
  \labelEquation{local-rect-packing}
\end{equation}
%
where \mbox{$\mWidthOf(d) \in \mNatNumSet$} denotes the number of
\glspl{register} required for \gls{datum}~$d$\hspace{-1pt}.


\subsection{Global Register Allocation}

The main problem of extending \gls{local.ra} \gls{register allocation} to
\gls{global.ra} scope is that placements of \glspl{match} to \glspl{block} need
to be taken into consideration.
%
Furthermore, the \glspl{live range} are no longer necessarily limited within a
single \gls{block} but may span multiple \glspl{block}.
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Scheduled instructions%
                  \labelFigure{global-reg-alloc-example-ir}%
                }%
                [38mm]%
                {%
                  \figureFont\figureFontSize%
                  \begin{tabular}{@{}c@{\hspace{.5em}}l@{}}
                      \irBlock{A:}
                    & \irAssign{\irVar{x}}{\ldots} \\
                    & \irCondBr{\ldots}{B}{C} \\
                      \irBlock{B:}
                    & \ldots \\
                    & \irBr{D} \\
                      \irBlock{C:}
                    & \ldots \\
                    & \irBr{D} \\
                      \irBlock{D:}
                    & \ldots \\
                    & \irAssign{\irVar{y}}{\ldots \irVar{x} \ldots}
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  Live ranges of \irVar{x}%
                  \labelFigure{global-reg-alloc-example-live-ranges}%
                }{%
                  \input{%
                    figures/future-work/global-reg-alloc-example-live-ranges%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of global register allocation}
  \labelFigure{global-reg-alloc-example}
\end{figure}
%
An example is shown in \refFigure{global-reg-alloc-example}.
%
Assume a \gls{function} where a variable~\irVar{x} is defined in one
\gls{block}~\irBlock{A} and used in another \gls{block}~\irBlock{D}
(\refFigure{global-reg-alloc-example-ir}).
%
Consequently, \irVar{x} must be live to the end of \irBlock{A}, through all
\glspl{block} between \irBlock{A} and \irBlock{D} (that is,
\glspl{block}~\irBlock{B} and~\irBlock{C}), and until the last use in
\irBlock{D} (\refFigure{global-reg-alloc-example-live-ranges}).

We extend the \gls{constraint model} proposed for \gls{local.ra} \gls{register
  allocation} by first creating $\mVar{start}$ and $\mVar{end}$~\glspl{variable}
for each \gls{block} in the \gls{function} together with an additional set of
\glspl{variable}, and then extending the \glspl{constraint} to handle multiple
\glspl{block}.


\subsubsection{Variables}

The two sets of \glspl{variable} \mbox{$\mVar{start}[d \hspace{-1pt}, b] \in
  \mNatNumSet$} and \mbox{$\mVar{end}[d \hspace{-1pt}, b] \in \mNatNumSet$}
models the start respectively end of the \gls{live range} for a \gls{datum}~$d$
in \gls{block}~$b$\hspace{-1pt}.
%
In addition, the set of \glspl{variable} \mbox{$\mVar{useafter}[d \hspace{-1pt},
    b] \in \mSet{0, 1}$} models, given a \gls{datum}~$d$ and a
\gls{block}~$b$\hspace{-1pt}, whether there exists some selected \gls{match}
making use of $d$ in one of the \glspl{block} to which a branch from $b$ can
occur.


\subsubsection{Constraints}

Even with multiple \glspl{block}, the start of a \gls{live range} is still
determined by the \gls{match} defining the \gls{datum}.
%
Morever, the \gls{constraint} that no two rectangles belonging to the same
\gls{block} may overlap still apply.
%
Hence Eqs.\thinspace\refEquation*{local-live-range-start},
\refEquation*{local-killed-range-start}, and~\refEquation*{local-rect-packing}
are adjusted accordingly (the changes are highlighted in grey):
%
\begin{equation}
  \begin{array}{c}
    \hlDiff{(}
      \mVar{alive}[d]
      \hlDiff{
        \mbox{}
        \mAnd
        \mVar{dplace}[d] = b
    )}
    \mImp
    \mVar{start}[d] = \mVar{cycle}[\mVar{dmatch}[m]] \\
    \forall d \in \mDataSet \!,
    \hlDiff{\forall b \in \mBlockSet \hspace{-1pt},} \,
    \forall m \in \mMatchSet[d] \hspace{-.8pt},
  \end{array}
  \labelEquation{global-live-range-start}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \hlDiff{(}
      \neg\mVar{alive}[d]
      \hlDiff{
        \mbox{}
        \mOr
        \mVar{dplace}[d] \neq b
      }
    \hlDiff{)}
    \mImp
    \mVar{start}[d \hlDiff{\hspace{-.4pt}, b}] = 0 \\
    \forall d \in \mDataSet \hspace{-1pt},
    \hlDiff{\forall b \in \mBlockSet \hspace{-1pt},}
  \end{array}
  \labelEquation{global-killed-range-start}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mNoOverlap\!
    \left(
      \cup_{d \,\in\, \mDataSet}
        \mTuple{
           \mVar{start}[d \hlDiff{\hspace{-.4pt}, b}],
           \mVar{end}[d \hlDiff{\hspace{-.4pt}, b}],
           \mVar{loc}[d],
           \mVar{loc}[d] + \mWidthOf(d)
        }
    \right) \\
    \hlDiff{\forall b \in \mBlockSet} \hspace{-1pt}.
  \end{array}
  \labelEquation{global-rect-packing}
\end{equation}

Intuitively, given a \gls{datum}~$d$ and a \gls{block}~$b$\hspace{-1pt}, if $d$
is used in some \gls{block}~$b'$ following $b$ (meaning there is a jump from $b$
to $b'$), then the \gls{live range} of $d$ must extend until the end of the
schedule for $b$\hspace{-1pt}.
%
This can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{useafter}[d \hspace{-1pt}, b]
    \mImp
    \mVar{end}[d \hspace{-1pt}, b]
    =
    \mMax(
      \cup_{d' \,\in\, \mDataSet \text{ \st } d' \neq d} \,
      \mVar{end}[d' \!\!, b]
    ) \\
    \forall d \in \mDataSet \!,
    \forall b \in \mBlockSet \hspace{-1pt},
  \end{array}
  \labelEquation{global-live-range-end-def-and-int-blocks}
\end{equation}
%
For every other \glspl{block}~$b''\!$, either $d$ is not used in
$b''$ or the last use of $d$ occurs in $b''\!$, which can jointly be modeled as
%
\begin{equation}
  \begin{array}{c}
    \neg\mVar{useafter}[d \hspace{-1pt}, b]
    \mImp \mbox{} \\
    \mVar{end}[d, b]
    =
    \mMax\!
    \left(
      \begin{array}{@{}c@{}}
        \cup_{m \,\in\, \mUsersOf(d)} \,
        \mVar{cycle}[m]
        \times
        \mVar{sched}[m \hspace{-1pt}, b]
        \times
        \mVar{using}[m \hspace{-1pt}, d] \\
        \mbox{} \cup
        \mSet{\mVar{start}[d, b]}
      \end{array}
    \right) \\
    \forall d \in \mDataSet \!,
    \forall b \in \mBlockSet \hspace{-1pt}.
  \end{array}
  \labelEquation{global-live-range-end-last-use-block}
\end{equation}
%
Equations \refEquation*{global-live-range-end-def-and-int-blocks}
and~\refEquation*{global-live-range-end-last-use-block} implicitly assume that
\glspl{phi-match} are always scheduled first,%
%
\footnote{%
  This is because \glspl{datum} \gls{define.d}[d] and \gls{use.d}[d] within
  loops must be live across the entire loop, meaning the \glspl{live range} must
  start at the beginning of the \gls{block}.
  %
  Since the \glspl{phi-match} \gls{define.d} the \glspl{datum} to be
  \gls{use.d}[d] within the loop, these must appear first in the schedule.
}%
which can be enforced by
%
\begin{equation}
  \mVar{cycles}[m] = 0
  \mQuantSep
  \forall m \in \mPhiMatchSet.
  \labelEquation{schedule-phi-matches}
\end{equation}

Lastly, we constrain the $\mVar{useafter}$~\glspl{variable} according to the
definition above, which can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{useafter}[d \hspace{-1pt}, b_1]
    \mEq
    \exists m \in \mMatchSet
    \text{ \st }
    \mVar{using}[m \hspace{-1pt}, d]
    \mAnd
    \mVar{sched}[m \hspace{-1pt}, b_2]
    \\
    \forall d \in \mDataSet \!,
    \forall b_1, b_2 \in \mBlockSet
    \text{ \st }
    b_2 \in \mBranches(b_1),
  \end{array}
  \labelEquation{global-use-after-block}
\end{equation}
%
where \mbox{$\mBranches(b) \subseteq \mBlockSet$} gives the set of \glspl{block}
to which a branch from \gls{block}~$b$ can occur.

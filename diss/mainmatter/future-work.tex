% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Future Work}
\labelChapter{future-work}

\todo{add chapter outline}

\todo{mention Robertos contribution}


\section{Integrating Instruction Scheduling}

In this context, the \gls{instruction scheduling} problem can be defined as
follows.
%
Given a \gls{block}~$b$ and a set of selected \glspl{match} placed in
$b$\hspace{-1pt}, assign to each \gls{match}~$m$ an issue cycle $c_m$ such that
\mbox{$c_m \!+ \mLat(m) \leq c_{m'}$}, where $\mLat(m)$ denotes the latency of
$m$\hspace{-1pt}, holds for every \gls{match}~$m'$ that \gls{use.d}[s]
\glspl{datum} \gls{define.d}[d] by $m$\hspace{-1pt}.
%
To model this problem, we require two new \glspl{variable}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{cycle}[m] \in \mNatNumSet$} models at
which cycle a \gls{match}~$m$ is scheduled, and the set of \glspl{variable}
\mbox{$\mVar{sched}[m, b] \in \mSet{0, 1}$} models whether $m$ is to be
scheduled in \gls{block}~$b$\hspace{-1pt}.


\subsubsection{Constraints}

If a selected \gls{match}~$m_1$ \gls{define.d}[s] a \gls{datum}~$d$ which is
used by another selected \gls{match}~$m_2$ and $m_1$ and $m_2$ are both placed
in the same \gls{block}, then $m_1$ must be scheduled before~$m_2$.
%
This can be modeled as
%
\begin{equation}
  \hspace*{-1em}
  \begin{array}{c}
    \mVar{sel}[m_1] \mAnd \mVar{sel}[m_2]
    \mAnd \mBlockOf(m_1) = \mBlockOf(m_2)
    \mAnd \mVar{alt}[p_1] = \mVar{alt}[p_2] \\
    \mbox{} \mImp
    \mVar{cycle}[m_1] + \mLat(m_1) \leq \mVar{cycle}[m_2] \\
    \forall m_1 \hspace{-1pt}, m_2 \in \mMatchSet,
    \forall p_1 \in \mDefines(m_1),
    \forall p_2 \in \mUses(m_2) \setminus \mDefines(m_2)
    \text{ \st }
    m_1 \neq m_2 \hspace{-.8pt},
  \end{array}
  \labelEquation{precedence}
\end{equation}
%
where \mbox{$\mBlockOf(m) \in \mBlockSet$} denotes the block wherein $m$ is
placed (see \refEquation{block-of-function}).

If the \gls{target machine} is a \gls{VLIW} architecture, then special care must
be taken to ensure that the resource capacities are not exceeded by the
\glspl{instruction}.
%
In this context, a resource capacity could be the number of \glspl{issue slot}
(that is, the number of \glspl{instruction} that can run in parallel) or the
number of functional units available.\!%
%
\footnote{%
  Non-\gls{VLIW} architectures can be modeled using the same approach by setting
  the number of \glspl{issue slot} to 1.%
}
%
To model these restrictions, we will apply the same approach as in
\cite{CastanedaLozanoEtAl:2014:LCTES} and use the \gls!{cumulative constraint},
which constrains the scheduling times for a given set of tasks such that the
capacity of a given resource is not exceeded~\cite{SchuttEtAl:2011}.
%
\begin{figure}
  \centering%
  \input{figures/future-work/cumulative-example}

  \caption[Example illustrating the cumulative constraint]%
          {%
            Example of a solution to the cumulative constraint.
            %
            Each box represents a task%
          }
  \labelFigure{cumulative-example}
\end{figure}
%
An example is shown in \refFigure{cumulative-example}.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Cumulative Constraint]
  Let \mbox{$c \in \mNatNumSet$} represent the capacity of a resource to be used
  by $k$ optional tasks.
  %
  For each task~$i$, let \mbox{$\mVar{s}_i \in \mNatNumSet$} be a \gls{variable}
  representing the time at which $i$ is scheduled to start, \mbox{$l_i \in
    \mNatNumSet$} represent its latency, \mbox{$u_i \in \mNatNumSet$} represent
  the amount of resource required by~$i$, and \mbox{$\mVar{b}_i \in \mSet{0,
      1}$} be a \gls{variable} representing whether $i$ is scheduled.
  %
  Then
  %
  \begin{displaymath}
    \begin{array}{c}
      \mCumulative(
        c \hspace{-1pt},
        \mTuple{
          \mVar{s}_1 \hspace{-.8pt},
          l_1 \hspace{-.8pt},
          u_1 \hspace{-.8pt},
          \mVar{b}_1
        } \hspace{-1pt},
        \ldots,
        \mTuple{
          \mVar{s}_k \hspace{-.8pt},
          l_k \hspace{-.8pt},
          u_k \hspace{-.8pt},
          \mVar{b}_k
        }
      )
      \equiv \mbox{} \\
      \mSetBuilder*{%
                     \langle d_{\mVar{s}_1} \hspace{-.8pt}, \ldots, d_{\mVar{s}_k}
                             \hspace{-.8pt},
                             d_{\mVar{b}_1} \hspace{-.8pt}, \ldots, d_{\mVar{b}_k}
                             \hspace{-1pt}
                     \rangle
                   }%
                   {
                     \begin{array}{@{}l@{}}
                       \forall_{\! i} \: d_{\mVar{s}_i} \in \mDomain(\mVar{s}_i),
                       \forall_{\! i} \: d_{\mVar{b}_i} \in \mDomain(\mVar{b}_i)
                       \text{ \st} \\
                       \forall_{\! 1 \,\leq\, t \,<\, \mMax(\cup_i \mDomain(\mVar{s}_i))}
                         \displaystyle
                         \hspace{-1.2em}
                         \sum_{%
                                \substack{
                                  \forall{i} \text{ \st} \\
                                  d_{\mVar{s}_i} \,\leq\, t \,<\,
                                  d_{\mVar{s}_i} \hspace{-.8pt}+\, l_i
                                }
                              }
                         \hspace{-1.2em}
                           d_{\mVar{b}_i} \times u_i
                         \leq c
                     \end{array}
                   }\!.
    \end{array}
  \end{displaymath}
  \labelDefinition{cumulative}
\end{definition}

If \mbox{$\mCapOf(r) \in \mNatNumSet$} denotes the capacity of a
resource~\mbox{$r \in \mResourceSet$}, where $\mResourceSet$ denotes the set of
resources in the \gls{target machine}, \mbox{$\mLat(m) \in \mNatNumSet$} denotes
the latency of a \gls{match}~$m$\hspace{-.8pt}, and \mbox{$\mResourceUse(m, r)
  \in \mNatNumSet$} denotes the amount of $r$ used by $m$\hspace{-.8pt}, then
the \gls{constraint} can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mCumulative
    \!
    \left(
      \hspace{1pt}
      \mCapOf(r),
      \cup_{m \in \mMatchSet}
      \mTuple{
        \mVar{cycle}[m],
        \mLat(m),
        \mResourceUse(m, r),
        \mVar{sched}[m \hspace{-.8pt}, b]
      }
    \right) \\
    \forall r \in \mResourceSet,
    \forall b \in \mBlockSet \!.
  \end{array}
  \labelEquation{resource-capacities}
\end{equation}

Lastly, a \gls{match}~$m$ must be scheduled in \gls{block}~$b$ if and only if
$m$ is selected and placed in $b$, which can be modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sched}[m, b]
    \mEq
    \mVar{sel}[m] \mAnd \mBlockOf(m) = b \\
    \forall b \in \mBlockSet,
    \forall m \in \mMatchSet.
  \end{array}
  \labelEquation{optional-scheduling}
\end{equation}


\section{Integrating Register Allocation}

In this context, \gls{register allocation} can be described as the problem of
assigning a location to each \gls{datum}~$d$ such that the value in the location
is preserved until the last use of~$d$.
%
Like with \gls{instruction selection}, this problem can be considered either at
\gls{local.ra} or \gls{global.ra}.
%
In \gls!{local.ra} \gls{register allocation}, \glspl{register} are allocated to
the variables in the \gls{function} one \gls{block} at a time, whereas
\gls!{global.ra} \gls{register allocation} does so for the entire
\gls{function}.
%
We begin by discussing the \gls{local.ra} problem and then extend it into the
\gls{global.ra} problem.


\subsection{Local Register Allocation}

\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Scheduled instructions%
                  \labelFigure{local-reg-alloc-example-ir}%
                }%
                [38mm]%
                {%
                  \input{figures/future-work/local-reg-alloc-example-styles}%
                  \adjustbox{valign=M}{%
                    \rotatebox{90}{cycles}%
                  }%
                  \setlength\extrarowheight{\gridYSize-11pt}%
                  \begin{tabular}{@{\hspace{3pt}}cl@{}}
                    1 & \irAssign{\irVar{b}}{\ldots} \\
                    2 & \irAssign{\irVar{c}}{\ldots \irVar{a} \ldots} \\
                    3 & \irAssign{\irVar{d}}%
                                 {\ldots \irVar{a}, \irVar{b} \ldots} \\
                    \raisebox{0pt}[\gridYSize-2pt]{\vdots} &
                  \end{tabular}

                  \vspace*{3.5pt}
                }%
  \hfill\hfill%
  \subcaptionbox{%
                  Live ranges%
                  \labelFigure{local-reg-alloc-example-live-ranges}%
                }{%
                  \input{%
                    figures/future-work/local-reg-alloc-example-live-ranges%
                  }%
                }%
  \hfill\hfill%
  \subcaptionbox{%
                  Rectangle packing problem%
                  \labelFigure{local-reg-alloc-example-rect-packing}%
                }%
                [42mm]%
                {%
                  \input{%
                    figures/future-work/local-reg-alloc-example-rect-packing%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption[Example of local register allocation]%
          {%
            Example of local register allocation.
            %
            It is assumed that variables~\irVar{a}, \irVar{c}, and \irVar{d}
            each fit inside a single register whereas variable \irVar{b}
            requires two adjacent registers%
          }
  \labelFigure{local-reg-alloc-example}
\end{figure}

We will describe the problem using the example is shown in
\refFigure{local-reg-alloc-example}.
%
Assume a set of \glspl{instruction} in a given \gls{block} that have been
scheduled (\refFigure{local-reg-alloc-example-ir}).
%
From the schedule a \gls!{live range} is computed for each variable, which is
the point in time where the variable is defined until the point where it is last
used (\refFigure{local-reg-alloc-example-live-ranges}).
%
If two variables have overlapping \glspl{live range}, then they cannot be
assigned the same \gls{register} as one of the values would be overwritten
before its last use.
%
By representing each variable by a rectangle, the problem of assigning
\glspl{register} can be modeled as a rectangle packing
problem~\cite{Quintao-PereiraPalsberg:2008}
(\refFigure{local-reg-alloc-example-rect-packing}).
%
The height of each rectangle corresponds to variable's \gls{live range}, and the
width corresponds to the size of the value (that is, the number of
\glspl{register} it requires).


\subsubsection{Variables}

\todo{add variables}


\subsubsection{Constraints}

\todo{add constraints}


\subsection{Global Register Allocation}

\todo{model the problem}


\subsubsection{Variables}

\todo{add variables}


\subsubsection{Constraints}

\todo{add constraints}

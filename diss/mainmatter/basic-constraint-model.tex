% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Basic Constraint Model}

TODO: define $\mUFGraph$

\section{Global Instruction Selection}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is
\gls{cover}[ed].
%
There are two variants of this problem:
%
\begin{enumerateinline}
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerateinline}
%
The former problem is more common as it results in simpler models, with smaller
\glspl{solution space}, and allows use of \glspl{constraint} that enable strong
\gls{propagation}, which are essential for curbing solving time and increasing
scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.

\subsection{Modeling}

For sake of tractability, the constraint model introduced in this chapter
assumes the former problem of \gls{global.is}[ \gls{instruction selection}].
%
The set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0, 1}$} models
whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected, where $\mMatchSet$
denotes the match set found for $\mUFGraph$.
%
The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected match covers operation~\mbox{$o \in \mOpSet$}, where $\mOpSet$
denotes the set of operations in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq
  \mMatchSet$} denotes the set of \glspl{match} that can cover~$o$.

\begin{equation}
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m]
  \mQuantSep
  \forall o \in \mOpSet,
  \forall m \in \mMatchSet[o]
  \labelEquation{operation-coverage}
\end{equation}

\begin{equation}
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m]
  \mQuantSep
  \forall d \in \mDataSet,
  \forall m \in \mMatchSet[d]
  \labelEquation{data-definitions}
\end{equation}



\section{Global Code Motion}
\subsection{Problem}
\subsection{Modeling}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o_1] = \mVar{oplace}[o_2] \\
    \forall m \in \mMatchSet,
    \forall o_1 \in \mCovers(m),
    \forall o_2 \in \mCovers(m)
  \end{array}
  \labelEquation{operation-placement}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o] = b \\
    \forall m \in \mMatchSet,
    \forall o \in \mCovers(m),
    \forall b \in \mEntry(m)
  \end{array}
  \labelEquation{jump-placements}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in \mDom(\mVar{oplace}[o]) \\
    \forall m \in \mMatchCompSet{\mPhi},
    \forall d \in \mUses(m),
    \forall o \in \mCovers(m)
  \end{array}
  \labelEquation{dom}
\end{equation}

\begin{equation}
  \mVar{dplace}[d] = b
  \mQuantSep
  \forall \mUnDirEdge{d}{b} \in \mDefEdgeSet,
  \labelEquation{def-edges}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d] \in \mSet{\mVar{oplace}[o]} \cup \mSpans(m) \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m),
    \forall o \in \mCovers(m)
  \end{array}
  \labelEquation{spanning}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{oplace}[o] \neq b \\
    \forall o \in \mOpSet,
    \forall m \in \mMatchSet,
    \forall b \in \mConsumes(m)
  \end{array}
  \labelEquation{consumption}
\end{equation}



\section{Block Ordering}
\subsection{Problem}
\subsection{Modeling}

\begin{equation}
  \mCircuit\left(
    \cup_{b \in \mBlockSet} \{\mVar{succ}[b]\}
  \right)
  \labelEquation{block-order}
\end{equation}



\section{Objective Function}
\subsection{Problem}
\subsection{Modeling}

\begin{equation}
  \sum_{b \in \mBlockSet}
  \Big(
    \mFreq(b) \times
    \hspace{-4.5mm}
    \sum_{
      \substack{
        m \in \mMatchSet \:\text{s.t.} \\
        \mVar{place}[m] = b
      }
    }
     \hspace{-4.5mm}
    \mCost(m)
  \Big)
  \labelEquation{naive-objective-function}
\end{equation}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Pattern Matching}
\labelChapter{pattern-matching}

\todo{write chapter summary}



\section{TODO: name intro section}

\todo{write}



\section{Proof That Separating Matching From Selection Preserves Optimality}

\todo{write}


\section{The VF2 Algorithm}
\labelSection{pm-vf2-algorithm}

Due to its simplicity and ease of implementation,
\gls{VF2}~\cite{CordellaEtAl:2001} was selected as the \gls{subgraph
  isomorphism} algorithm used in this work.\!%
%
\footnote{%
  In his dissertation, \textcite{McCreesh:2017} advices against using \gls{VF2}
  after showing that, for large body of problem instances, it exhibits
  considerably worse performance compared to two other \gls{subgraph
    isomorphism} algorithms (\gls{LAD}~\cite{Solnon:2010} and
  \gls{Glasgow}~\cite{McCreeshProsser:2015}).
  %
  In case of \gls{instruction selection}, however, the problem instances are
  small enough that the time for finding all \glspl{match} is negligible
  compared to the time for solving the \gls{constraint model}.
}
%
\def\fG{G_{\textrm{\textsc{f}}}}%
\def\pG{G_{\textrm{\textsc{p}}}}%
\def\fN{N_{\textrm{\textsc{f}}}}%
\def\fE{E_{\textrm{\textsc{f}}}}%
\def\pN{N_{\textrm{\textsc{p}}}}%
\def\pE{E_{\textrm{\textsc{p}}}}%
\def\mSynRuleCheck{F_{\textrm{\textsc{syn}}}}%
\def\mSemRuleCheck{F_{\textrm{\textsc{sem}}}}%
\def\fTout{T_{\!\textrm{\textsc{f}}}^{\hspace{.5pt}\textrm{\textsc{out}}}}%
\def\pTout{T_{\!\textrm{\textsc{p}}}^{\hspace{.5pt}\textrm{\textsc{out}}}}%
\def\fTin{T_{\!\textrm{\textsc{f}}}^{\textrm{\textsc{in}}}}%
\def\pTin{T_{\!\textrm{\textsc{p}}}^{\textrm{\textsc{in}}}}%
\begin{algorithm}[t]
  \DeclFunction{FindMatches}{function graph $\fG = \mPair{\fN}{\fE}$,
                             pattern graph $\pG = \mPair{\pN}{\pE}$}%
  {%
    $M$ \Assign $\emptyset$\;
    \Call{FindMatchRec}{$\emptyset$}\;
    \Return{$M$}\;
    \DeclFunction{FindMatchRec}{set $s$ of mappings}%
    {%
      \If{$\mCard{s} = \mCard{\pN}$}{%
        $M$ \Assign $M \cup s$%
        \tcp*{match found}
      }
      \Else{%
        $C$ \Assign compute mapping candidates\;
        \ForEach{$\mPair{n}{m} \in C$}{%
          \If{$\mSynRuleCheck(s, n, m) \mAnd \mSemRuleCheck(s, n, m)$}{%
            \Call{FindMatchRec}{$s \cup \mPair{n}{m}$}\;
          }
        }
      }
    }
  }

  \caption{VF2 algorithm}
  \labelAlgorithm{vf2-algorithm}
\end{algorithm}
%
The algorithm, given in \refAlgorithm{vf2-algorithm}, recursively checks every
\gls{node}-mapping candidate and applies a set of rules for checking whether the
current mapping will yield a \gls{match}.
%
The rules are categorized into \emph{syntactic} and \emph{semantic} rules.
%
The syntactic rules check that the \gls{graph} structure is preserved, and the
semantic rules check that \gls{node} and \gls{edge} attributes are compatible.



\subsubsection{Computing Mapping Candidates}

Given a \gls{function graph}~\mbox{$\fG = \mPair{\fN}{\fE}$}, a \gls{pattern
  graph}~\mbox{$\pG = \mPair{\pN}{\pE}$}, and a set~$s$ of mappings from
\glspl{node} in $\fG$ to \glspl{node} in $\pG$, the set~$C$ of mapping
candidates under consideration for being added to $s$ is computed as follows.
%
Let $\fTout$ and $\pTout$ denote the set of \glspl{node} in $\fG$ and $\pG$,
respectively, that are targets of \glspl{edge} from \glspl{node} appearing
in~$s$.
%
Likewise, let $\fTin$ and $\pTin$ denote the set of \glspl{node} in $\fG$ and
$\pG$, respectively, that are sources of \glspl{edge} to \glspl{node} appearing
in~$s$.
%
Then
%
\begin{equation}
  \hspace*{-.8em}
  C = \left\{
  \begin{array}{ll}
      \mSetBuilder{\mPair{n}{m}}{n \in \fTout, m \in \pTout}
    & \text{if} \ \fTout \neq \emptyset \mAnd \pTout \neq \emptyset, \\
      \mSetBuilder{\mPair{n}{m}}{n \in \fTin, m \in \pTin}
    & \text{if} \ \fTin \neq \emptyset \mAnd \pTin \neq \emptyset, \\
      \mSetBuilder{\mPair{n}{m}}{
                                  n \in \fN \setminus \fN(s),
                                  m \in \pN \setminus \pN(s),
                                }
    & \text{otherwise},
  \end{array}
 \right.
\end{equation}
%
where $\fN(s)$ and $\pN(s)$ denote the sets of \glspl{node} in $\fG$ and $\pG$,
respectively, that appear in $s$.
%
The last clause is needed when $\fG$ or $\pG$ consist of disconnected
\glspl{graph}.



\subsubsection{Syntactic Rules}

\todo{write}



\subsubsection{Semantic Rules}

\todo{write}



\section{Pattern Matching Using Universal Representations}
\labelSection{pm-using-universal-reps}

\todo{write}

\todo{refine coverage definition}



\section{Handling Data Types}
\labelSection{pm-handling-data-types}

\todo{write}

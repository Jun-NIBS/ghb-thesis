% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Pattern Matching}
\labelChapter{pattern-matching}

\todo{write chapter summary}



\section{TODO: name intro section}

\todo{write}



\section{Proof That Separating Matching From Selection Preserves Optimality}

\todo{write}


\section{The VF2 Algorithm}
\labelSection{pm-vf2-algorithm}

Due to its simplicity and ease of implementation,
\gls{VF2}~\cite{CordellaEtAl:2001} was selected as the \gls{subgraph
  isomorphism} algorithm used in this work.\!%
%
\footnote{%
  In his dissertation, \textcite{McCreesh:2017} advices against using \gls{VF2}
  after showing that, for large body of problem instances, it exhibits
  considerably worse performance compared to two other \gls{subgraph
    isomorphism} algorithms (\gls{LAD}~\cite{Solnon:2010} and
  \gls{Glasgow}~\cite{McCreeshProsser:2015}).
  %
  In case of \gls{instruction selection}, however, the problem instances are
  small enough that the time for finding all \glspl{match} is negligible
  compared to the time for solving the \gls{constraint model}.
}
%
\def\fG{G_{\textrm{\textsc{f}}}}%
\def\pG{G_{\textrm{\textsc{p}}}}%
\def\fN{N_{\textrm{\textsc{f}}}}%
\def\fE{E_{\textrm{\textsc{f}}}}%
\def\pN{N_{\textrm{\textsc{p}}}}%
\def\pE{E_{\textrm{\textsc{p}}}}%
\def\mCandSet{P(s)}%
\def\mSynRuleCheck{F_{\textrm{\textsc{syn}}}}%
\def\mSemRuleCheck{F_{\textrm{\textsc{sem}}}}%
\def\fTout{T_{\!\textrm{\textsc{f}}}^{\hspace{.5pt}\textrm{\textsc{out}}}}%
\def\pTout{T_{\!\textrm{\textsc{p}}}^{\hspace{.5pt}\textrm{\textsc{out}}}}%
\def\fTin{T_{\!\textrm{\textsc{f}}}^{\textrm{\textsc{in}}}}%
\def\pTin{T_{\!\textrm{\textsc{p}}}^{\textrm{\textsc{in}}}}%
\begin{algorithm}[t]
  \DeclFunction{FindMatches}{function graph $\fG = \mPair{\fN}{\fE}$,
                             pattern graph $\pG = \mPair{\pN}{\pE}$}%
  {%
    $M$ \Assign $\emptyset$\;
    \Call{FindMatchRec}{$\emptyset$}\;
    \Return{$M$}\;
    \DeclFunction{FindMatchRec}{set $s$ of mappings}%
    {%
      \If(\tcp*[f]{if match found}){$\mCard{s} = \mCard{\pN}$}{%
        $M$ \Assign $M \cup s$\;
      }
      \Else{%
        compute mapping candidate set $\mCandSet$
        \tcp*{see \refDefinition{pm-cand-set}}
        \ForEach{$\mPair{n}{m} \in \mCandSet$}{%
          \If(\tcp*[f]{see \refDefinitionRange{pm-syntactic-rules}{}})%
             {$\mSynRuleCheck(s, n, m) \mAnd \mSemRuleCheck(s, n, m)$}%
          {%
            \Call{FindMatchRec}{$s \cup \mPair{n}{m}$}\;
          }
        }
      }
    }
  }

  \caption{VF2 algorithm}
  \labelAlgorithm{vf2-algorithm}
\end{algorithm}
%
The algorithm, given in \refAlgorithm{vf2-algorithm}, recursively checks every
\gls{node}-mapping candidate and applies a set of rules for checking whether the
current mapping will yield a \gls{match}.
%
The rules are categorized into \emph{syntactic} and \emph{semantic} rules.
%
The syntactic rules check that the \gls{graph} structure is preserved, and the
semantic rules check that \gls{node} and \gls{edge} attributes are compatible.



\subsubsection{Computing the Mapping Candidate Set}

Given a \gls{function graph}~\mbox{$\fG = \mPair{\fN}{\fE}$}, a \gls{pattern
  graph}~\mbox{$\pG = \mPair{\pN}{\pE}$}, and a set~$s$ of mappings from
\glspl{node} in $\fG$ to \glspl{node} in $\pG$, the set~$\mCandSet$ of mapping
candidates under consideration for being added to $s$ is computed as follows.
%
\begin{definition}[Mapping Candidate Set]
  Let $\fN(s)$ and $\pN(s)$ denote the sets of \glspl{node} in $\fG$ and $\pG$,
  respectively, that appear in $s$.
  %
  Also let $\fTout$ and $\pTout$ denote the set of \glspl{node} in $\fG$ and
  $\pG$, respectively, that are targets of \glspl{edge} from \glspl{node}
  appearing in~$s$.
  %
  Likewise, let $\fTin$ and $\pTin$ denote the set of \glspl{node} in $\fG$ and
  $\pG$, respectively, that are sources of \glspl{edge} to \glspl{node}
  appearing in~$s$.
  %
  Then
  %
  \begin{displaymath}
    \mCandSet = \left\{
    \begin{array}{ll}
        \mSetBuilder{\mPair{n}{m}}{n \in \fTout, m \in \pTout}
      & \text{if} \ \fTout \neq \emptyset \mAnd \pTout \neq \emptyset, \\
        \mSetBuilder{\mPair{n}{m}}{n \in \fTin, m \in \pTin}
      & \text{if} \ \fTin \neq \emptyset \mAnd \pTin \neq \emptyset, \\
        \mSetBuilder{\mPair{n}{m}}{
                                    n \in \fN \setminus \fN(s),
                                    m \in \pN \setminus \pN(s)
                                  }
      & \text{otherwise}.
    \end{array}
    \right.
  \end{displaymath}%
  \labelDefinition{pm-cand-set}%
\end{definition}
%
The last clause is needed when $\fG$ or $\pG$ consists of disconnected
\glspl{subgraph}.



\subsubsection{Syntactic Rules}

\def\mSynPredRule{R_{\textrm{\textsc{pred}}}}
\def\mSynSuccRule{R_{\textrm{\textsc{succ}}}}
\def\mSynInRule{R_{\textrm{\textsc{in}}}}
\def\mSynOutRule{R_{\textrm{\textsc{out}}}}
\def\mSynNewRule{R_{\textrm{\textsc{new}}}}

The syntactic rule check $\mSynRuleCheck$ consists of five rules:
%
\begin{displaymath}
  \mSynRuleCheck(s, n, m) =
  \mSynPredRule(\ldots) \mAnd \mSynSuccRule(\ldots) \mAnd
  \mSynInRule(\ldots) \mAnd \mSynOutRule(\ldots) \mAnd \mSynNewRule(\ldots).
\end{displaymath}
%
The first two rules, $\mSynPredRule$ and $\mSynSuccRule$, check the consistency
of the partial \gls{match} obtained when the candidate~\mbox{$\mPair{n}{m}$} is
added to~$s$.
%
Intuitively, if there exists an \gls{edge} between two mapped \glspl{node} in
the \gls{pattern graph}, then a corresponding \gls{edge} must also exist in the
\gls{function graph}.\!%
%
\footnote{%
  In the paper \cite{CordellaEtAl:2001}, $\mSynPredRule$ and $\mSynSuccRule$
  also check the inverse -- that is, an \gls{edge} between two mapped
  \glspl{node} in the \gls{function graph} must have a corresponding \gls{edge}
  in the \gls{pattern graph} -- thus requiring that $\pG$ is an induced
  \gls{subgraph} of $\fG$.
  %
  In this context, however, it is sufficient with only maintaining the structure
  of~$\pG$, and the condition above has therefore been removed from
  \refDefinition{pm-syntactic-rules}.
}
%
The next two rules, $\mSynInRule$ and $\mSynOutRule$, are 1-look-ahead rules
that check whether there exist a sufficient number of unmapped \glspl{node}
adjacent to $n$ in the \gls{function graph} for mapping the remaining
\glspl{node} adjacent to $m$ in the \gls{pattern graph}.
%
The last rule, $\mSynNewRule$, is similar to $\mSynInRule$ and $\mSynOutRule$
but perform a 2-look-ahead check.

Formally, the rules are defined as follows.
%
\begin{definition}[Syntactic rules]
  \def\fT{T_{\!\textrm{\textsc{f}}}}%
  \def\pT{T_{\!\textrm{\textsc{p}}}}%
  \def\fNegN{\mkern2mu\overline{\mkern-2mu N}_{\textrm{\textsc{f}}}}%
  \def\pNegN{\mkern2mu\overline{\mkern-2mu N}_{\textrm{\textsc{p}}}}%

  Let $\mPred(G, n)$ and $\mSucc(G, n)$ denote the sets of predecessor and
  successor \glspl{node}, respectively, to \gls{node}~$n$ in \gls{graph}~$G$.
  %
  Also let \mbox{$\fT = \fTin \cup \fTout$} and \mbox{$\fNegN = \fN \setminus
    \fN(s) \setminus \fT$}, with similar definitions for $\pT$ and $\pNegN$.
  %
  Then
  %
  \begin{displaymath}
    \begin{array}{r@{}l}
        \mSynPredRule(s, n, m) \equiv \mbox{}
      & \mPair{n'}{m'} \in s,
        \forall m' \in \pN(s) \cap \mPred(\pG, m),
         \exists n' \in \fN(s), \\[\abovedisplayskip]

        \mSynSuccRule(s, n, m) \equiv \mbox{}
      & \mPair{n'}{m'} \in s,
        \forall m' \in \pN(s) \cap \mSucc(\pG, m),
        \exists n' \in \fN(s), \\[\abovedisplayskip]

        \mSynInRule(s, n, m) \equiv \mbox{}
      & \mCard{\mSucc(\fN, n) \cap \fTin} \geq
        \mCard{\mSucc(\pN, n) \cap \pTin} \mAnd \mbox{} \\
      & \mCard{\mPred(\fN, n) \cap \fTin} \geq
        \mCard{\mPred(\pN, n) \cap \pTin}, \\[\abovedisplayskip]

        \mSynOutRule(s, n, m) \equiv \mbox{}
      & \mCard{\mSucc(\fN, n) \cap \fTout} \geq
        \mCard{\mSucc(\pN, n) \cap \pTout} \mAnd \mbox{} \\
      & \mCard{\mPred(\fN, n) \cap \fTout} \geq
        \mCard{\mPred(\pN, n) \cap \pTout}, \\[\abovedisplayskip]

        \mSynNewRule(s, n, m) \equiv \mbox{}
      & \mCard{\fNegN \cap \mPred(\fG, n)} \geq
        \mCard{\pNegN \cap \mPred(\pG, m)} \mAnd \mbox{} \\
      & \mCard{\fNegN \cap \mSucc(\fG, n)} \geq
        \mCard{\pNegN \cap \mSucc(\pG, m)}.
    \end{array}
  \end{displaymath}%
  \labelDefinition{pm-syntactic-rules}%
\end{definition}



\subsubsection{Semantic Rules}

\todo{write}



\section{Pattern Matching Using Universal Representations}
\labelSection{pm-using-universal-reps}

\todo{write}

\todo{refine coverage definition}



\section{Handling Data Types}
\labelSection{pm-handling-data-types}

\todo{write}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Universal Representations}
\labelChapter{universal-representations}

\todo{write overview}



\section{Design Requirements}

In order to design \gls{constraint model} introduced later in this dissertation,
we require a \gls{graph}-based representation that fulfills the following
requirements:
%
\begin{requirements}
  \item \labelRequirement{uni-rep-capture-data-control}
    It must be able to capture the data and control flow of an entire
    \gls{function}.
    %
    This is needed for modeling \gls{global.is} \gls{instruction selection}
    and for uniform selection of data and control \glspl{instruction}.
  \item \labelRequirement{uni-rep-explicit-ops}
    \Glspl{operation}, both for data and control flow, must be explicitly
    represented as \glspl{node}.
    %
    This is needed for \gls{pattern matching}.
  \item \labelRequirement{uni-rep-explicit-values}
    Values produced and used by the \glspl{operation} must also be explicitly
    represented as \glspl{node}.
    %
    This is needed for modeling \gls{global code motion} and \gls{data copying}.
  \item \labelRequirement{uni-rep-fixed-operations}
    The \gls{block} in which a particular \gls{operation} in the \gls{function}
    is to be performed must not be fixed.
    %
    This is needed for modeling \gls{global code motion}.
  \item \labelRequirement{uni-rep-ssa}
    The representation must be based on \gls{SSA}.
    %
    Not only is this practical as most \glspl{IR} used in modern
    \glspl{compiler} are already based on \gls{SSA}, it also helps in modeling
    \gls{global code motion}.
\end{requirements}

While there exists many \gls{graph}-based representations -- for a survey, see
\cite{StanierWatson:2013} -- most fulfill only some of the requirements but not
all.
%
Consequently, a new representation had to be designed.



\section{Program Representation}

The new representation, called \gls!{universal representation}, is essentially a
combination of two existing representations -- the \gls{SSA graph} and the
\gls{control-flow graph}%
%
\footnote{%
  A \gls!{control-flow graph} is a \gls{graph} where each \gls{node} represents
  a \gls{block} in the \gls{function} and each \gls{edge} represents a jump from
  one \gls{block} to another.
  %
  \Glspl{edge} representing conditional jumps are labeled with a Boolean
  value indicating under which conditions the jump is taken.
  %
  An example is given in \refFigure{uf-graph-example-original-cf-graph}.
}
%
-- which have been extended to fulfill the missing requirements and then merged
into a single \gls{graph}.
%
This makes for a simple construction process as the \glsshort{control-flow
  graph} and \gls{SSA graph} is already used inside most, if not all, modern
\glspl{compiler}.

\begin{figure}
  \centering

  \subcaptionbox{Function in SSA form\labelFigure{uf-graph-example-ssa-c}}%
                {\lstinputlisting[language=c,mathescape]{fact-ssa.c}}%

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Control-flow graph%
                  \labelFigure{uf-graph-example-original-cf-graph}%
                }%
                [32mm]%
                {\input{figures/universal-representations/control-flow-graph-example}}%
  \hfill%
  \subcaptionbox{SSA graph\labelFigure{uf-graph-example-original-ssa-graph}}%
                {\input{figures/universal-representations/ssa-graph-example}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \subcaptionbox{%
                  Extended control-flow graph%
                  \labelFigure{uf-graph-example-extended-cf-graph}%
                }%
                [46mm]%
                {\input{figures/universal-representations/uf-graph-example-control-part}}%
  \hfill%
  \subcaptionbox{%
                  Extended SSA graph%
                  \labelFigure{uf-graph-example-extended-ssa-graph}%
                }%
                {%
                  \input{figures/universal-representations/uf-graph-example-data-part}%
                  \vspace*{1cm}%
                }%

  \input{figures/universal-representations/uf-graph-example-cross-edges}

  \caption[TODO]%
          {%
            TODO%
          }
  \labelFigure{uf-graph-example}
\end{figure}

We start with the \gls{control-flow graph}.
%
As it captures the control flow for an entire \gls{function},
\refRequirement{uni-rep-capture-data-control} is already met (at least
partially).
%
To achieve \refRequirement{uni-rep-explicit-ops}, we insert \glspl{node}
representing the \glspl{operation} that change the control flow from on
\gls{block} to another and redirect the \glspl{edge} such that the control flow
originate from these \glspl{node}.
%
An example of the extended \gls{control-flow graph} is given in
\refFigure{uf-graph-example-extended-cf-graph}.
%
\Glspl{node} representing \glspl{block} and control-flow \glspl{operation} are
called \glspl!{block node} and \glspl!{control node}, respectively.
%
\todo{finish paragraph}

\todo{describe how \refRequirement{uni-rep-capture-data-control} is
  achieved}

\todo{describe how \refRequirement{uni-rep-explicit-ops} is achieved}

\todo{describe how \refRequirement{uni-rep-explicit-values} is achieved}

\todo{describe how \refRequirement{uni-rep-fixed-operations} is achieved}

\todo{describe how \refRequirement{uni-rep-ssa} is achieved}

\todo{give example}

\todo{discuss similarities with \gls{Click-Paleczny graph}}



\subsubsection{Proof of Semantic Preservation}

\todo{write?}



\section{Instruction Representation}

\todo{write}

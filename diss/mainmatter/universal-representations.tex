% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Universal Representations}
\labelChapter{universal-representations}

\todo{write overview}



\section{Design Requirements}

In order to design \gls{constraint model} introduced later in this dissertation,
we require a \gls{graph}-based representation that fulfills the following
requirements:
%
\begin{requirements}
  \item \labelRequirement{uni-rep-capture-data-control}
    It must be able to capture the data and control flow of an entire
    \gls{function}.
    %
    This is needed for modeling \gls{global.is} \gls{instruction selection}
    and for uniform selection of data and control \glspl{instruction}.
  \item \labelRequirement{uni-rep-explicit-blocks}
    \Glspl{block} must be explicitly represented as \glspl{node}.
    %
    This is needed for \gls{pattern matching} and for modeling \gls{global code
      motion}.
  \item \labelRequirement{uni-rep-explicit-ops}
    \Glspl{operation}, both for data and control flow, must be explicitly
    represented as \glspl{node}.
    %
    This is needed for \gls{pattern matching}.
  \item \labelRequirement{uni-rep-explicit-values}
    Values produced and used by the \glspl{operation} must also be explicitly
    represented as \glspl{node}.
    %
    This is needed for modeling \gls{global code motion} and \gls{data copying}.
  \item \labelRequirement{uni-rep-fixed-operations}
    The \gls{block} in which a particular \gls{operation} in the \gls{function}
    is to be performed must not be fixed.
    %
    This is needed for enabling \gls{global code motion}.
  \item \labelRequirement{uni-rep-preserve-semantics}
    \Gls{operation} are not allowed to be placed in \glspl{block} which will
    break \gls{program} semantics.
    %
    This is needed to ensure correctness when performing \gls{global code
      motion}.
  \item \labelRequirement{uni-rep-ssa}
    The representation must be based on \gls{SSA}.
    %
    Not only is this practical as most \glspl{IR} used in modern
    \glspl{compiler} are already based on \gls{SSA}, it also helps in modeling
    \gls{global code motion}.
\end{requirements}

While there exists many \gls{graph}-based representations -- for a survey, see
\cite{StanierWatson:2013} -- most fulfill only some of the requirements but not
all.
%
Consequently, a new representation had to be designed.



\section{Program Representation}

The new representation, called \gls!{universal representation}, is essentially a
combination of two existing representations -- the \gls{SSA graph} and the
\gls{control-flow graph}%
%
\footnote{%
  A \gls!{control-flow graph} is a \gls{graph} where each \gls{node} represents
  a \gls{block} in the \gls{function} and each \gls{edge} represents a jump from
  one \gls{block} to another.
  %
  \Glspl{edge} representing conditional jumps are labeled with a Boolean
  value indicating under which conditions the jump is taken.
  %
  An example is given in \refFigure{uf-graph-example-original-cf-graph}.
}
%
-- which have been extended to fulfill the missing requirements and then merged
into a single \gls{graph}.
%
This makes for a simple construction process as the \glsshort{control-flow
  graph} and \glspl{SSA graph} are already used inside most, if not all, modern
\glspl{compiler}.

\begin{figure}
  \centering

  \subcaptionbox{Function in SSA form\labelFigure{uf-graph-example-ssa-c}}%
                {\lstinputlisting[language=c,mathescape]{fact-ssa.c}}%

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Control-flow graph%
                  \labelFigure{uf-graph-example-original-cf-graph}%
                }%
                [32mm]%
                {%
                  \input{figures/universal-representations/%
                    control-flow-graph-example}%
                }%
  \hfill%
  \subcaptionbox{SSA graph\labelFigure{uf-graph-example-original-ssa-graph}}%
                {\input{figures/universal-representations/ssa-graph-example}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \subcaptionbox{%
                  Extended control-flow graph%
                  \labelFigure{uf-graph-example-extended-cf-graph}%
                }%
                [46mm]%
                {%
                  \input{figures/universal-representations/%
                    uf-graph-example-control-part}%
                }%
  \hfill%
  \subcaptionbox{%
                  Extended SSA graph%
                  \labelFigure{uf-graph-example-extended-ssa-graph}%
                }%
                {%
                  \input{%
                    figures/universal-representations/%
                    uf-graph-example-data-part%
                  }%
                  \vspace*{1cm}%
                }%

  \input{figures/universal-representations/uf-graph-example-cross-edges}

  \caption[TODO]%
          {%
            TODO%
          }
  \labelFigure{uf-graph-example}
\end{figure}

We start with the \gls{control-flow graph}.
%
As it captures the control flow for an entire \gls{function},
\refRequirement{uni-rep-capture-data-control} is already partially fulfilled.
%
\refRequirement{uni-rep-explicit-blocks} is also fulfilled since \glspl{block}
in the \gls{control-flow graph} are already represented as \glspl{node}, which
are called \glspl!{block node}.
%
To partially achieve \refRequirement{uni-rep-explicit-ops}, we insert
\glspl!{control node} to represent the \glspl{operation} that change the control
flow from on \gls{block} to another and redirect the \glspl{edge} such that
control flows through these \glspl{node}.
%
For example, in the \gls{graph} shown in
\refFigure{uf-graph-example-original-cf-graph}, \glspl{control node}
representing unconditional branches is inserted along the \glspl{edge} from
\irBlock{entry} to \irBlock{head} and from \irBlock{body} to \irBlock{head}.
%
For the conditional control flow originating from \irBlock{head}, a \gls{control
  node} representing a conditional branch is inserted and connected to
\irBlock{head}, and the labeled \glspl{edge} are redirected to the new
\gls{node}.
%
Lastly, a \gls{control node} representing \gls{function} return is inserted and
connected to \irBlock{end}.
%
This results in the \gls{control-flow graph} shown in
\refFigure{uf-graph-example-extended-cf-graph}.

We continue with the \gls{SSA graph}.
%
As it captures the data flow for an entire \gls{function} and represents
data-flow \glspl{operation} as \glspl{node}, the remaining parts of
\refRequirement{uni-rep-capture-data-control} and
\refRequirement{uni-rep-explicit-ops} are fulfilled.
%
\refRequirement{uni-rep-ssa} is inherently fulfilled as the \gls{SSA graph}
requires the \gls{function} to be in \gls{SSA}~form.
%
To achieve \refRequirement{uni-rep-explicit-values}, we insert \glspl{node}
representing values and redirect the \glspl{edge} in same fashion as when
extending the \gls{control-flow graph}.
%
\Glspl{node} representing \gls{function} return are removed as these are already
represented in the extended \gls{control-flow graph}.
%
Using the \gls{graph} shown in \refFigure{uf-graph-example-original-ssa-graph}
as example, this results in the \gls{SSA graph} shown in
\refFigure{uf-graph-example-extended-ssa-graph}.

We now connect the extended \glspl{graph} together.
%

\todo{discuss connecting the two extended graphs together}
%
\refRequirement{uni-rep-fixed-operations},
%
To achieve \refRequirement{uni-rep-preserve-semantics}
%
\todo{finish discussion}

\todo{discuss similarities with \gls{Click-Paleczny graph}}



\subsubsection{Proof of Semantic Preservation}

\todo{write?}



\section{Instruction Representation}

\todo{write}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Universal Representations}
\labelChapter{universal-representations}

This chapter introduces the representations used in the approach for modeling
\glspl{function} and \glspl{instruction}.
%
\RefSection{uni-rep-design-requirements} lists the design requirements that must
be fulfilled by the representation.
%
\RefSection{uni-rep-program-rep} introduces the representation and describes how
to use it to model \glspl{function}, and \refSection{uni-rep-instr-rep}
describes how to model \glspl{instruction}.



\section{Design Requirements}
\labelSection{uni-rep-design-requirements}

In order to construct the \gls{constraint model} introduced later in this
dissertation, we require a \gls{graph}-based representation that fulfills the
following requirements:
%
\begin{requirements}
  \item \labelRequirement{uni-rep-capture-data-control}
    It must be able to capture the data and control flow of an entire
    \gls{function}.
    %
    This is needed for modeling \gls{global.is} \gls{instruction selection}
    and for uniform selection of data and control \glspl{instruction}.
  \item \labelRequirement{uni-rep-explicit-blocks}
    \Glspl{block} must be explicitly represented as \glspl{node}.
    %
    This is needed for \gls{pattern matching} and for modeling \gls{global code
      motion}.
  \item \labelRequirement{uni-rep-explicit-ops}
    Data and control \glspl{operation} must be explicitly represented as
    \glspl{node}.
    %
    This is needed for \gls{pattern matching}.
  \item \labelRequirement{uni-rep-explicit-values}
    Values produced and used by the \glspl{operation} must also be explicitly
    represented as \glspl{node}.
    %
    Also, for \glspl{graph} modeling \glspl{function} every such \gls{node} must
    have exactly one inbound data-flow \gls{edge}.
    %
    This is needed for modeling \gls{global code motion} and \gls{data copying}.
  \item \labelRequirement{uni-rep-fixed-operations}
    The \gls{block} in which a particular \gls{operation} in the \gls{function}
    is to be performed must not be fixed.
    %
    This is needed for enabling \gls{global code motion}.
  \item \labelRequirement{uni-rep-preserve-semantics}
    Data \gls{operation} must be forbidden to be placed in \glspl{block} that
    will break \gls{program} semantics.
    %
    This is needed to ensure correctness when performing \gls{global code
      motion}.
  \item \labelRequirement{uni-rep-ssa}
    The representation must be based on \gls{SSA}.
    %
    Not only is this practical as most \glspl{IR} used in modern
    \glspl{compiler} are already based on \gls{SSA}, it also helps in modeling
    \gls{global code motion}.
\end{requirements}

While there exists many \gls{graph}-based representations -- for a survey, see
\cite{StanierWatson:2013} -- most fulfill only some of the requirements but not
all.
%
Consequently, a new representation had to be designed.



\section{Program Representation}
\labelSection{uni-rep-program-rep}

The new representation, called \gls!{universal representation}, is essentially a
combination of two existing representations -- the \gls{SSA graph} and the
\gls{control-flow graph}%
%
\footnote{%
  A \gls!{control-flow graph} is a \gls{graph} where each \gls{node} represents
  a \gls{block} in the \gls{function} and each \gls{edge} represents a jump from
  one \gls{block} to another.
  %
  \Glspl{edge} representing conditional jumps are labeled with a Boolean
  value indicating under which conditions the jump is taken.
  %
  An example is given in \refFigure{function-example-cf-graph}.
}
%
-- which have been extended to fulfill the missing requirements and then merged
into a single \gls{graph}.
%
This makes for a simple construction process as the \glsshort{control-flow
  graph} and \glspl{SSA graph} are already used inside most, if not all, modern
\glspl{compiler}.

We start with the \gls{control-flow graph}.
%
As it captures the control flow for an entire \gls{function},
\refRequirement{uni-rep-capture-data-control} is already partially fulfilled.
%
\refRequirement{uni-rep-explicit-blocks} is also fulfilled since \glspl{block}
in the \gls{control-flow graph} are already represented as \glspl{node}, which
are called \glspl!{block node}.
%
To partially achieve \refRequirement{uni-rep-explicit-ops}, we insert
\glspl!{control node} representing \glspl{operation} that change the control
flow from on \gls{block} to another and redirect the \glspl{edge} such that
control flows through these \glspl{node}.
%
For example, in the \gls{control-flow graph} shown in
\refFigure{function-example-cf-graph}, \glspl{control node} representing
unconditional branches are inserted along the \glspl{edge} between the
\irBlock{entry} and \irBlock{head} \glspl{node} and between the \irBlock{body}
and \irBlock{head} \glspl{node}.
%
\begin{filecontents*}{uf-example-ssa.c}
int factorial(int $\irVar{n}[1]$) {
  entry:
    int $\irVar{f}[1]$ = 1;
  head:
    int $\irVar{f}[2]$ = $\mPhi$($\irVar{f}[1]$:entry, $\irVar{f}[3]$:body);
    int $\irVar{n}[2]$ = $\mPhi$($\irVar{n}[1]$:entry, $\irVar{n}[3]$:body);
    bool b = $\irVar{n}[2]$ <= 1;
    if b goto end;
  body:
    int $\irVar{f}[3]$ = $\irVar{f}[2]$ * $\irVar{n}[2]$;
    int $\irVar{n}[3]$ = $\irVar{n}[2]$ - 1;
    goto head;
  end:
    return $\irVar{f}[2]$;
}
\end{filecontents*}
%
\begin{figure}
  \centering

  \begin{minipage}{55mm}
    \centering%
    \subcaptionbox{Function in SSA form\labelFigure{function-example-ssa-c}}%
                  {%
                    \lstinputlisting[language=c,mathescape,morekeywords={bool}]%
                                    {uf-example-ssa.c}%
                  }%
  \end{minipage}%
  \hfill%
  \begin{minipage}{67mm}
    \centering%
    \subcaptionbox{%
                    Control-flow graph%
                    \labelFigure{function-example-cf-graph}%
                  }%
                  [32mm]%
                  {%
                    \input{figures/universal-representations/%
                      control-flow-graph-example}%
                  }

    \vspace{\baselineskip}

    \subcaptionbox{SSA graph\labelFigure{function-example-ssa-graph}}%
                  {\input{figures/universal-representations/ssa-graph-example}}
  \end{minipage}

  \caption[Function example used in describing the program representation]%
          {%
            Running example of a function and its corresponding control-flow and
            SSA graph, which will be used in describing the program
            representation%
          }
  \labelFigure{function-example}
\end{figure}
%
\begin{figure}
  \centering

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Extended control-flow graph%
                  \labelFigure{uf-graph-example-extended-cf-graph}%
                }%
                [46mm]%
                {%
                  \input{figures/universal-representations/%
                    uf-graph-example-control-part}%
                }%
  \hfill%
  \subcaptionbox{%
                  Extended SSA graph%
                  \labelFigure{uf-graph-example-extended-ssa-graph}%
                }%
                {%
                  \input{%
                    figures/universal-representations/%
                    uf-graph-example-data-part%
                  }%
                }%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \subcaptionbox{%
                  Universal function graph%
                  \labelFigure{uf-graph-example-full-graph}%
                }%
                {%
                  \parbox{\textwidth}{%
                    \parbox[b]{32mm}{%
                      \input{figures/universal-representations/%
                        uf-graph-example-control-part}%
                    }%
                    \hfill%
                    \parbox[b]{63mm}{%
                      \input{%
                        figures/universal-representations/%
                        uf-graph-example-data-part%
                      }%
                      \vspace*{1cm}%
                    }%
                    \input{%
                      figures/universal-representations/%
                      uf-graph-example-cross-edges%
                    }%
                  }%
                }%

  \caption[%
            Example of a universal function graph, built from
            \refFigure{function-example}%
          ]%
          {%
            Example of a universal function graph, built from the \gls{function}
            shown in \refFigure{function-example}.
            %
            Thick-lined diamonds, boxes, and arrows represent control nodes,
            block nodes, and control-flow edges, respectively.
            %
            Thin-lined circles, boxes, and arrows represent computation nodes,
            value nodes, and data-flow edges, respectively.
            %
            Dotted lines represent definition edges%
          }
  \labelFigure{uf-graph-example}
\end{figure}
%
For the conditional control flow originating from the \irBlock{head}
\gls{block}, a \gls{control node} representing a conditional branch is inserted
and connected to the \irBlock{head} \gls{node}, and the labeled \glspl{edge} are
redirected to the new \gls{node}.
%
Lastly, a \gls{control node} representing \gls{function} return is inserted and
connected to the \irBlock{end} \gls{node}.
%
This results in the \gls{graph} shown in
\refFigure{uf-graph-example-extended-cf-graph}.
%
An invariant here is that each \gls{control node} has exactly one \gls{edge}
flowing \emph{from} a \gls{block node}, and each \gls{block node} has exactly
one \gls{edge} flowing \emph{to} a \gls{control node}.
%
In other words, every control \gls{operation} belongs to exactly one
\gls{block}, and every \gls{block} has exactly one point where changes in
control occur.

We continue with the \gls{SSA graph}.
%
As it captures the data flow for an entire \gls{function} and represents data
\glspl{operation} as \glspl{node} -- we call these \glspl!{computation node} --
the remaining parts of \refRequirement{uni-rep-capture-data-control} and
\refRequirement{uni-rep-explicit-ops} are fulfilled.
%
\refRequirement{uni-rep-ssa} is inherently fulfilled as the \gls{SSA graph}
requires the \gls{function} to be in \gls{SSA}~form.
%
To achieve \refRequirement{uni-rep-explicit-values}, we insert \glspl!{value
  node} representing the entities produced and used by the data
\glspl{operation} and redirect the \glspl{edge} in same fashion as when
extending the \gls{control-flow graph}.
%
\Glspl{node} representing \gls{function} return are removed as these are already
represented in the extended \gls{control-flow graph}.
%
Using the \gls{SSA graph} shown in \refFigure{function-example-ssa-graph} as
example, this results in the \gls{graph} shown in
\refFigure{uf-graph-example-extended-ssa-graph}.
%
Note that at this point, the invariant specified in
\refRequirement{uni-rep-explicit-values} that every \gls{value node} has exactly
one inbound data-flow \gls{edge} is broken, but this will be addressed shortly.

We now connect the two extended \glspl{graph} together.
%
First, data-flow \glspl{edge} are inserted to connect control \glspl{operation}
with the values used by these \glspl{operation}.
%
In the case of our running example, such \glspl{edge} are added from
values~\irVar{b} and~\irVar{f}[2] to the {\irFont\irCondBrText} and
{\irFont\irRetText} \glspl{operation}, respectively.
%
To achieve the invariant specified in \refRequirement{uni-rep-explicit-values},
data-flow \glspl{edge} are also inserted from the \glsshort{entry block}
\gls{block node} to each \gls{value node} representing constants and function
arguments.
%
Intuitively, this means that such values are produced at the point of entry to
the \gls{function}.

Since there are no \glspl{edge} connecting \glspl{computation node} with
\glspl{block node}, the assignment of data \glspl{operation} to \glspl{block} is
free, thus fulfilling \refRequirement{uni-rep-fixed-operations}.
%
This alone, however, permits \glspl{operation} to be moved to \glspl{block} that
will break \gls{program} semantics.
%
For example, assume the code snippet and corresponding, extended
\glsshort{control-flow graph} and \glspl{SSA graph} shown in
\refFigure{preserving-semantics-example}.
%
\begin{filecontents*}{preserving-semantics-code.c}
  $\ldots$
  int $\irVar{x}[1]$ = $\ldots$;
check:
  bool b = $\ldots$;
  if b goto dec;
inc:
  int $\irVar{x}[2]$ = $\irVar{x}[1]$ + 1;
  goto merge;
dec:
  int $\irVar{x}[3]$ = $\irVar{x}[1]$ - 1;
join:
  int $\irVar{x}[4]$ = $\mPhi$($\irVar{x}[2]$:inc, $\irVar{x}[3]$:dec);
\end{filecontents*}
%
\begin{figure}
  \centering

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Code snippet%
                  \labelFigure{preserving-semantics-example-code-snippet}%
                }{%
                  \lstinputlisting[language=c,mathescape]%
                                  {preserving-semantics-code.c}%
                }%
  \hfill\hfill\hfill%
  \subcaptionbox{%
                  UF subgraph%
                  \labelFigure{preserving-semantics-graph}%
                }{%
                  \input{figures/universal-representations/%
                    preserving-semantics-example-graph}%
                }%
  \hfill%
  \mbox{}

  \caption[Example illustrating the need for definition edges]%
          {%
            Example illustrating the need for definition edges to prevent
            certain operations from being moved into blocks that will break
            program semantics%
          }
  \labelFigure{preserving-semantics-example}
\end{figure}
%
In the original code, the addition should be performed in the \irBlock{inc}
\gls{block} while the subtraction should be performed in the \irBlock{dec}
\gls{block}.
%
But according to the \gls{graph}, swapping the placement of these
\glspl{operation} would be considered a valid move, which clearly results in a
different \gls{program}.
%
We recognize that such problems only occur in situations where a value is
expected to be produce in a particular \gls{block}, which are captured by the
\glspl{phi-function}.
%
Consequently, for each value-\gls{block} pair \mbox{$\mPair{v}{b}$} appearing as
argument to a \gls{phi-function}, we add a \gls!{definition edge} between the
corresponding \glsshort{value node} and \gls{block node}.
%
This forces $v$ to be produced in $b$, which in turn forbids the \gls{operation}
producing $v$ from being moved out of $b$.
%
Hence \refRequirement{uni-rep-preserve-semantics} is achieved.
%
Lastly, for convenience we prevent \glspl{phi-function} from being moved by
inserting a \gls{definition edge} between the value produced by the
\gls{phi-function} and the \gls{block} wherein the \gls{phi-function} resides in
the \gls{IR}.
%
This results in the \gls{graph} shown in
\refFigure{uf-graph-example-full-graph},\hspace{-1pt}%
%
\footnote{%
  In this case, the \glspl{definition edge} from the \irBlock{entry} \gls{node}
  to the \irVar{n}[1] and \irVar{1} \glspl{node} are redundant since the
  data-flow \glspl{edge} are sufficient to force these values to be produced in
  the \irBlock{entry} \gls{block}.
}
%
which is called \gls!{UF graph}.

The \gls{UF graph} is similar to the \gls{Click-Paleczny graph} (compare for
example \refFigure{uf-graph-example-full-graph} with
\refFigure{sea-of-nodes-example-click-paleczny-graph} on
\refPageOfFigure{sea-of-nodes-example-click-paleczny-graph}).
%
Both are combinations of \glsshort{control-flow graph} and \glspl{SSA graph},
they represent (some) of the control \glspl{operation} as \glspl{node}, and they
can restrict the placement of \glspl{operation} to \glspl{block} through
auxiliary edges.
%
However, the \gls{Click-Paleczny graph} does not completely fulfill
\refRequirement{uni-rep-explicit-ops} as unconditional branches are not
represented as \glspl{node}, nor does it fulfill
\refRequirement{uni-rep-explicit-values}.



\section{Instruction Representation}
\labelSection{uni-rep-instr-rep}

Modeling \glspl{instruction} as \glspl{pattern} is nearly identical to modeling
\glspl{function}.
%
The exceptions are that the \gls{control-flow graph} becomes empty if the output
is not dependent on control flow, and that no additional data-flow \glspl{edge}
are added for \glspl{value node} representing constants and \gls{instruction}
input.
%
In other words, the invariant specified in
\refRequirement{uni-rep-explicit-values} that every \gls{value node} has exactly
one inbound data-flow \gls{edge} does not need to (and should not) hold for such
values.
%
This results in a \gls{graph} called \gls!{UP graph}, and two examples are given
in \refFigure{up-graph-examples}.

\begin{filecontents*}{add-code.c}
int add(int $\irVar{s}$, int $\irVar{t}$) {
  entry:
    int $\irVar{d}$ = $\irVar{s}$ + $\irVar{t}$;
    return $\irVar{d}$;
}
\end{filecontents*}

\begin{filecontents*}{satadd-code.c}
int satadd(int $\irVar{s}$, int $\irVar{t}$) {
  entry:
    int $\irVar{d}[1]$ = $\irVar{s}$ + $\irVar{t}$;
    if ($\irVar{d}[1]$ > MAX) goto clamp;
  clamp:
    int $\irVar{d}[2]$ = MAX;
  end:
    int $\irVar{d}[3]$ = $\mPhi$($\irVar{d}[3]$:entry, $\irVar{d}[2]$:clamp);
    return $\irVar{d}[3]$;
}
\end{filecontents*}

\begin{figure}
  \centering%
  \setlength{\tmpLength}{2\baselineskip + \betweensubfigures}%
  \begin{tabular}{@{}c@{\quad}c@{}}
    \subcaptionbox{%
                    Semantic behavior of an \mbox{\instrFont add \$d, \$s, \$t}
                    instruction%
                    \labelFigure{up-graph-examples-add-code}%
                  }%
                  [40mm]%
                  {%
                    \lstinputlisting[language=c,mathescape,morekeywords={bool}]%
                                    {add-code.c}%
                  }%
    &
    \subcaptionbox{%
                    UP graph of {\instrFont add}%
                    \labelFigure{up-graph-examples-add-graph}%
                  }%
                  [28mm]%
                  {\input{figures/universal-representations/up-graph-add}}%
    \\[\tmpLength]
    \subcaptionbox{%
                    Semantic behavior of a
                    \mbox{\instrFont satadd \$d, \$s, \$t} instruction%
                    \labelFigure{up-graph-examples-satadd-code}%
                  }%
                  [64mm]%
                  {%
                    \lstinputlisting[language=c,mathescape,morekeywords={bool}]%
                                    {satadd-code.c}%
                  }%
    &
    \subcaptionbox{%
                    UP graph of {\instrFont satadd}%
                    \labelFigure{up-graph-examples-satadd}%
                  }{\input{figures/universal-representations/up-graph-satadd}}
  \end{tabular}

  \caption{Examples of universal pattern graphs}
  \labelFigure{up-graph-examples}
\end{figure}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Constraint Model}
\labelChapter{constraint-model}

This chapter introduces the \gls{constraint model} for \gls{universal
  instruction selection}.
%
\RefSectionRange{modeling-global-instruction-selection}{modeling-block-ordering}
introduce the \glspl{variable} and \gls{constraint} for modeling \gls{global.is}
\gls{instruction selection}, \gls{global code motion}, \gls{data copying},
\gls{value reuse}, and \gls{block ordering}, respectively.
%
\RefSection{cm-objective-function} introduces the \gls{objective function}
applied in the \gls{constraint model}.
%
\RefSection{cm-limitations} discusses the \glsshort{constraint model}
limitations.
%
Lastly, \refSection{model-summary} summarizes the chapter.


\section{Modeling Global Instruction Selection}
\labelSection{modeling-global-instruction-selection}

Modeling \gls{global.is} \gls{instruction selection} entails that all
\glspl{operation} must be \gls{cover}[ed] and all \glspl{datum} must be
\gls{define.d}[d].
%
This could, however, lead to situations resulting in cyclic data dependencies,
which must be forbidden.


\subsection{Covering Operations and Defining Data}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
There are two variants of this problem:
%
\begin{enumerate*}[label=(\arabic*)]
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerate*}
%
The former problem is more common as it is stricter, resulting in simpler models
with smaller \glspl{solution space}.
%
It also allows use of \glspl{constraint} that enable strong \gls{propagation},
which is essential for curbing solving time and increasing scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.
%
Due to the increased complexity of the relaxed version of the problem, we model
exact \gls{cover}[age] in this dissertation.

Similarly, every value and state must be produced by exactly one selected match.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \gls!{define.d}[s] $d$
if there exists an inbound \glsshort{state-flow edge} or \gls{data-flow edge} to
$d$ in the \gls{UP graph} from which $m$ was derived.
%
Similarly, $m$ \gls!{use.d}[s] $d$ if there exists an outbound
\glsshort{state-flow edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph}
of $m$.


\subsubsection{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match} found
for $\mUFGraph$, the set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0,
    1}$} models whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\neg\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt}}, where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} that can cover~$o$.
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[o]$} models which selected \gls{match} \gls{define.d}[s]
\gls{datum}~\mbox{$d \in \mDataSet$\hspace{-1.5pt}}, where $\mDataSet$ denotes
the set of \glspl{datum} in $\mUFGraph$, and \mbox{$\mMatchSet[d] \subseteq
  \mMatchSet$} denotes the set of \glspl{match} that can \gls{define.d}~$d$.


\subsubsection{Constraints}

If an \gls{operation}~$o$ is covered by a \gls{match}~$m$, then that entails
selection of $m$, and vice versa.
%
Hence the \gls{constraint} that every \gls{operation} must be covered is modeled
as
%
\begin{equation}
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m],
  \forall o \in \mOpSet \hspace{-1pt},
  \forall m \in \mMatchSet[o] \hspace{-1pt}.
  \labelEquation{operation-coverage}
\end{equation}

Likewise, if a \gls{datum}~$d$ is \gls{define.d}[d] by a \gls{match}~$m$, then
that entails selection of $m$, and vice versa.
%
Hence the \gls{constraint} that every \gls{datum} must be \gls{define.d}[d]
is modeled as
%
\begin{equation}
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m],
  \forall d \in \mDataSet \hspace{-1.5pt},
  \forall m \in \mMatchSet[d] \hspace{-1pt}.
  \labelEquation{data-definitions}
\end{equation}
%
We assume the \gls{pattern set} has been extended with a special \gls!{null-def
  pattern}, with \gls{graph} structure \mbox{$\mEdge{b}{d}$} where $b$ is a
\gls{entry block} and $d$ is a \gls{datum}, that defines $d$ at zero cost.
%
This \gls{pattern} is needed for defining \glspl{datum} representing
\gls{function} arguments and constants since these are not produced by any
\gls{operation}.


\subsection{Forbidding Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

In certain cases, selecting \glspl{match} of \glspl{instruction} producing
multiple results -- for example, many modern processors provide memory
\glspl{instruction} that automatically increment or decrement the address value
-- could lead to cyclic data dependencies~\cite{EbnerEtAl:2008}.
%
\begin{filecontents*}{cyclic-data-deps-example-ir.c}
$\ldots$
$\irAssign{\irVar{p}[2]}{\irAdd{\irVar{p}[1]}{\irVar{4}}}$
$\irStore{\irVar{q}[1]}{\irVar{p}[2]}$
$\irAssign{\irVar{q}[2]}{\irAdd{\irVar{q}[1]}{\irVar{4}}}$
$\irStore{\irVar{p}[1]}{\irVar{q}[2]}$
\end{filecontents*}%
%
\begin{figure}
  \subcaptionbox{IR\labelFigure{cyclic-data-deps-example-ir}}%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {cyclic-data-deps-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF graph, covered by two matches derived from an
                  auto-increment store instruction.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{cyclic-data-deps-example-uf-graph}%
                }%
                [62mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-uf-graph%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Dependency graph%
                  \labelFigure{cyclic-data-deps-example-dep-graph}%
                }%
                [32mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-dep-graph%
                  }%
                }

  \caption{Example illustrating cyclic data dependencies}%
  \labelFigure{cyclic-data-deps-example}%
\end{figure}
%
An example of such a situation is given in \refFigure{cyclic-data-deps-example}.
%
If both \glspl{match} are selected, then either value~\irVar{p}[2] or
value~\irVar{q}[2] will be \gls{use.d}[d] before it is available (depending on
the instruction order), thus resulting in incorrect code.
%
Consequently, such combinations must be identified and forbidden.

We detect such combinations -- which could involve more than two \glspl{match}
-- by first constructing a \gls!{dependency graph}, where each \gls{node}
represents a \gls{match} and each \gls{edge}~$\mEdge{n}{m}$ indicates
that \gls{match}~$m$ \gls{use.d}[s] \glspl{datum} produced by \gls{match}~$n$.
%
A \gls{cycle} in this \gls{graph} corresponds a combination of \glspl{match}
which will lead to a cyclic data dependency if all \glspl{match} are selected.
%
Hence, we find all \glspl{cycle} in the \gls{dependency graph} -- we applied
\citeauthor{Johnson:1975}'s algorithm for this task~\cite{Johnson:1975} -- and
add \glspl{constraint} forbidding selection of all \glspl{match} appearing in a
\gls{cycle}.


\subsubsection{Constraints}

Given a set~\mbox{$\mForbiddenCombSet \subseteq \mPowerset{\mMatchSet}$} of
\glspl{cycle} found for the \gls{dependency graph} built from a \gls{UF graph}
and \gls{match set}, the \gls{constraint} forbidding cyclic data dependencies is
modeled as
%
\begin{equation}
  \sum_{m \in f} \mVar{sel}[m] < \mCard{f},
  \forall f \in \mForbiddenCombSet.
  \labelEquation{cyclic-data-deps}
\end{equation}


\section{Modeling Global Code Motion}
\labelSection{modeling-global-code-motion}

The \gls{global code motion} problem entails that \glspl{datum} must be placed
in \glspl{block} such that each definition of a \gls{datum}~$d$ precedes all
\gls{use.d}[s] of~$d$.
%
This condition can be expressed in terms of \gls{block} dominance.
%
Given a \gls{function}~$f$, a \gls{block}~$b$ in $f$ \gls!{dominate.b}[s]
another \gls{block}~$c$ in $f$ if $b$ appears on every control-flow path from
$f$'s \gls{entry block} to $c$ (see \refFigure{block-dominance-example} for an
example).
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{block-dominance-example-cfg}}%
                [34mm]%
                {%
                  \input{%
                    figures/constraint-model/block-dominance-example%
                  }%
                }%
  \hfill%
  \subcaptionbox{Dominance\labelFigure{block-dominance-example-doms}}%
                {%
                  \figureFont\figureFontSize%
                  \begin{tabular}{cc}
                    \toprule
                      \tabhead block
                    & \tabhead dominates\\
                    \midrule
                      \irBlock{entry}
                    & $\mSet{\irBlock{entry}, \irBlock{A}, \irBlock{B},
                        \irBlock{C}, \irBlock{D}, \irBlock{E}}$\\
                      \irBlock{A}
                    & $\mSet{\irBlock{A}, \irBlock{B}, \irBlock{C},
                        \irBlock{D}}$\\
                      \irBlock{B}
                    & $\mSet{\irBlock{B}}$\\
                      \irBlock{C}
                    & $\mSet{\irBlock{C}}$\\
                      \irBlock{D}
                    & $\mSet{\irBlock{D}}$\\
                      \irBlock{E}
                    & $\mSet{\irBlock{E}}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \mbox{}

  \caption{Example of block dominance}
  \labelFigure{block-dominance-example}
\end{figure}%
%
By definition, a \gls{block} always \gls{dominate.b}[s] itself.
%
Hence a placement of \glspl{match} into \glspl{block} is a \gls{solution} to the
\gls{global code motion} problem if each \gls{datum}~$d$ is \gls{define.d}[d] by
some selected \gls{match} placed in a \gls{block}~$b$, and every
non-\gls{phi-match} \glsshort{use.d}[ing] $d$ is placed in a \gls{block}
\gls{dominate.b}[d] by~$b$.
%
The \glspl{phi-match} must be excluded since, due to the \glspl{definition
  edge}, at least one \gls{datum} used by such \glspl{match} must be
\gls{define.d}[d] in a \gls{block} that does not \gls{dominate.b} the
\gls{block} wherein the \gls{phi-match} must be placed.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{oplace}[o] \in \mBlockSet$} models in
which \gls{block} \gls{operation}~$o$ is placed, where $\mBlockSet$ denotes the
set of \glspl{block} in $\mUFGraph$.
%
Likewise, the set of \glspl{variable} \mbox{$\mVar{dplace}[d] \in \mBlockSet$}
models in which \gls{block} the definition of \gls{datum}~$d$ is placed.


\subsubsection{Constraints}

Intuitively, all \glspl{operation} covered by a \gls{match}~$m$ must be placed
in the same \gls{block} wherein $m$ itself is placed.
%
Hence, if \mbox{$\mCovers(m) \subseteq \mOpSet$} denotes the set of
\glspl{operation} covered by \gls{match}~$m$, then this \gls{constraint} is
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o_1] = \mVar{oplace}[o_2], \\
    \forall m \in \mMatchSet,
    \forall o_1\hspace{-1pt}, o_2 \in \mCovers(m).
  \end{array}
  \labelEquation{operation-placement}
\end{equation}
%
This also enables the placement of $m$ to be deduced from any of the
corresponding $\mVar{oplace}$~\glspl{variable}.

We prevent control-flow \glspl{operation} from being moved to another
\gls{block}, which in all likelihood would break \gls{program} semantics, by
forcing selected \glspl{match} with control flow to be placed in the \gls{block}
matched by the \gls{UP graph}'s \gls{entry block}.
%
Hence, if \mbox{$\mEntry(m) \subseteq \mBlockSet$} returns either the empty set
or a set containing only the \gls{entry block} of match~$m$ (when the \gls{UP
  graph} of $m$ has such a node), then this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o] = b\hspace{-1.2pt}, \\
    \forall m \in \mMatchSet,
    \forall o \in \mCovers(m),
    \forall b \in \mEntry(m).
  \end{array}
  \labelEquation{preventing-control-flow-op-moves}
\end{equation}

As stated previously, each \gls{datum}~$d$ must be \gls{define.d}[d] in some
\gls{block}~\mbox{$b \in \mBlockSet$} such that $b$ \gls{dominate.b}[s] every
\gls{block} wherein $d$ is \gls{use.d}[d], excluding \gls{use.d}[s] made by the
\glspl{phi-match}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} denote the set of \glspl{datum}
\gls{define.d}[d] respectively \gls{use.d}[d] by \gls{match}~$m$.
%
Let also \mbox{$\mDom(b) \subseteq \mBlockSet$} denote the set of \glspl{block}
\gls{dominate.b}[d] by \gls{block}~$b$.
%
With these definitions, the \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in \mDom(\mVar{oplace}[o]), \\
    \forall m \in \mPhiMatchCompSet,
    \forall d \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{dom}
\end{equation}
%
where $\mPhiMatchCompSet$ denotes the set~$\mMatchSet$ without the
\glspl{phi-match}.

The restrictions imposed by the \glspl{definition edge} are modeled as
%
\begin{equation}
  \mVar{dplace}[d] = b,
  \forall \mEdge{d}{b} \in \mDefEdgeSet,
  \labelEquation{def-edges}
\end{equation}
%
where $\mDefEdgeSet$ denotes the set of \glspl{definition edge} in $\mUFGraph$.
%
It is assumed that the \glspl{edge} in $\mDefEdgeSet$ have been reoriented such
that all \glspl{source} are either \glsshort{state node} or \glspl{value node}
and all \glspl{target} are \glspl{block node}.

So far, there is no connection between the $\mVar{oplace}$ and $\mVar{dplace}$
\glspl{variable}.
%
Intuitively, every \gls{datum} \gls{define.d}[d] by a \gls{match}~$m$ should be
placed in the same \gls{block} as $m$ together with all \glspl{operation}
covered by~$m$.
%
This alone, however, could result in an over-constrained \glsshort{constraint
  model} that prevents selection of certain \glspl{match}.
%
For example, assume a \gls{match}~$m$ of the \gls{UP graph} shown in
\refFigure{up-graph-examples-add-graph} on
\refPageOfFigure{up-graph-examples-add-graph}, where the \glspl{block node}
\irBlock{entry}, \irBlock{clamp}, and \irBlock{end} are matched to \glspl{block}
in $\mUFGraph$ labeled \irBlock{A}, \irBlock{B}, and \irBlock{C}, respectively.
%
Because of \refEquation{preventing-control-flow-op-moves}, $m$ must be placed in
the \irBlock{A}~\gls{block}.
%
But because of \refEquation{def-edges}, one of its \glspl{value node} must be
placed in the \irBlock{B}~\gls{block}.
%
Consequently, for such conditions the \gls{constraint} is relaxed as follows.
%
We say that a \gls{match} \gls!{span.b}[s] the \glspl{block} matched by the
\gls{UP graph}'s \glspl{block node} (hence $m$ \gls{span.b}[s] \glspl{block}
\irBlock{A}, \irBlock{B}, and~\irBlock{C}).
%
We also say that a \gls{match} \gls!{consume.b}[s] any matched \glspl{block}
where the corresponding \gls{block node} has both \gls{inbound.e} and
\gls{outbound.e} control-flow \glspl{edge} in the \gls{UP graph} (hence $m$
\gls{consume.b}[s] \gls{block}~\irBlock{B}).
%
Consequently, every \gls{datum}~$d$ \gls{define.d}[d] by a \gls{match}~$m$ must
be placed in the same \gls{block} as $m$ only if $m$ \gls{span.b}[s] no
\glspl{block}, otherwise $d$ may be \gls{define.d}[d] in any of the
\glspl{block} \gls{span.b}[ned] by~$m$.
%
If \mbox{$\mSpans(m) \subseteq B$} denotes the set of \glspl{block}
\gls{span.b}[ned] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d] \in \mSet{\mVar{oplace}[o]} \cup \mSpans(m), \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m),
    \forall o \in \mCovers(m).
  \end{array}
  \labelEquation{spanning}
\end{equation}

\Glsshort{consume.b}[ing] a \gls{block} entails that the corresponding
\gls{instruction} assumes full control of the control flow to and from that
\gls{block}, which in turn means no \glspl{operation} covered by other
\glspl{match} may be placed in that \gls{block}.
%
Hence, if \mbox{$\mConsumes(m) \subseteq B$} denotes the set of \glspl{block}
\gls{consume.b}[d] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{oplace}[o] \neq b\hspace{-1.2pt}, \\
    \forall m \in \mMatchSet,
    \forall o \in \mOpSet \setminus \mCovers(m),
    \forall b \in \mConsumes(m).
  \end{array}
  \labelEquation{consumption}
\end{equation}


\section{Modeling Data Copying}
\labelSection{modeling-data-copying}

The cost of \gls{data copying} is taken into account by keeping track of the
location requirements for the data used and produced by the selected
\glspl{match}.
%
The idea is as follows.
%
For each value~$v$ in the \gls{UF graph}, let a \gls{variable}~$\mVar{x}$ decide
in which location provided by the \gls{target machine} $v$ is stored.
%
A \gls{match}~$m$ that either \gls{use.d}[s] or \gls{define.d}[s] $v$ and
requires $v$ to be in one of a set~$L$ of locations can then enforce, if
selected, that \mbox{$\mVar{x} \in L$}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{loc}[d] \in \mLocationSet \cup
  \mSet{\mNullLocation}$} models in which location \gls{datum}~$d$ is available,
where $\mLocationSet$ denotes the set of locations provided by the \gls{target
  machine} and $\mNullLocation$ denotes a special location for values that
cannot be reused across \glspl{instruction}.
%
In this context a location is an abstract representation, typically representing
a \gls{register}, but it could also indicate that the value is for example
stored in memory.
%
The special location is used for intermediate values produced internally by an
\gls{instruction} which can only be accessed by this very \gls{instruction}.
%
For example, the address computed by a memory load \gls{instruction} with a
sophisticated addressing mode is produced within the pipeline and thus cannot be
reused by other \glspl{instruction}.


\subsubsection{Constraints}

Every \gls{datum} must be made available in a location that is compatible for
all selected \glspl{match}.
%
If \mbox{$\mStores(m, d) \subseteq \mLocationSet \cup \mSet{\mNullLocation}$}
denotes the set of compatible locations (including the special location for
intermediate values) for a \gls{datum}~$d$ which is either \gls{define.d}[d] or
\gls{use.d}[d] by a \gls{match}~$m$, then this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[d] \in \mStores(m, d), \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{compatible-locations}
\end{equation}


\subsection{Copy Extension}

Depending on the \gls{target machine}, \refEquation{compatible-locations} can
result in an over-constrained \glsshort{constraint model}.
%
For example, in many \glspl{target machine} the \gls{SIMD.instr}
\glspl{instruction} use a different set of \glspl{register} than the other,
general \glspl{instruction}.
%
In such situations, the \glspl{match} derived from the \gls{SIMD.instr}
\glspl{instruction} and the \glspl{match} derived from the general
\glspl{instruction} will have non-overlapping locations on the same
\glspl{datum} (that is, \mbox{$\mStores(m_1, d) \cap \mStores(m_2, d) =
  \mEmptySet$}), preventing selection of such \glspl{match}.

Since non-overlapping locations entails the need for copy \glspl{instruction},
we extend the \gls{UF graph} with \glspl!{copy node} through a process called
\gls!{copy extension}.
%
For each \gls{data-flow edge}~$\mEdge{v}{o}$, where $v$ is a \gls{value node}
and $o$ is an \gls{operation}, we remove this \gls{edge} and insert a new
\gls{copy node}~$c$, \gls{value node}~$v'$, and \glspl{data-flow edge} such that
\mbox{$\mEdge{v}{\mEdge{c}{\mEdge{v'}{o}}}$}.
%
If $o$ is a \gls{phi-node} then the corresponding \gls{definition edge}
connected to $v$ -- this is the \gls{edge} with the same \gls{outbound.en}
\gls{edge number} as the \gls{data-flow edge} -- is also moved to $v'$.
%
This is to ensure that the placement restrictions are applied only on the
\glspl{datum} actually used by the \glspl{phi-function} (that is, the copied
value and not the original value).
%
We also extend the \gls{pattern set} with a special \gls!{null-copy pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, that covers $c$ at
zero cost provided that \mbox{$\mVar{loc}[v] = \mVar{loc}[v']$}.
%
Obviously, \glspl{match} derived from the \gls{null-copy pattern} -- we call
these \glspl!{null-copy match} -- emit nothing if selected.
%
If the \gls{null-copy match} cannot be selected for covering a particular
\gls{copy node}, then this means an appropriate copy \gls{instruction} must be
emitted whose cost will be accounted for.
%
\Glspl{match} covering exactly a \gls{copy node} are called \glspl!{copy match}.

In order to retain matching of \glspl{pattern}, we also need to perform
\gls{copy extension} on every \gls{UP graph} in the \gls{pattern set}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original UP graph%
                  \labelFigure{copy-extending-pattern-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After copy extension%
                  \labelFigure{copy-extending-pattern-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of copy-extending a pattern}
  \labelFigure{copy-extending-pattern-example}
\end{figure}
%
See for example \refFigure{copy-extending-pattern-example}.
%
The \gls{UP graph} captures the behavior of an \gls{instruction} that adds two
values~\irVar{r} and~\irVar{s} and then shifts the result by one bit to the
right (\refFigure{copy-extending-pattern-example-before}).
%
Since we want to preserve the ability of selecting copy \glspl{instruction} for
moving \glspl{datum} between \glspl{instruction}, we only copy-extend the
\glspl!{internal value} in a \gls{UP graph}, which are values that are both
\gls{define.d}[d] and \gls{use.d}[d] by the \gls{pattern}.
%
We also copy-extend any constant values since these obviously do not require a
separate copy \gls{instruction} to be used by the \gls{pattern}.
%
The resulting \gls{UP graph} will now yield the same \glspl{match} as before
\gls{copy extension} (\refFigure{copy-extending-pattern-example-after}).


\subsection{Handling Calling Conventions}

The method for handling \gls{data copying} can also be used for handling calling
conventions of the specific \gls{target machine}.
%
\Glspl{constraint} that callee arguments (that is, arguments to the
\gls{function} under compilation) must reside in a specific location are modeled
as
%
\begin{equation}
  \mVar{loc}[d] \in \mArgLoc(d),
  \forall d \in \mArgSet,
  \labelEquation{function-args}
\end{equation}
%
where \mbox{$\mArgSet \subseteq \mDataSet$} denotes the set of \gls{function}
arguments in $\mUFGraph$ and \mbox{$\mArgLoc(d) \subseteq \mLocationSet$}
denotes the set of locations in which argument~$d$ resides.
%
Arguments residing on the stack can be signified using a special $\mMemLocation$
location, thus requiring a memory load \gls{instruction} in order to be used by
other \glspl{instruction}.

Locations for caller arguments (that is, arguments to \glspl{function} calls
made from within the \gls{function} under compilation) can be enforced either
through \refEquation{function-args} or through
\refEquation{compatible-locations}.
%
If the calling convention depends on the \gls{instruction} selected then the
former is needed, otherwise the latter is more suitable as the restrictions can
be enforced before a \gls{match} is selected.\!%
%
\footnote{%
  If exactly one \gls{match}~$m$ can cover a given \gls{function} call
  \gls{node}, then both \glspl{constraint} provide the same amount of
  \gls{propagation} as \mbox{$\mVar{sel}[m] = 1$} will always hold for the
  implication in \refEquation{compatible-locations}.
}


\section{Modeling Value Reuse}
\labelSection{modeling-value-reuse}

Code quality can be increased if \glspl{instruction} are allowed to reuse copies
of values, which is a crucial feature to be expected in the code emitted by any
modern \gls{instruction selector}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  A UF graph with two matches%
                  \labelFigure{value-reuse-example-uf-graph}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-uf-graph}}%
  \hfill%
  \subcaptionbox{%
                  UF graph after copy extension%
                  \labelFigure{value-reuse-example-after-ce}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-after-ce}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Redundant copying of values%
                  \labelFigure{value-reuse-example-redundant-copies}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    value-reuse-example-redundant-copies%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Reuse of copied value%
                  \labelFigure{value-reuse-example-one-copy}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/value-reuse-example-one-copy%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of value reuse}
  \labelFigure{value-reuse-example}
\end{figure}
%
See for example \refFigure{value-reuse-example}.
%
Originally, the \gls{UF graph} has a value~\irVar{v} which is used by two
\glspl{operation} coverable by \glspl{match}~$m_1$ and~$m_2$
(\refFigure{value-reuse-example-uf-graph}).
%
After \gls{copy extension}, $m_1$ and $m_2$ use their own private copy --
\irVar{v}[1] and \irVar{v}[2], respectively -- of \irVar{v}
(\refFigure{value-reuse-example-after-ce}).
%
We say \irVar{v}[1] and \irVar{v}[2] are \gls!{copy-related.d}.
%
Consequently, if both $m_1$ and $m_2$ require \irVar{v} to be copied -- assume
for example that \irVar{v} resides on the stack -- then two copy
\glspl{instruction} will be emitted
(\refFigure{value-reuse-example-redundant-copies}).
%
However, if \irVar{v}[1] and \irVar{v}[2] could reside in the same location then
either of the values could be reused by either \gls{match}, thus necessitating
only one copy \gls{instruction} (\refFigure{value-reuse-example-one-copy}).
%
We call this notion \gls!{value reuse}.

In this dissertation, we discuss two methods for reusing values: \gls{match
  duplication} and \glspl{alternative value}.
%
We first introduce each in turn and then present experiments showing that one is
superior to the other.


\subsection{Match Duplication}

The idea is easily derived from its name: for each \gls{match}~$m$, create a new
\gls{match} for each permutation of \glspl{datum} that are \gls{copy-related.d}
to the \glspl{input datum} in $m$, where an \gls!{input datum} is a \gls{datum}
\gls{use.d}[d] but not \gls{define.d}[d] by~$m$.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{match-duplication-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After match duplication%
                  \labelFigure{match-duplication-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of match duplication}
  \labelFigure{match-duplication-example}
\end{figure}
%
See for example \refFigure{match-duplication-example}.
%
The \gls{match set} contains a \gls{match}~$m$ that uses value~\irVar{v}[1],
which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{match-duplication-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we duplicate $m$ to instead
use \irVar{v}[2], resulting in match~$m'$
(\refFigure{match-duplication-example-after}).

The main advantage of \gls{match duplication} is that no changes need to be done
for the \gls{constraint model}; the decision of which value to use (and reuse)
depends entirely on the selection of \glspl{match}.
%
However, this comes at a cost of inflating the \gls{match set}, which in turn
inflates the \gls{search space}.
%
If a \gls{match} has $k$~\glspl{input datum}, each with $n$~\gls{copy-related.d}
values, then $\mBigO(n^k)$ new \glspl{match} will be created.
%
Although the decision of \gls{value reuse} is intuitively orthogonal to the
decisions of selecting a \gls{match} and placing it into a \glspl{block}, these
decisions must be remade for each new \gls{match}, thereby enlarging the
\gls{search space} with many symmetric \glspl{solution}.


\subsection{Alternative Values}

The idea is as follows.
%
For each \gls{match}~$m$, let every \glspl{input datum}~$d$ in $m$ be mapped to
any \gls{datum} that is \gls{copy-related.d} to~$d$.
%
In other words, unlike before when a \gls{match} was \mbox{1-to-1} mapping
between \glspl{node} in the \gls{UP graph} and \glspl{node} in the \gls{UF
  graph}, we now allow certain mappings to be a \mbox{1-to-$n$} mapping.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{alt-values-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-without%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  With alternative values%
                  \labelFigure{alt-values-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-with%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of alternative values}
  \labelFigure{alt-values-example}
\end{figure}
%
See for example \refFigure{alt-values-example-before}.
%
Again, the \gls{match set} contains a \gls{match}~$m$ that uses
value~\irVar{v}[1], which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{alt-values-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we extend the mapping from
$n$ to \irVar{v}[1] to include \irVar{v}[2], where $n$ is the corresponding
\gls{value node} in the \gls{UP graph} of~$m$
(\refFigure{alt-values-example-after}).
%
In this context, \irVar{v}[1] and \irVar{v}[2] are said to be
\glspl!{alternative value} to~$m$.
%
For convenience, we assume that the set of \glspl{alternative value} for each
non-\gls{input datum}~$d$ in a \gls{match} contains only the \glsshort{state
  node} or \gls{value node} to which $d$ is already mapped.

After having extended the \gls{match set} with \glspl{alternative value}, the
next step is to extend the \gls{constraint model} with an another level of
indirection wherever a \gls{constraint} refers to a \gls{datum}.


\subsubsection{Variables}

Assume first that each \glsshort{define.d}[ition] or \glsshort{use.d}[age] of
\glspl{datum} within each \gls{match} incurs a unique \gls!{operand}.
%
Consequently, instead of \glsshort{define.d}[ing] and \glsshort{use.d}[ing]
\glspl{datum}, we now assume that all \glspl{match} \gls{define.d} and
\gls{use.d} \glspl{operand}.
%
Hence the set of \glspl{variable} \mbox{$\mVar{alt}[p] \in \mDataSet[p]$} models
to which \gls{datum} \gls{operand}~\mbox{$p \in \mOperandSet$} is mapped, where
\mbox{$\mDataSet[p] \subseteq \mDataSet$} denotes the set of alternative values
for~$p$, and $\mOperandSet$ denotes the set of \glspl{operand} incurred
by~$\mMatchSet$.

For reasons that will become apparent shortly, we also introduce a set of
\glspl{variable} \mbox{$\mVar{inactive}[d] \in \mSet{0, 1}$}, which models
whether a \gls{datum}~$d$ is \gls{inactive.d}.


\subsubsection{Constraints}

As stated previously, the aim is to add another level of indirection whenever a
\gls{constraint} refers to a \gls{datum}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} now denote the set of \glspl{operand}
(instead of \glspl{datum}) \gls{define.d}[d] respectively \gls{use.d}[d] by
\gls{match}~$m$.
%
With these new definitions, Eqs.\thinspace\refEquation*{dom},
\refEquation*{spanning}, and~\refEquation*{compatible-locations} are adjusted
accordingly (the changes are highlighted in grey):
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mDom(\mVar{oplace}[o]), \\
    \forall m \in \mPhiMatchCompSet,
    \forall \hlDiff{p} \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{dom-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in
      \mSet{\mVar{oplace}[o]} \cup \mSpans(m), \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{spanning-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mStores(m, \hlDiff{p}), \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{compatible-locations-alt}
\end{equation}

Due to these changes there may be \glspl{datum} that is not \gls{use.d}[d] by
any \gls{match}, yet \refEquation{data-definitions} still requires that every
\gls{datum} must be \gls{define.d}[d] by some \gls{match}.
%
We address this by extending the \gls{pattern set} with a \gls!{kill pattern}
(shaped like \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, where $v$ and $v'$ are
\glspl{value node} and $c$ is a \gls{copy node}).
%
\Glspl{match} derived from this \gls{pattern} are called \glspl!{kill match},
which have zero cost and emit nothing if selected.
%
A \gls{datum} is said to be \gls!{inactive.d} if and only if it is
\gls{define.d}[d] by a \gls{kill match}, and non-\glspl{kill match} are
forbidden to use \gls{inactive.d} \glspl{datum}.
%
Likewise, a \gls{datum} cannot be \gls{inactive.d} if it is used by a
non-\gls{kill match}.
%
These \glspl{constraint} are modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mEq
    \mVar{inactive}[\mVar{alt}[p]], \\
    \forall m \in \mKillMatchSet,
    \forall p \in \mDefines(m)
  \end{array}
  \labelEquation{inactivity-when-killed}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \neg \mVar{inactive}[\mVar{alt}[p]], \\
    \forall m \in \mKillMatchCompSet,
    \forall p \in \mUses(m)
  \end{array}
  \labelEquation{inactivity-when-used}
\end{equation}
%
where $\mKillMatchSet$ and $\mKillMatchCompSet$ denote the set of \glspl{kill
  match} respectively the set~$\mMatchSet$ without the \glspl{kill match}.


\subsection{Experimental Evaluation}

\todo{insert data}

\todo{discuss data}


\section{Modeling Block Ordering}
\labelSection{modeling-block-ordering}

Ordering the \glspl{block} in a \gls{function} entails finding a sequence~$s$
such that each \gls{block} appears exactly once in~$s$\hspace{-.8pt}.
%
Depending on the control-flow \glspl{instruction} selected, some \glspl{block}
may need to be adjacent.
%
For example, assume a \gls{block}~$b$ that branches to either of two
\glspl{block}~$c$ and~$d$ depending on whether a condition holds.
%
Assume also that the conditional branching in $b$ is implemented using an
\gls{instruction} that branches to $c$ if the condition holds, otherwise it
continues the execution with the next \gls{instruction} in the \gls{assembly
  code}.
%
This notion of execution is called \gls!{fall-through}, and due to this, $d$
must be placed immediately after $b$ in the sequence.

For some combinations of \glspl{function} and \glspl{target machine} with
\gls{fall-through} \glspl{instruction}, there exist no valid \gls{block}
sequence without inserting one or more additional jump \glspl{instruction}.
%
\begin{figure}
  \setlength{\opNodeDist}{20pt}%
  \tikzset{
    block node/.append style={
      minimum width=2cm,
      minimum height=.9\opNodeSize,
    },
  }%

  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{jump-insert-example-cfg}}%
                [34mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-cfg}%
                }%
  \hfill%
  \subcaptionbox{%
                  Valid block sequences, after jump insertion%
                  \labelFigure{jump-insert-example-solutions}%
                }%
                [65mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-sol1}%
                  \hspace{6mm}%
                  \input{figures/constraint-model/jump-insert-example-sol2}%
                }%
  \hfill%
  \mbox{}

  \caption[Example that requires additional jump instructions]%
          {%
            Example that requires additional jump instructions.
            %
            It is assumed that the conditional {\instrFont br}~instruction
            falls through to the next instruction if the condition is false%
          }
  \labelFigure{jump-insert-example}
\end{figure}
%
See for example \refFigure{jump-insert-example}.
%
\Glspl{block}~\irBlock{A} and~\irBlock{B} both contain control-flow
\glspl{instruction} that branches to the beginning of \irBlock{B} if the
condition holds, otherwise they should branches to block~\irBlock{C}
(\refFigure{jump-insert-example-cfg}).
%
Because of the fall-through \gls{constraint}, \irBlock{A} and \irBlock{B} cannot
both have \irBlock{C} as its successor \gls{block}.
%
Hence an additional jump \gls{instruction} that directly branches to \irBlock{C}
must be inserted after the control-flow \gls{instruction} in either \irBlock{A}
or~\irBlock{B} (\refFigure{jump-insert-example-solutions}).

In this dissertation, we discuss two methods for inserting jump
\glspl{instruction} when required: \gls{branch extension} and \glspl{dual-target
  branch pattern}.
%
We first introduce the \glspl{variable} and \glspl{constraint} for modeling
\gls{block ordering} before introducing each method in turn, and then present
experiments showing that one is superior to the other.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{succ}[b] \in \mBlockSet$} models the
successor of block~$b$\hspace{-.5pt}.
%
For example, if \mbox{$\mVar{succ}[b] = b'$}, then \gls{block}~$b'$ will appear
immediately after \gls{block}~$b$ in the \gls{block ordering} sequence.


\subsubsection{Constraints}

A \gls{solution} to the \gls{block ordering} problem is a sequence of
\gls{block} successors such that they form a \gls{cycle}.
%
Using the \gls{circuit constraint} defined in
\refChapter{constraint-programming} on \refPageOfDefinition{circuit}, this
\gls{constraint} is modeled as
%
\begin{equation}
  \mCircuit(\mVar{succ}[b_1], \ldots, \mVar{succ}[b_n]),
  \labelEquation{block-order}
\end{equation}
%
where \mbox{$b_1, \ldots, b_n = \mBlockSet$}.

If a \gls{match}~$m$ with an \gls{entry block} is derived from an
\gls{instruction} that performs a \gls{fall-through} to \gls{block}~$b$, then
the \gls{constraint} can naively be modeled as \mbox{$\mVar{sel}[m] \mImp
  \mVar{succ}[\mEntry(m)] = b$}.
%
However, this \gls{constraint} is too limiting as it disallows empty
\glspl{block} to be placed between $\mEntry(m)$ and~$b$\hspace{-.5pt}, thus
forcing redundant jump \glspl{instruction} to be emitted.
%
A \gls{block}~$b$ is considered empty if either no \glspl{match} are placed in
$b$ or every \gls{match} in $b$ is a \gls!{null match}, which is a \gls{match}
that emits nothing if selected.
%
As empty \glspl{block} are not uncommon to appear in the \gls{function} under
compilation -- especially when having performed \gls{global code motion} -- this
has a significant impact on code quality.
%
Hence we extend the naive implementation into a disjunction, where the second
clause captures \glspl{fall-through} via single empty \glspl{block}.
%
Let $\mFallThroughSet$ denote a set of pairs~$\mPair{m}{b}$, where $m$ is a
\gls{match} and $b$ is a \gls{block} through which $m$ will fall if selected,
and let $\mNullMatchSet$ denote the set of \glspl{null match}.
%
With these definitions, the \gls{fall-through} \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{succ}[\mEntry(m)] = b \mOr \mbox{} \\
    \big(
      \mVar{succ}[\mVar{succ}[\mEntry(m)]] = b
      \mAnd
      \mEmptyBlock(\mVar{succ}[\mEntry(m)])
    \big)\hspace{-.8pt}, \\
    \forall \mPair{m}{b} \in \mFallThroughSet,
  \end{array}
  \labelEquation{fall-through}
\end{equation}
%
where
%
\begin{equation*}
  \mEmptyBlock(b)
  \equiv
  \mVar{oplace}[o] \neq b
  \mOr
  \mVar{omatch}[o] \in \mNullMatchSet,
  \forall o \in \mOpSet\hspace{-.8pt}.
\end{equation*}

If a \gls{block}~$b$ unconditionally branches to another \gls{block}~$b'$ and
$b'$ appears immediately after $b$ in the \gls{block} sequence, then a jump
\gls{instruction} is redundant.
%
To prevent emission of such jump \glspl{instruction}, we extend the \gls{pattern
  set} with a special \gls!{null-jump pattern}, with \gls{graph} structure
\mbox{$\mEdge{b}{\mEdge{c}{b'}}$}, that covers a \gls{control node}~$c$ at zero
cost provided that \mbox{$\mVar{succ}[b] = b'$}.


\subsection{Branch Extension}

One method of inserting jump \glspl{instruction} is to extend the \gls{UF graph}
with additional \glsshort{block node} and \glspl{control node}.
%
The idea is as follows.
%
For each \gls{control-flow edge}~$\mPair{c}{b}$, where $c$ is a \gls{control
  node} and $b$ is a \gls{block node}, we remove this \gls{edge} and insert a
new \gls{block node}~$b'$ and \gls{control node}~$c'$, and \glspl{control-flow
  edge} such that \mbox{$\mEdge{c}{\mEdge{b'}{\mEdge{c'}{b}}}$}.
%
If the new \glspl{control node} are indeed redundant, then each such \gls{node}
can be covered by a \gls{match} derived from the \gls{null-jump pattern},
causing the new \glspl{block} to become empty and appear immediately before the
target \gls{block}.
%
Like with \gls{copy extension}, to retain matching \gls{branch extension} must
also be performed on each \gls{UF graph} in the \gls{pattern set}.

The disadvantage of \gls{branch extension} is that it inflates the \gls{search
  space}.
%
The number of \glsshort{block node} and \glspl{control node} both increase by
$\mBigO(nk)$, where $n$ is the number of \glspl{block} before \gls{branch
  extension} and $k$ is the highest number of \gls{outbound.e}
\glspl{control-flow edge} from a \gls{control node} in the \gls{UF graph}.
%
This leads to more \glspl{operation} to be covered and more \glspl{block}
wherein an \gls{operation} may be placed.
%
In addition, as the majority of the new \glspl{block} will be empty, situations
often arise where a control-flow \gls{instruction} could successfully fall
through more than one \gls{block}.
%
Because of \refEquation{fall-through}, however, it can only fall through at most
one empty \gls{block}, causing emission of redundant jump \glspl{instruction}
that would not have been emitted had \gls{branch extension} not been performed.


\subsection{Dual-target Branch Patterns}

\def\jmpPattern{p_{\textsc{jmp}}}%

Another method is to extend the \gls{pattern set} with so-called
\glspl!{dual-target branch pattern}.
%
Given a \gls{pattern set}~$S$, first find the \gls{pattern}~\mbox{$\jmpPattern
  \in S$} which corresponds to a unconditional jump \gls{instruction} that
directly branches to a given label (it is reasonable to assume such a
\gls{pattern} always exist for any given \gls{target machine}).
%
Let \mbox{$\mCost(p)$} and \mbox{$\mEmits(p)$} denote the cost of pattern~$p$
respectively the sequence of \glspl{instruction} emitted by $p$ if selected.
%
Then, for each \gls{pattern}~\mbox{$p \in S$} which corresponds to a conditional
jump \gls{instruction} that falls through to a given block~$b$, add to $S$ a new
\gls{pattern}~$p'$ that is a copy of $p$ but has no \gls{fall-through}
\gls{constraint}, emits $\mEmits(p)$ followed by $\mEmits(\jmpPattern)$, and has
cost \mbox{$\mCost(p) + \mCost(\jmpPattern)$}.
%
\begin{figure}
  \subcaptionbox{%
                  A pattern that falls through to the \irBlock{false} block%
                  \labelFigure{dual-target-branch-pattern-example-original}%
                }%
                [68mm]%
                {%
                  \begin{tabular}{c}
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true} & $2$\\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  New pattern, without fall-through%
                  \labelFigure{dual-target-branch-pattern-example-copy}%
                }%
                [52mm]%
                {%
                  \begin{tabular}{c}
                    \newcommand{\fallthruString}{}%
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true}
                      & \textrm{$2 + \mCost\hspace{.4pt}(\jmpPattern)$}\\
                        \textrm{$\mEmits(\jmpPattern)$}
                      & \\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }

  \caption{Example of creating dual-target branch pattern}%
  \labelFigure{dual-target-branch-pattern-example}
\end{figure}
%
An example is shown in \refFigure{dual-target-branch-pattern-example}.
%
Because a \gls{dual-target branch pattern} has no \gls{fall-through}
\gls{constraint}, it essentially models a conditional jump \gls{instruction}
capable of directly branching to two \glspl{block} (hence the name).

Consequently, if a \gls{pattern set} contains $k$~\glspl{pattern} with
\gls{fall-through} \glspl{constraint} and a \gls{UF graph} contains
$n$~\glspl{control node} representing conditional jumps, then using
\glspl{dual-target branch pattern} will enlarge the \gls{match set} by
$\mBigO(nk)$~\glspl{match}.
%
Unlike \gls{branch extension}, however, the \gls{UF graph} does not need to be
extended with additional \glspl{block} wherein \glspl{operation} may be placed,
which results in a significantly \gls{search space}.


\subsection{Experimental Evaluation}

\todo{insert data}

\todo{discuss data}


\section{Objective Function}
\labelSection{cm-objective-function}

In \gls{instruction selection} most \glspl{compiler} optimize for performance,
meaning they attempt to minimize the total cost -- this is typically the
\gls{instruction} latency -- of the selected \glspl{match} per \gls{block}~$b$
while factoring in the execution frequency of~$b$.
%
The intuition is that the \glspl{instruction} selected for ``hot'' \glspl{block}
-- that is, those which are part of a loop with many iterations -- will have
greater impact than those selected for scarcely executed \glspl{block}.
%
In this chapter we introduce a straightforward but naive implementation of the
\gls{objective function}, which will be refined in the next chapter.


\subsubsection{Variables}

The \gls{cost variable} \mbox{$\mVar{cost} \in \mathbb{N}$} models the total
cost of the selected \glspl{match}.
%
It is assumed the total cost can never be negative.


\subsubsection{Constraints}

A straightforward implementation of the \gls{objective function} described above
can be modeled as
%
\begin{equation}
  \mVar{cost} =
  \sum_{m \in \mMatchSet}
  \mVar{sel}[m] \times \mCost(m) \times \mFreq(\mBlockOf(m)),
  \labelEquation{naive-objective-function}
\end{equation}
%
where \mbox{$\mCost(m) \in \mNatNumSet$} denotes the cost of \gls{match}~$m$,
\mbox{$\mFreq(b) \in \mNatNumSet$} denotes the execution frequency of
block~$b$\!, and \mbox{$\mBlockOf(m) \in \mBlockSet$} denotes the block wherein
$m$ is placed.
%
However, as previously stated \refEquation{naive-objective-function} is a naive
implementation and we therefore use a refined version, introduced in
\refChapter{solving-techniques}, which offers much stronger \gls{propagation}.


\section{Limitations}
\labelSection{cm-limitations}

The \gls{constraint model} described in this chapter has several limitations
that affect code quality.
%
Consequently, a \gls{solution} that is considered optimal with respect to this
\glsshort{constraint model} may still be inferior to the code produced by an
\gls{instruction selector} without these limitations.
%
The first limitation concerns \gls{recomputation} of values, the second concerns
elimination of common subexpressions, and the third concerns implicit sign and
zero extensions and truncations.


\subsubsection{Recomputation}

For some combinations of \glspl{function} and \glspl{target machine}, it may be
beneficial to \glsshort!{recomputation} values appearing in common
subexpressions instead of reusing it.
%
\begin{filecontents*}{recomputation-example-ir.c}
$\irAssign{a}{x + y}$
store a, $\ldots$
$\ldots$
store a, $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \subcaptionbox{Code snippet\labelFigure{recomputation-example-ir}}%
                [25mm]%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {recomputation-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF subgraph, covered by two matches derived from a
                  store instruction with base-plus-index addressing mode.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{recomputation-example-graph}%
                }%
                [74mm]%
                {%
                  \input{figures/constraint-model/recomputation-example-graph}%
                }%
  \hfill%
  \mbox{}

  \caption{%
    Example illustrating when recomputation is preferred over value reuse%
  }%
  \labelFigure{recomputation-example}
\end{figure}
%
See for example \refFigure{recomputation-example}.
%
The \gls{function} performs two memory stores using the same address
value~\irVar{a} (\refFigure{recomputation-example-ir}).
%
If the \gls{target machine} provides a memory \gls{instruction} with
base-plus-index addressing mode (that is, the address to be used is the sum of
the values appearing in a base and an index \gls{register}), then no
add~\gls{instruction} is needed for computing~\irVar{a}.
%
In the context of \gls{instruction selection}, this means letting the
\gls{operation} representing the addition to be covered by more than one
\gls{match} (\refFigure{recomputation-example-graph}).
%
However, Eqs.\thinspace\refEquation*{operation-coverage}
and~\refEquation*{data-definitions} require that every \gls{operation} and
\gls{datum} must be covered respectively \gls{define.d}[d] by exactly one
selected \gls{match}, thus forbidding such \glspl{solution}.
%
Although these \glspl{constraint} can be relaxed to allow \glspl{operation} and
\glspl{datum} to be covered respectively \gls{define.d}[d] by at least one
selected \gls{match}, many of the solving techniques introduced in this
dissertation which are needed for scalability and robustness rely on exact
\gls{cover}[age].


\subsubsection{If-Conversions}

In most cases, performing a branch incurs a performance penalty.
%
Some architectures therefore allow the \glspl{instruction} to be predicated with
a boolean flag for optional execution, which allows \glspl{function} with
if-then-else structures to be transformed into linear code.
%
This process is called \gls!{if-conversion}.

Although the \gls{universal representation} enables predicated versions of the
\glspl{instruction} to be captured as \glspl{pattern}, selection of such
\glspl{pattern} is typically prevented by the \gls{constraint model}.
%
\begin{filecontents*}{if-conversions-example-ir.c}
entry:
  $\ldots$
  if p goto body
  else goto end;
body:
  $\irAssign{a}{x + y}$
  $\irAssign{b}{v + w}$
end:
  $\ldots$
\end{filecontents*}
%
\begin{filecontents*}{if-conversions-example-instrs.c}
entry:
  $\ldots$
  if (p) add a, x, y
  if (p) add b, v, w
  $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \begin{minipage}{36mm}%
    \centering%
    \subcaptionbox{Code snippet\labelFigure{if-conversions-example-ir}}%
                  [28mm]
                  {%
                    \lstinputlisting[language=c,mathescape]%
                                    {if-conversions-example-ir.c}%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Assembly code with predicated instructions%
                    \labelFigure{if-conversions-example-instrs}%
                  }{%
                    \lstinputlisting[mathescape]%
                                    {if-conversions-example-instrs.c}%
                  }
  \end{minipage}%
  \hfill\hfill\hfill%
  \adjustbox{valign=M}{%
    \subcaptionbox{%
                    UF subgraph, covered by two matches derived predicated
                    add instructions%
                    \labelFigure{if-conversions-example-graph}%
                  }{%
                    \input{%
                      figures/constraint-model/if-conversions-example-graph%
                    }%
                  }%
  }%
  \hfill%
  \mbox{}

  \caption{%
    Example illustrating if-conversions%
  }%
  \labelFigure{if-conversions-example}
\end{figure}
%
See for example \refFigure{if-conversions-example}.
%
Assume a \gls{function} containing two sums, \irVar{a} and~\irVar{b}, which are
conditionally computed given a certain predicate~\irVar{p}
(\refFigure{if-conversions-example-ir}).
%
Because this constitutes an if-then-else structure, this code snippet is eligble
for \gls{if-conversion} (\refFigure{if-conversions-example-instrs}).
%
Representing the predicated versions of add~\glspl{instruction} as
\glspl{pattern} gives rise to two \glspl{match}, $m_1$ and~$m_2$, which can
collectively cover the \glsshort{computation node} and \glspl{control node} in
the corresponding \gls{UF graph} (\refFigure{if-conversions-example-graph}).
%
However, since $m_1$ and $m_2$ both cover the same \glspl{control node}, only
one of the \glspl{match} can be selected (due to
Eqs.\thinspace\refEquation*{operation-coverage}
and~\refEquation*{data-definitions}).
%
In addition, because both \glspl{match} \gls{consume.b} the \irBlock{body}
\gls{block}, no other \glspl{operation} may be placed in \irBlock{body} if
either is selected (due to \refEquation{consumption}).
%
This means either both or none of the \glspl{match} must be selected.
%
Together with the \gls{constraint} of exact \gls{cover}[age], in all
\glspl{solution} neither of $m_1$ or $m_2$ is selected.
%
This problem can be fixed by relaxing the \gls{constraint} of exact
\gls{cover}[age], but as in the case of \gls{recomputation} this inhibits many
of the necessary solving techniques.


\subsubsection{Implicit Sign or Zero Extensions}

In cases where the \gls{function} contains sign or zero extensions, depending on
the hardware the \gls{constraint model} may produce code with redundant
\glspl{instruction}.
%
\begin{figure}
  \centering%
  \input{figures/constraint-model/implicit-extensions-graph}

  \caption{Example illustrating implicit sign or zero extensions}%
  \labelFigure{implicit-extensions-example}
\end{figure}
%
See for example \refFigure{implicit-extensions-example}, which depicts a
\glsshort{UF graph}~\gls{subgraph} coverable by \glspl{match}~$m_1$, $m_2$,
and~$m_3$.
%
Assume that {\irFont foo} represents a \gls{function} call and that \irVar{a},
\irVar{b}, and \irVar{c} represent 8-bit values stored in 32-bit
\glspl{register}.
%
As is common, $m_3$ will be derived from an \gls{instruction} that checks
whether the full contents of two \glspl{register} are equal.
%
Consequently, as a precaution the upper bytes of the \glspl{register} need to be
zero-extended (that is, those bits are all set to~0) before doing the
comparison.
%
While this is certainly necessary for the \gls{register} of \irVar{a} as nothing
can be assumed about the value returned by {\irFont foo}, it may be redundant
for the register of \irVar{b}.
%
For example, $m_2$ may be derived from a single-byte load \gls{instruction} that
clears the entire \gls{register} before loading the value.
%
But since this information is lost in the \gls{constraint model}, $m_3$ must
assume both \glspl{register} need to be zero-extended.

One solution to this problem is to extend the \gls{pattern set} with additional
\glspl{pattern} that capture these situations.
%
For example, merging the \glspl{pattern} of $m_2$ and $m_3$ results in a
\gls{match} which, if selected, emits the \gls{instruction} of $m_2$ followed by
the \glspl{instruction} of $m_3$ without the redundant clearing of \irVar{b}.
%
Depending on the \gls{instruction set}, however, this may result in an
exponential number of \glspl{pattern}.
%
If the \gls{instruction set} contains $n$~\glspl{instruction} with implicit
extensions and $m$~\gls{instruction} each taking $k$~values that must first be
sign- or zero-extended, then this will result in $\mBigO(n^k m)$ additional
\glspl{pattern}.

Another solution is to apply the same mechanism used in \gls{copy extension}.
%
In the same manner as with \glspl{copy node}, first the \gls{UF graph} is
extended with \glspl!{extension node}.
%
Hence, for each \gls{data-flow edge}~$\mEdge{v}{o}$, where $v$ is a \gls{value
  node} and $o$ is an \gls{operation}, we remove this \gls{edge} and insert a
new \gls{extension node}~$e$, \gls{value node}~$v'$, and \glspl{data-flow edge}
such that \mbox{$\mEdge{v}{\mEdge{e}{\mEdge{v'}{o}}}$}.
%
Then the \gls{constraint model} is extended with two sets of \glspl{variable},
\mbox{$\mVar{sext}[d] \in \mSet{0, 1}$} and \mbox{$\mVar{zext}[d] \in \mSet{0,
    1}$}, denoting whether a value has been sign- respectively zero-extended.
%
We also extend the \gls{pattern set} with a special \gls!{null-extend pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{e}{v'}}$}, that covers $e$ at
zero cost provided that \mbox{$(\mVar{sext}[v] \mOr \neg\mVar{sext}[v']) \mAnd
  (\mVar{zext}[v] \mOr \neg\mVar{zext}[v'])$} holds.
%
Obviously, a \gls{match} derived from the \gls{null-extend pattern} emits
nothing if selected.
%
If the \gls{null-extend pattern} cannot be selected for covering a particular
\gls{extension node}, then this means an appropriate extension \gls{instruction}
must be emitted.


\section{Summary}
\labelSection{model-summary}

In this chapter, we have introduced a \gls{constraint model} that integrates the
problems of \gls{global.is} \gls{instruction selection}, \gls{global code
  motion}, \gls{data copying}, \gls{value reuse}, and \gls{block ordering}.
%
We have also discussed the limitations of this \glsshort{constraint model} and
how these impact the assembly code that can be produced.

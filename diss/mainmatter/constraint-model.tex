% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Constraint Model}
\labelChapter{constraint-model}

This chapter introduces the \gls{constraint model} for \gls{universal
  instruction selection}.
%
\RefSectionRange{modeling-global-instruction-selection}{modeling-block-ordering}
introduce the \glspl{variable} and \gls{constraint} for modeling \gls{global.is}
\gls{instruction selection}, \gls{global code motion}, \gls{data copying},
\gls{value reuse}, and \gls{block ordering}, respectively.
%
The \glsshort{constraint model} limitations are discussed in
\refSection{cm-limitations}.



\section{Modeling Global Instruction Selection}
\labelSection{modeling-global-instruction-selection}

Modeling \gls{global.is} \gls{instruction selection} entails that all
\glspl{operation} must be \gls{cover}[ed] and all \glspl{datum} must be
\gls{define.d}[d].
%
This could, however, lead to situations resulting in cyclic data dependencies,
which must be forbidden.


\subsection{Covering Operations and Defining Data}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
There are two variants of this problem:
%
\begin{enumerate*}[label=(\arabic*)]
  \item each \gls{operation} must appear in \emph{exactly} one selected
    \gls{match}; and
%
  \item each \gls{operation} must appear in \emph{at least} one selected
    \gls{match}, hence allowing matches to \gls{overlap}.
\end{enumerate*}
%
The former problem is more common as it is stricter, resulting in simpler models
with smaller \glspl{solution space}.
%
It also allows use of \glspl{constraint} that enable strong \gls{propagation},
which is essential for curbing solving time and increasing scalability.

Depending on the \gls{instruction set}, the latter problem permits
\glspl{solution} with potentially higher code quality.
%
For example, assume a \gls{UF graph} where a sum is used as address in two
memory operations and a \gls{target machine} where the address can be computed
as part of the memory instructions.
%
A \gls{solution} to the latter problem would therefore only need two
instructions, whereas the former problem would require three instructions -- one
to compute the sum and two to perform the memory operations -- since the
addition is not allowed to be covered by both memory instructions.
%
In certain conditions, however, an add instruction may still be required.
%
For example, assume a \gls{UF graph} where the sum is also used in a
subtraction.
%
For this \gls{UF graph}, unless the \gls{target machine} has an instruction that
performs both an addition and a subtraction, a \gls{solution} to either problem
requires an add instruction to compute the sum.
%
Due to the increased complexity of the relaxed version of the problem, we model
exact coverage in this dissertation.

Similarly, every value and state must be produced by exactly one selected match.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \gls!{define.d}[s] $d$
if there exists an inbound \glsshort{state-flow edge} or \gls{data-flow edge} to
$d$ in the \gls{UP graph} from which $m$ was derived.
%
Similarly, $m$ \gls!{use.d}[s] $d$ if there exists an outbound
\glsshort{state-flow edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph}
of $m$.


\subsubsection{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match} found
for $\mUFGraph$, the set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0,
    1}$} models whether \gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\neg\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt}}, where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$, and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} that can cover~$o$.
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[o]$} models which selected \gls{match} \gls{define.d}[s]
\gls{datum}~\mbox{$d \in \mDataSet$\hspace{-1.5pt}}, where $\mDataSet$ denotes
the set of \glspl{datum} in $\mUFGraph$, and \mbox{$\mMatchSet[d] \subseteq
  \mMatchSet$} denotes the set of \glspl{match} that can \gls{define.d}~$d$.


\subsubsection{Constraints}

The \gls{constraint} that every \gls{operation} must be covered is modeled as
%
\begin{equation}
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m],
  \forall o \in \mOpSet \hspace{-1pt},
  \forall m \in \mMatchSet[o] \hspace{-1pt}.
  \labelEquation{operation-coverage}
\end{equation}
%
Hence an \gls{operation}~$o$ is covered by a match~$m$ if and only if $m$ is
selected.

Likewise, the \gls{constraint} that every \gls{datum} must be \gls{define.d}[d]
is modeled as
%
\begin{equation}
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m],
  \forall d \in \mDataSet \hspace{-1.5pt},
  \forall m \in \mMatchSet[d] \hspace{-1pt}.
  \labelEquation{data-definitions}
\end{equation}
%
Hence a \gls{datum}~$d$ is \gls{define.d}[d] by a match~$m$ if and only if $m$
is selected.


\subsection{Forbidding Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

In certain cases, selecting \glspl{match} of \glspl{instruction} producing
multiple results -- for example, many modern processors provide memory
\glspl{instruction} that automatically increment or decrement the address value
-- could lead to cyclic data dependencies~\cite{EbnerEtAl:2008}.
%
\begin{filecontents*}{cyclic-data-deps-example-ir.c}
$\ldots$
$\irAssign{\irVar{p}[2]}{\irAdd{\irVar{p}[1]}{\irVar{4}}}$
$\irStore{\irVar{q}[1]}{\irVar{p}[2]}$
$\irAssign{\irVar{q}[2]}{\irAdd{\irVar{q}[1]}{\irVar{4}}}$
$\irStore{\irVar{p}[1]}{\irVar{q}[2]}$
\end{filecontents*}%
%
\begin{figure}
  \subcaptionbox{IR\labelFigure{cyclic-data-deps-example-ir}}%
                {%
                  \lstinputlisting[language=c,mathescape]%
                                  {cyclic-data-deps-example-ir.c}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF graph, covered by two matches derived from an
                  auto-increment store instruction.
                  %
                  For brevity, the state node are not included%
                  \labelFigure{cyclic-data-deps-example-uf-graph}%
                }%
                [62mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-uf-graph%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Dependency graph%
                  \labelFigure{cyclic-data-deps-example-dep-graph}%
                }%
                [32mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-dep-graph%
                  }%
                }

  \caption{Example illustrating cyclic data dependencies}%
  \labelFigure{cyclic-data-deps-example}%
\end{figure}
%
An example of such a situation is given in \refFigure{cyclic-data-deps-example}.
%
If both \glspl{match} are selected, then either value~\irVar{p}[2] or
value~\irVar{q}[2] will be \gls{use.d}[d] before it is available (depending on
the instruction order), thus resulting in incorrect code.
%
Consequently, such combinations must be identified and forbidden.

We detect such combinations -- which could involve more than two \glspl{match}
-- by first constructing a \gls!{dependency graph}, where each \gls{node}
represents a \gls{match} and each \gls{edge}~$\mEdge{n}{m}$ indicates
that \gls{match}~$m$ \gls{use.d}[s] \glspl{datum} produced by \gls{match}~$n$.
%
A \gls{cycle} in this \gls{graph} corresponds a combination of \glspl{match}
which will lead to a cyclic data dependency if all \glspl{match} are selected.
%
Hence, we find all \glspl{cycle} in the \gls{dependency graph} -- we applied
\citeauthor{Johnson:1975}'s algorithm for this task~\cite{Johnson:1975} -- and
add \glspl{constraint} forbidding selection of all \glspl{match} appearing in a
\gls{cycle}.


\subsubsection{Constraints}

Given a set~\mbox{$\mForbiddenCombSet \subseteq \mPowerset{\mMatchSet}$} of
\glspl{cycle} found for the \gls{dependency graph} built from a \gls{UF graph}
and \gls{match set}, the \gls{constraint} forbidding cyclic data dependencies is
modeled as
%
\begin{equation}
  \sum_{m \in f} \mVar{sel}[m] < \mCard{f},
  \forall f \in \mForbiddenCombSet.
  \labelEquation{cyclic-data-deps}
\end{equation}
%
In other words, the number of selected \glspl{match} must be strictly less than
the number of \gls{match} appearing in the \gls{cycle}.


\section{Modeling Global Code Motion}
\labelSection{modeling-global-code-motion}

The \gls{global code motion} problem entails that \glspl{datum} must be placed
in \glspl{block} such that each definition of a \gls{datum}~$d$ precedes all
\gls{use.d}[s] of~$d$.
%
This condition can be expressed in terms of \gls{block} dominance.
%
Given a \gls{function}~$f$, a \gls{block}~$b$ in $f$ \gls!{dominate.b}[s]
another \gls{block}~$c$ in $f$ if $b$ appears on every control-flow path from
$f$'s \gls{entry block} to $c$ (see \refFigure{block-dominance-example} for an
example).
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{block-dominance-example-cfg}}%
                [34mm]%
                {%
                  \input{%
                    figures/constraint-model/block-dominance-example%
                  }%
                }%
  \hfill%
  \subcaptionbox{Dominance\labelFigure{block-dominance-example-doms}}%
                {%
                  \figureFontSize%
                  \begin{tabular}{cc}
                    \toprule
                      \tabhead Block
                    & \tabhead dominates\\
                    \midrule
                      \irBlock{entry}
                    & $\mSet{\irBlock{entry}, \irBlock{A}, \irBlock{B},
                        \irBlock{C}, \irBlock{D}, \irBlock{E}}$\\
                      \irBlock{A}
                    & $\mSet{\irBlock{A}, \irBlock{B}, \irBlock{C},
                        \irBlock{D}}$\\
                      \irBlock{B}
                    & $\mSet{\irBlock{B}}$\\
                      \irBlock{C}
                    & $\mSet{\irBlock{C}}$\\
                      \irBlock{D}
                    & $\mSet{\irBlock{D}}$\\
                      \irBlock{E}
                    & $\mSet{\irBlock{E}}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \mbox{}

  \caption{Example of block dominance}
  \labelFigure{block-dominance-example}
\end{figure}%
%
By definition, a \gls{block} always \gls{dominate.b}[s] itself.
%
Hence a placement of \glspl{match} into \glspl{block} is a \gls{solution} to the
\gls{global code motion} problem if each \gls{datum}~$d$ is \gls{define.d}[d] by
some selected \gls{match} placed in a \gls{block}~$b$, and every
non-\gls{phi-match} \glsshort{use.d}[ing] $d$ is placed in a \gls{block}
\gls{dominate.b}[d] by~$b$.
%
The \glspl{phi-match} must be excluded since, due to the \glspl{definition
  edge}, at least one \gls{datum} used by such \glspl{match} must be
\gls{define.d}[d] in a \gls{block} that does not \gls{dominate.b} the
\gls{block} wherein the \gls{phi-match} must be placed.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{oplace}[o] \in \mBlockSet$} models in
which \gls{block} \gls{operation}~$o$ is placed, where $\mBlockSet$ denotes the
set of \glspl{block} in $\mUFGraph$.
%
Likewise, the set of \glspl{variable} \mbox{$\mVar{dplace}[d] \in \mBlockSet$}
models in which \gls{block} the definition of \gls{datum}~$d$ is placed.


\subsubsection{Constraints}

Intuitively, all \glspl{operation} covered by a \gls{match}~$m$ must be placed
in the same \gls{block} wherein $m$ itself is placed.
%
Hence, if \mbox{$\mCovers(m) \subseteq \mOpSet$} denotes the set of
\glspl{operation} covered by \gls{match}~$m$, then this \gls{constraint} is
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o_1] = \mVar{oplace}[o_2], \\
    \forall m \in \mMatchSet,
    \forall o_1\hspace{-1pt}, o_2 \in \mCovers(m).
  \end{array}
  \labelEquation{operation-placement}
\end{equation}
%
This also enables the placement of $m$ to be deduced from any of the
corresponding $\mVar{oplace}$~\glspl{variable}.

We prevent control-flow \glspl{operation} from being moved to another
\gls{block}, which in all likelihood would break \gls{program} semantics, by
forcing selected \glspl{match} with control flow to be placed in the \gls{block}
matched by the \gls{UP graph}'s \gls{entry block}.
%
Hence, if \mbox{$\mEntry(m) \subseteq \mBlockSet$} returns either the empty set
or a set containing only the \gls{entry block} of match~$m$ (when the \gls{UP
  graph} of $m$ has such a node), then this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o] = b\hspace{-1.2pt}, \\
    \forall m \in \mMatchSet,
    \forall o \in \mCovers(m),
    \forall b \in \mEntry(m).
  \end{array}
  \labelEquation{preventing-control-flow-op-moves}
\end{equation}

As stated previously, each \gls{datum}~$d$ must be \gls{define.d}[d] in some
\gls{block}~\mbox{$b \in \mBlockSet$} such that $b$ \gls{dominate.b}[s] every
\gls{block} wherein $d$ is \gls{use.d}[d], excluding \gls{use.d}[s] made by the
\glspl{phi-match}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} denote the set of \glspl{datum}
\gls{define.d}[d] respectively \gls{use.d}[d] by \gls{match}~$m$.
%
Let also \mbox{$\mDom(b) \subseteq \mBlockSet$} denote the set of \glspl{block}
\gls{dominate.b}[d] by \gls{block}~$b$.
%
With these definitions, the \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in \mDom(\mVar{oplace}[o]), \\
    \forall m \in \mMatchCompSet{\mPhi},
    \forall d \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{dom}
\end{equation}
%
where $\mMatchCompSet{\mPhi}$ denotes the set~$\mMatchSet$ without the
\glspl{phi-match}.

The restrictions imposed by the \glspl{definition edge} are modeled as
%
\begin{equation}
  \mVar{dplace}[d] = b,
  \forall \mEdge{d}{b} \in \mDefEdgeSet,
  \labelEquation{def-edges}
\end{equation}
%
where $\mDefEdgeSet$ denotes the set of \glspl{definition edge} in $\mUFGraph$.
%
It is assumed that the \glspl{edge} in $\mDefEdgeSet$ have been reoriented such
that all \glspl{source} are either \glsshort{state node} or \glspl{value node}
and all \glspl{target} are \glspl{block node}.

So far, there is no connection between the $\mVar{oplace}$ and $\mVar{dplace}$
\glspl{variable}.
%
Intuitively, every \gls{datum} \gls{define.d}[d] by a \gls{match}~$m$ should be
placed in the same \gls{block} as $m$ together with all \glspl{operation}
covered by~$m$.
%
This alone, however, could result in an over-constrained \glsshort{constraint
  model} that prevents selection of certain \glspl{match}.
%
For example, assume a \gls{match}~$m$ of the \gls{UP graph} shown in
\refFigure{up-graph-examples-add-graph} on
\refPageOfFigure{up-graph-examples-add-graph}, where the \glspl{block node}
\irBlock{entry}, \irBlock{clamp}, and \irBlock{end} are matched to \glspl{block}
in $\mUFGraph$ labeled \irBlock{A}, \irBlock{B}, and \irBlock{C}, respectively.
%
Because of \refEquation{preventing-control-flow-op-moves}, $m$ must be placed in
the \irBlock{A}~\gls{block}.
%
But because of \refEquation{def-edges}, one of its \glspl{value node} must be
placed in the \irBlock{B}~\gls{block}.
%
Consequently, for such conditions the \gls{constraint} is relaxed as follows.
%
We say that a \gls{match} \gls!{span.b}[s] the \glspl{block} matched by the
\gls{UP graph}'s \glspl{block node} (hence $m$ \gls{span.b}[s] \glspl{block}
\irBlock{A}, \irBlock{B}, and~\irBlock{C}).
%
We also say that a \gls{match} \gls!{consume.b}[s] any matched \glspl{block}
where the corresponding \gls{block node} has both \gls{inbound.e} and
\gls{outbound.e} control-flow \glspl{edge} in the \gls{UP graph} (hence $m$
\gls{consume.b}[s] \gls{block}~\irBlock{B}).
%
Consequently, every \gls{datum}~$d$ \gls{define.d}[d] by a \gls{match}~$m$ must
be placed in the same \gls{block} as $m$ only if $m$ \gls{span.b}[s] no
\glspl{block}, otherwise $d$ may be \gls{define.d}[d] in any of the
\glspl{block} \gls{span.b}[ned] by~$m$.
%
If \mbox{$\mSpans(m) \subseteq B$} denotes the set of \glspl{block}
\gls{span.b}[ned] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d] \in \mSet{\mVar{oplace}[o]} \cup \mSpans(m), \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m),
    \forall o \in \mCovers(m).
  \end{array}
  \labelEquation{spanning}
\end{equation}

\Glsshort{consume.b}[ing] a \gls{block} entails that the corresponding
\gls{instruction} assumes full control of the control flow to and from that
\gls{block}, which in turn means no \glspl{operation} covered by other
\glspl{match} may be placed in that \gls{block}.
%
Hence, if \mbox{$\mConsumes(m) \subseteq B$} denotes the set of \glspl{block}
\gls{consume.b}[d] by \gls{match}~$m$, then this constraint is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{oplace}[o] \neq b\hspace{-1.2pt}, \\
    \forall m \in \mMatchSet,
    \forall o \in \mOpSet \setminus \mCovers(m),
    \forall b \in \mConsumes(m).
  \end{array}
  \labelEquation{consumption}
\end{equation}


\section{Modeling Data Copying}
\labelSection{modeling-data-copying}

The cost of \gls{data copying} is taken into account by keeping track of the
location requirements for the data used and produced by the selected
\glspl{match}.
%
The idea is as follows.
%
For each value~$v$ in the \gls{UF graph}, let a \gls{variable}~$\mVar{x}$ decide
in which location provided by the \gls{target machine} $v$ is stored.
%
A \gls{match}~$m$ that either \gls{use.d}[s] or \gls{define.d}[s] $v$ and
requires $v$ to be in one of a set~$L$ of locations can then enforce, if
selected, that \mbox{$\mVar{x} \in L$}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{loc}[d] \in \mLocationSet \cup
  \mSet{\mNullLocation}$} models in which location \gls{datum}~$d$ is available,
where $\mLocationSet$ denotes the set of locations provided by the \gls{target
  machine} and $\mNullLocation$ denotes a special location for values that
cannot be reused across \glspl{instruction}.
%
In this context a location is an abstract representation, typically representing
a \gls{register}, but it could also indicate that the value is for example
stored in memory.
%
The special location is used for intermediate values produced internally by an
\gls{instruction} which can only be accessed by this very \gls{instruction}.
%
For example, the address computed by a memory load \gls{instruction} with a
sophisticated addressing mode is produced within the pipeline and thus cannot be
reused by other \glspl{instruction}.


\subsubsection{Constraints}

Every \gls{datum} must be made available in a location that is compatible for
all selected \glspl{match}.
%
If \mbox{$\mStores(m, d) \subseteq \mLocationSet \cup \mSet{\mNullLocation}$}
denotes the set of compatible locations (including the special location for
intermediate values) for a \gls{datum}~$d$ which is either \gls{define.d}[d] or
\gls{use.d}[d] by a \gls{match}~$m$, then this \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[d] \in \mStores(m, d), \\
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{compatible-locations}
\end{equation}


\subsection{Copy Extension}

Depending on the \gls{target machine}, \refEquation{compatible-locations} can
result in an over-constrained \glsshort{constraint model}.
%
For example, in many \glspl{target machine} the \gls{SIMD.instr}
\glspl{instruction} use a different set of \glspl{register} than the other,
general \glspl{instruction}.
%
In such situations, the \glspl{match} derived from the \gls{SIMD.instr}
\glspl{instruction} and the \glspl{match} derived from the general
\glspl{instruction} will have non-overlapping locations on the same
\glspl{datum} (that is, \mbox{$\mStores(m_1, d) \cap \mStores(m_2, d) =
  \mEmptySet$}), preventing selection of such \glspl{match}.

Since non-overlapping locations entails the need for copy \glspl{instruction},
we extend the \gls{UF graph} with \glspl!{copy node} through a process called
\gls!{copy extension}.
%
For each \gls{data-flow edge}~$\mEdge{v}{o}$, where $v$ is a \gls{value node}
and $o$ is an \gls{operation}, we remove this \gls{edge} and insert a new
\gls{copy node}~$c$, \gls{value node}~$v'$, and \glspl{data-flow edge} such that
\mbox{$\mEdge{v}{\mEdge{c}{\mEdge{v'}{o}}}$}.
%
If $o$ is a \gls{phi-node} then the corresponding \gls{definition edge}
connected to $v$ -- this is the \gls{edge} with the same \gls{outbound.en}
\gls{edge number} as the \gls{data-flow edge} -- is also moved to $v'$.
%
This is to ensure that the placement restrictions are applied only on the
\glspl{datum} actually used by the \glspl{phi-function} (that is, the copied
value and not the original value).
%
We also extend the \gls{pattern set} with a special \gls!{null-copy pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, that covers $c$ at
zero cost provided that \mbox{$\mVar{loc}[v] = \mVar{loc}[v']$}.
%
Obviously, a \gls{match} derived from the \gls{null-copy pattern} emits nothing
if selected.
%
If the \gls{null-copy pattern} cannot be selected for covering a particular
\gls{copy node}, then this means an appropriate copy \gls{instruction} must be
emitted whose cost will be accounted for.

In order to retain matching of \glspl{pattern}, we also need to perform
\gls{copy extension} on every \gls{UP graph} in the \gls{pattern set}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original UP graph%
                  \labelFigure{copy-extending-pattern-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After copy extension%
                  \labelFigure{copy-extending-pattern-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of copy-extending a pattern}
  \labelFigure{copy-extending-pattern-example}
\end{figure}
%
See for example \refFigure{copy-extending-pattern-example}.
%
The \gls{UP graph} captures the behavior of an \gls{instruction} that adds two
values~\irVar{r} and~\irVar{s} and then shifts the result by one bit to the
right (\refFigure{copy-extending-pattern-example-before}).
%
Since we want to preserve the ability of selecting copy \glspl{instruction} for
moving \glspl{datum} between \glspl{instruction}, we only copy-extend the
\glspl!{internal value} in a \gls{UP graph}, which are values that are both
\gls{define.d}[d] and \gls{use.d}[d] by the \gls{pattern}.
%
We also copy-extend any constant values since these obviously do not require a
separate copy \gls{instruction} to be used by the \gls{pattern}.
%
The resulting \gls{UP graph} will now yield the same \glspl{match} as before
\gls{copy extension} (\refFigure{copy-extending-pattern-example-after}).


\subsection{Handling Calling Conventions}

The method for handling \gls{data copying} can also be used for handling calling
conventions of the specific \gls{target machine}.
%
\Glspl{constraint} that callee arguments (that is, arguments to the
\gls{function} under compilation) must reside in a specific location are modeled
as
%
\begin{equation}
  \mVar{loc}[d] \in \mArgLoc(d),
  \forall d \in \mArgSet,
  \labelEquation{function-args}
\end{equation}
%
where \mbox{$\mArgSet \subseteq \mDataSet$} denotes the set of \gls{function}
arguments in $\mUFGraph$ and \mbox{$\mArgLoc(d) \subseteq \mLocationSet$}
denotes the set of locations in which argument~$d$ resides.
%
Arguments residing on the stack can be signified using a special $\mMemLocation$
location, thus requiring a memory load \gls{instruction} in order to be used by
other \glspl{instruction}.

Locations for caller arguments (that is, arguments to \glspl{function} calls
made from within the \gls{function} under compilation) can be enforced either
through \refEquation{function-args} or through
\refEquation{compatible-locations}.
%
If the calling convention depends on the \gls{instruction} selected then the
former is needed, otherwise the latter is more suitable as the restrictions can
be enforced before a \gls{match} is selected.\!%
%
\footnote{%
  If exactly one \gls{match}~$m$ can cover a given \gls{function} call
  \gls{node}, then both \glspl{constraint} provide the same amount of
  propagation as \mbox{$\mVar{sel}[m] = 1$} will always hold for the implication
  in \refEquation{compatible-locations}.
}


\section{Modeling Value Reuse}
\labelSection{modeling-value-reuse}

Code quality can be increased if \glspl{instruction} are allowed to reuse copies
of values, which is a crucial feature to be expected in the code emitted by any
modern \gls{instruction selector}.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  A UF graph with two matches%
                  \labelFigure{value-reuse-example-uf-graph}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-uf-graph}}%
  \hfill%
  \subcaptionbox{%
                  UF graph after copy extension%
                  \labelFigure{value-reuse-example-after-ce}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-after-ce}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Redundant copying of values%
                  \labelFigure{value-reuse-example-redundant-copies}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    value-reuse-example-redundant-copies%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Reuse of copied value%
                  \labelFigure{value-reuse-example-one-copy}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/value-reuse-example-one-copy%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of value reuse}
  \labelFigure{value-reuse-example}
\end{figure}
%
See for example \refFigure{value-reuse-example}.
%
Originally, the \gls{UF graph} has a value~\irVar{v} which is used by two
\glspl{operation} coverable by \glspl{match}~$m_1$ and~$m_2$
(\refFigure{value-reuse-example-uf-graph}).
%
After \gls{copy extension}, $m_1$ and $m_2$ use their own private copy --
\irVar{v}[1] and \irVar{v}[2], respectively -- of \irVar{v}
(\refFigure{value-reuse-example-after-ce}).
%
We say \irVar{v}[1] and \irVar{v}[2] are \gls!{copy-related.d}.
%
Consequently, if both $m_1$ and $m_2$ require \irVar{v} to be copied -- assume
for example that \irVar{v} resides on the stack -- then two copy
\glspl{instruction} will be emitted
(\refFigure{value-reuse-example-redundant-copies}).
%
However, if \irVar{v}[1] and \irVar{v}[2] could reside in the same location then
either of the values could be reused by either \gls{match}, thus necessitating
only one copy \gls{instruction} (\refFigure{value-reuse-example-one-copy}).
%
We call this notion \gls!{value reuse}.

In this dissertation, we discuss two methods for reusing values: \gls{match
  duplication} and \glspl{alternative value}.
%
We first introduce each in turn and then present experiments showing that one is
superior to the other.


\subsection{Match Duplication}

The idea is easily derived from its name: for each \gls{match}~$m$, create a new
\gls{match} for each permutation of \glspl{datum} that are \gls{copy-related.d}
to the \glspl{input datum} in $m$, where an \gls!{input datum} is a \gls{datum}
\gls{use.d}[d] but not \gls{define.d}[d] by~$m$.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{match-duplication-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After match duplication%
                  \labelFigure{match-duplication-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of match duplication}
  \labelFigure{match-duplication-example}
\end{figure}
%
See for example \refFigure{match-duplication-example}.
%
The \gls{match set} contains a \gls{match}~$m$ that uses value~\irVar{v}[1],
which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{match-duplication-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we duplicate $m$ to instead
use \irVar{v}[2], resulting in match~$m'$
(\refFigure{match-duplication-example-after}).

The main advantage of \gls{match duplication} is that no changes need to be done
for the \gls{constraint model}; the decision of which value to use (and reuse)
depends entirely on the selection of \glspl{match}.
%
However, this comes at a cost of inflating the \gls{match set}, which in turn
inflates the \gls{search space}.
%
If a \gls{match} has $k$~\glspl{input datum}, each with $n$~\gls{copy-related.d}
values, then $\mBigO(n^k)$ new \glspl{match} will be created.
%
Although the decision of \gls{value reuse} is intuitively orthogonal to the
decisions of selecting a \gls{match} and placing it into a \glspl{block}, these
decisions must be remade for each new \gls{match}, thereby enlarging the
\gls{search space} with many symmetric \glspl{solution}.


\subsection{Alternative Values}

The idea is as follows.
%
For each \gls{match}~$m$, let every \glspl{input datum}~$d$ in $m$ be mapped to
any \gls{datum} that is \gls{copy-related.d} to~$d$.
%
In other words, unlike before when a \gls{match} was \mbox{1-to-1} mapping
between \glspl{node} in the \gls{UP graph} and \glspl{node} in the \gls{UF
  graph}, we now allow certain mappings to be a \mbox{1-to-$n$} mapping.
%
\begin{figure}
  \setlength{\opNodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{alt-values-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-without%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  With alternative values%
                  \labelFigure{alt-values-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-with%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of alternative values}
  \labelFigure{alt-values-example}
\end{figure}
%
See for example \refFigure{alt-values-example-before}.
%
Again, the \gls{match set} contains a \gls{match}~$m$ that uses
value~\irVar{v}[1], which is \gls{copy-related.d} with value~\irVar{v}[2]
(\refFigure{alt-values-example-before}).
%
Because \irVar{v}[1] is an \gls{input datum} in~$m$, we extend the mapping from
$n$ to \irVar{v}[1] to include \irVar{v}[2], where $n$ is the corresponding
\gls{value node} in the \gls{UP graph} of~$m$
(\refFigure{alt-values-example-after}).
%
In this context, \irVar{v}[1] and \irVar{v}[2] are said to be
\glspl!{alternative value} to~$m$.
%
For convenience, we assume that the set of \glspl{alternative value} for each
non-\gls{input datum}~$d$ in a \gls{match} contains only the \glsshort{state
  node} or \gls{value node} to which $d$ is already mapped.

After having extended the \gls{match set} with \glspl{alternative value}, the
next step is to extend the \gls{constraint model} with an another level of
indirection wherever a \gls{constraint} refers to a \gls{datum}.


\subsubsection{Variables}

Assume first that each \glsshort{define.d}[ition] or \glsshort{use.d}[age] of
\glspl{datum} within each \gls{match} incurs a unique \gls!{operand}.
%
Consequently, instead of \glsshort{define.d}[ing] and \glsshort{use.d}[ing]
\glspl{datum}, we now assume that all \glspl{match} \gls{define.d} and
\gls{use.d} \glspl{operand}.
%
Hence the set of \glspl{variable} \mbox{$\mVar{alt}[p] \in \mDataSet[p]$} models
to which \gls{datum} \gls{operand}~\mbox{$p \in \mOperandSet$} is mapped, where
\mbox{$\mDataSet[p] \subseteq \mDataSet$} denotes the set of alternative values
for~$p$, and $\mOperandSet$ denotes the set of \glspl{operand} incurred
by~$\mMatchSet$.

For reasons that will become apparent shortly, we also introduce a set of
\glspl{variable} \mbox{$\mVar{inactive}[d] \in \mSet{0, 1}$}, which models
whether a \gls{datum}~$d$ is \gls{inactive.d}.


\subsubsection{Constraints}

As stated previously, the aim is to add another level of indirection whenever a
\gls{constraint} refers to a \gls{datum}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} now denote the set of \glspl{operand}
(instead of \glspl{datum}) \gls{define.d}[d] respectively \gls{use.d}[d] by
\gls{match}~$m$.
%
With these new definitions, Eqs.\thinspace\refEquation*{dom},
\refEquation*{spanning}, and~\refEquation*{compatible-locations} are adjusted
accordingly (the changes are highlighted in grey):
%
\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mDom(\mVar{oplace}[o]), \\
    \forall m \in \mMatchCompSet{\mPhi},
    \forall \hlDiff{p} \in \mUses(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{dom-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in
      \mSet{\mVar{oplace}[o]} \cup \mSpans(m), \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m),
    \forall o \in \mCovers(m),
  \end{array}
  \labelEquation{spanning-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mStores(m, \hlDiff{p}), \\
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{compatible-locations-alt}
\end{equation}

Due to these changes there may be \glspl{datum} that is not \gls{use.d}[d] by
any \gls{match}, yet \refEquation{data-definitions} still requires that every
\gls{datum} must be \gls{define.d}[d] by some \gls{match}.
%
We address this by extending the \gls{pattern set} with a \gls!{kill pattern}
(shaped like \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}, where $v$ and $v'$ are
\glspl{value node} and $c$ is a \gls{copy node}).
%
\Glspl{match} derived from this \gls{pattern} are called \glspl!{kill match},
which have zero cost and emit nothing if selected.
%
A \gls{datum} is said to be \gls!{inactive.d} if and only if it is
\gls{define.d}[d] by a \gls{kill match}, and non-\glspl{kill match} are
forbidden to use \gls{inactive.d} \glspl{datum}.
%
Likewise, a \gls{datum} cannot be \gls{inactive.d} if it is used by a
non-\gls{kill match}.
%
These \glspl{constraint} are modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mEq
    \mVar{inactive}[\mVar{alt}[p]], \\
    \forall m \in \mMatchSet[\mKill],
    \forall p \in \mDefines(m)
  \end{array}
  \labelEquation{inactivity-when-killed}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \neg \mVar{inactive}[\mVar{alt}[p]], \\
    \forall m \in \mMatchCompSet{\mKill},
    \forall p \in \mUses(m)
  \end{array}
  \labelEquation{inactivity-when-used}
\end{equation}
%
where $\mMatchSet[\mKill]$ and $\mMatchCompSet{\mKill}$ denote the set of
\glspl{kill match} respectively the set~$\mMatchSet$ without the \glspl{kill
  match}.


\subsection{Experimental Evaluation}

\todo{insert data}

\todo{discuss data}


\section{Modeling Block Ordering}
\labelSection{modeling-block-ordering}

Ordering the \glspl{block} in a \gls{function} entails finding a sequence~$s$
such that each \gls{block} appears exactly once in~$s$\hspace{-.8pt}.
%
Depending on the control-flow \glspl{instruction} selected, some \glspl{block}
may need to be adjacent.
%
For example, assume a \gls{block}~$b$ that jumps to either of two
\glspl{block}~$c$ and~$d$ depending on whether a condition holds.
%
Assume also that the conditional branching in $b$ is implemented using an
\gls{instruction} that jumps to $c$ if the condition holds, otherwise it
continues the execution with the next \gls{instruction} in the \gls{assembly
  code}.
%
This notion of execution is called \gls!{fall-through}, and due to this, $d$
must be placed immediately after $b$ in the sequence.

For some combinations of \glspl{function} and \glspl{target machine} with
\gls{fall-through} \glspl{instruction}, there exist no valid \gls{block}
sequence without inserting one or more additional jump \glspl{instruction}.
%
\begin{figure}
  \setlength{\opNodeDist}{20pt}%
  \tikzset{
    block node/.append style={
      minimum width=2cm,
      minimum height=.9\opNodeSize,
    },
  }%

  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{jump-insert-example-cfg}}%
                [34mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-cfg}%
                }%
  \hfill%
  \subcaptionbox{%
                  Valid block sequences, after jump insertion%
                  \labelFigure{jump-insert-example-solutions}%
                }%
                [65mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-sol1}%
                  \hspace{6mm}%
                  \input{figures/constraint-model/jump-insert-example-sol2}%
                }%
  \hfill%
  \mbox{}

  \caption[Example that requires additional jump instructions]%
          {%
            Example that requires additional jump instructions.
            %
            It is assumed that the conditional {\instrFont br}~instruction
            falls through to the next instruction if the condition is false%
          }
  \labelFigure{jump-insert-example}
\end{figure}
%
See for example \refFigure{jump-insert-example}.
%
\Glspl{block}~\irBlock{A} and~\irBlock{B} both contain control-flow
\glspl{instruction} that jump to the beginning of \irBlock{B} if the condition
holds, otherwise they should jump to block~\irBlock{C}
(\refFigure{jump-insert-example-cfg}).
%
Because of the fall-through \gls{constraint}, \irBlock{A} and \irBlock{B} cannot
both have \irBlock{C} as its successor \gls{block}.
%
Hence an additional \gls{instruction} that directly jumps to \irBlock{C} must be
inserted after the control-flow \gls{instruction} in either \irBlock{A}
or~\irBlock{B} (\refFigure{jump-insert-example-solutions}).

In this dissertation, we discuss two methods for inserting jump
\glspl{instruction} when required: \gls{block extension} and \glspl{dual-target
  branch pattern}.
%
We first introduce the \glspl{variable} and \glspl{constraint} for modeling
\gls{block ordering} before introducing each method in turn, and then present
experiments showing that one is superior to the other.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{succ}[b] \in \mBlockSet$} models the
successor of block~$b$\hspace{-.5pt}.
%
For example, if \mbox{$\mVar{succ}[b] = b'$}, then \gls{block}~$b'$ will appear
immediately after \gls{block}~$b$ in the \gls{block ordering} sequence.


\subsubsection{Constraints}

A \gls{solution} to the \gls{block ordering} problem is a sequence of
\gls{block} successors such that they form a \gls{cycle}.
%
Using the \gls{circuit constraint} defined in
\refChapter{constraint-programming} on \refPageOfDefinition{circuit}, this
\gls{constraint} is modeled as
%
\begin{equation}
  \mCircuit(\mVar{succ}[b_1], \ldots, \mVar{succ}[b_n]),
  \labelEquation{block-order}
\end{equation}
%
where \mbox{$b_1, \ldots, b_n = \mBlockSet$}.

If a \gls{match}~$m$ with an \gls{entry block} is derived from an
\gls{instruction} that performs a \gls{fall-through} to \gls{block}~$b$, then
the \gls{constraint} can naively be modeled as \mbox{$\mVar{sel}[m] \mImp
  \mVar{succ}[\mEntry(m)] = b$}.
%
However, this \gls{constraint} is too limiting as it disallows empty
\glspl{block} to be placed between $\mEntry(m)$ and~$b$\hspace{-.5pt}, thus
forcing redundant jump \glspl{instruction} to be emitted.
%
A \gls{block}~$b$ is considered empty if either no \glspl{match} are placed in
$b$ or every \gls{match} in $b$ is a \gls!{null match}, which is a \gls{match}
that emits nothing if selected.
%
As empty \glspl{block} are not uncommon to appear in the \gls{function} under
compilation -- especially when having performed \gls{global code motion} -- this
has a significant impact on code quality.
%
Hence we extend the naive implementation into a disjunction, where the second
clause captures \glspl{fall-through} via single empty \glspl{block}.
%
Let $\mFallThroughSet$ denote a set of pairs~$\mPair{m}{b}$, where $m$ is a
\gls{match} and $b$ is a \gls{block} through which $m$ will fall if selected,
and let $\mMatchSet[\mNull]$ denote the set of \glspl{null match}.
%
With these definitions, the \gls{fall-through} \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{succ}[\mEntry(m)] = b \mOr \mbox{} \\
    \big(
      \mVar{succ}[\mVar{succ}[\mEntry(m)]] = b
      \mAnd
      \mEmptyBlock(\mVar{succ}[\mEntry(m)])
    \big)\hspace{-.8pt}, \\
    \forall \mPair{m}{b} \in \mFallThroughSet,
  \end{array}
  \labelEquation{fall-through}
\end{equation}
%
where
%
\begin{equation*}
  \mEmptyBlock(b)
  \equiv
  \mVar{oplace}[o] \neq b
  \mOr
  \mVar{omatch}[o] \in \mMatchSet[\mNull],
  \forall o \in \mOpSet\hspace{-.8pt}.
\end{equation*}

If a \gls{block}~$b$ has a direct jump to another \gls{block}~$b'$ and $b'$
appears immediately after $b$ in the \gls{block} sequence, then the jump is
redundant.
%
To prevent emission of such jump \glspl{instruction}, we extend the \gls{pattern
  set} with a special \gls!{null-jump pattern}, with \gls{graph} structure
\mbox{$\mEdge{b}{\mEdge{c}{b'}}$}, that covers a \gls{control node}~$c$ at zero
cost provided that \mbox{$\mVar{succ}[b] = b'$}.


\subsection{Branch Extension}

\todo{explain idea}


\subsection{Dual-target Branch Patterns}

\todo{explain idea}


\subsection{Experimental Evaluation}

\todo{insert data}

\todo{discuss data}


\section{Limitations}
\labelSection{cm-limitations}

\todo{write introduction}


\subsubsection{Recomputation}

\todo{discuss limitation}


\subsubsection{Common Subexpression Elimination}

\todo{discuss limitation}


\subsubsection{Implicit Sign/Zero Extensions and Truncations}

\todo{discuss limitation}

% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Constraint Programming}
\labelChapter{constraint-programming}

This chapter describes \glsdesc{CP}, which is the method used in this
dissertation for modeling and solving the problems described in
\refChapter{introduction}.
%
\refSection{cp-overview} gives a brief overview (for a comprehensive overview of
\gls{CP}, see \cite{RossiEtAl:2006}).
%
\refSection{cp-modeling} describes how to describe problems as a \gls{constraint
  model}, and \refSection{cp-solving} describes the techniques applied in
solving these \glsplshort{constraint model}.



\section{Overview}
\labelSection{cp-overview}

As already mentioned, \glsdesc{CP} is a method for solving computationally hard
problems.
%
These problems are typically optimization problems, but the method can also be
applied to solve satisfaction problems.
%
In terms of modeling, \gls{CP} offers a higher level of abstraction than similar
methods such as \gls{IP} and \gls{SAT}~\cite{BiereEtAl:2009}.
%
For example, \gls{CP} provides dedicated constraints for capturing many
recurring problem structures that must be decomposed and reformulated in
\gls{IP} and \gls{SAT}~models.
%
This also makes \gls{CP} particularly suited for solving problems that appear in
\gls{instruction selection}, \gls{global code motion}, and \gls{block ordering}.



\section{Modeling}
\labelSection{cp-modeling}

To solve a problem using \gls{CP}, it must first be formulated as a
\gls{constraint model}.
%
A detailed account on modeling strategies is given by \textcite{Smith:2006}.

A \gls!{constraint model} consists of two elements:%
%
\begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
  \item a set of \glspl{variable}
  \item a set of \glspl{constraint}
\end{inlinelist}.
%
\Glspl!{variable} represent problem decisions and take their values from a
finite \gls{domain}.
%
The \gls!{domain} of a variable~$\mVar{x}$, denoted $\mDomain(\mVar{x})$, is
typically is a set of integers, but it can also consist of real numbers and
complex structures such as string, sets, and \glspl{graph}~\cite{Gervet:2006}.
%
A \gls{variable}~$\mVar{x}$ is \gls!{assigned.v} if
\mbox{$|\!\mDomain(\mVar{x})| = 1$}.
%
\Glspl!{constraint} express relations between \glspl{variable} and forbid
assignments that are illegal in the problem.
%
Formally, we say that a \gls{constraint}~$C$ applied on a set of
\glspl{variable} returns a subset of the Cartesian product of the
\glspl{variable}' \glspl{domain}, i.e.\ \mbox{$C(\mVar{x}_1, \ldots, \mVar{x}_k)
  \subseteq \mDomain(\mVar{x}_1) \times \ldots \times \mDomain(\mVar{x}_k)$}.
%
A tuple $\mTuple{d_1, \ldots, d_k} \in C(\mVar{x}_1, \ldots, \mVar{x}_k)$ is
called a \gls!{solution}[ to $C$], and an assignment to all \glspl{variable}
that fulfills all \glspl{constraint} in a \gls{constraint model}~$M$ is called a
\gls!{solution}[ to $M$].
%
An example is shown in \refFigure{cp-model-example}.

\begin{figure}
  \centering%
  \figureFont\figureFontSize%
  \mbox{}%
  \hfill\hfill%
  \subcaptionbox{Constraint model\labelFigure{cp-model-example-instance}}%
                {%
                  \begin{tabular}{lc}
                    \toprule
                    \multicolumn{1}{c}{\tabhead Variables}
                      & \tabhead Constraints\\
                    \midrule
                      $\mVar{x} \in \mSet{1, 2}$ & $\mVar{x} \neq \mVar{y}$\\
                      $\mVar{y} \in \mSet{1, 2}$ & $\mVar{x} \neq \mVar{z}$\\
                      $\mVar{z} \in \mSet{1, 2, 3, 4}$
                        & $\mVar{y} \neq \mVar{z}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{Solutions\labelFigure{cp-model-example-solutions}}%
                [21mm]%
                {%
                  $\begin{array}{c@{\:}c@{\:}c@{\:}c@{\:}c}
                       & \mVar{x}\phantom{,}
                       & \mVar{y}\phantom{,}
                       & \mVar{z}
                       & \\
                     \langle & 1, & 2, & 3 & \rangle \\
                     \langle & 2, & 1, & 3 & \rangle \\
                     \langle & 1, & 2, & 4 & \rangle \\
                     \langle & 2, & 1, & 4 & \rangle \\
                   \end{array}$%
                }%
  \hfill\hfill%
  \mbox{}

  \caption[Example of a constraint model]%
          {%
            Example of a constraint model, corresponding to a problem where
            three variables must be assigned values which are different from one
            another%
          }
  \labelFigure{cp-model-example}
\end{figure}



\subsubsection{Global Constraints}

If a \gls!{binary.c}[ \gls{constraint}] is a \gls{constraint} involving two
\glspl{variable}, then a \gls!{global.c}[ \gls{constraint}] is a
\gls{constraint} involving three or more
\glspl{variable}~\cite{VanHoeveKatriel:2006}.
%
\Gls{global.c} \glspl{constraint} capture recurring problem structures and
improve solving compared to relations modeled using multiple \gls{binary.c}
\glspl{constraint}.

Arguably, the most well-known \gls{global.c} \gls{constraint} is the
\gls!{distinct constraint}.
%
Typically referred to as $\mDistinct$ or $\mAllDiff$, the \gls{constraint}
enforces all \glspl{variable} in a given set to take distinct values.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Distinct Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mDistinct(\mVar{x}_1, \ldots, \mVar{x}_k)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {\forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                 \forall_{\! i \neq j} \: d_i \neq d_j}.
  \end{displaymath}%
\end{definition}

Hence the \glspl{constraint} in \refFigure{cp-model-example} can be replaced by
$\mDistinct(\mVar{x}, \mVar{y}, \mVar{z})$.

In \refChapter{existing-isel-techniques-and-reps} we saw another \gls{global.c}
\gls{constraint} -- the \gls{global cardinality constraint}, which is a
generalization of the \gls{distinct constraint} -- and how it can be used to
model the \gls{pattern selection} problem (see
\refEquation{pattern-selection-using-gcc}).
%
For completeness, we provide the formal definition of the \gls{constraint}.
%
\begin{definition}[Global Cardinality Constraint]%
  Let $v$ be a value, and let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k, \mVar{y}$}
  be a set of \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mGCC(v, \mVar{x}_1, \ldots, \mVar{x}_k, \mVar{y})
    =
    \mSetBuilder*{\mTuple{d_1, \ldots, d_k, e}}%
                 {
                   \begin{array}{@{}l@{\,}}
                     \forall_i \: d_i \in \mDomain(\mVar{x}_i),
                     e \in \mDomain(\mVar{y}), \\
                     e = |\mSetBuilder{d_i}{\forall_i \: d_i = v}|
                   \end{array}
                 }.
  \end{displaymath}%
  \labelDefinition{gcc}%
\end{definition}

Another relevant example is the \gls!{circuit constraint}, typically referred to
as $\mCircuit$ or $\mCycle$, which enforces that the \glspl{variable}
representing adjacency forms a cycle.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Circuit Constraint]
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable} with
  \glspl{domain} \mbox{$\mDomain(\mVar{x}_i) \subseteq \mSet{1, \ldots, k}$} for
  \mbox{$i = 1, \ldots, k$}.
  %
  Let also a permutation~\mbox{$P = d_1, \ldots, d_k$} of \gls{domain} values be
  considered \emph{cyclic} if the set $S_P$, defined as
  %
  \begin{displaymath}
    \begin{array}{c}
      1 \in S_P,
      i \in S_P \mImp d_i \in S_P,
    \end{array}
  \end{displaymath}
  %
  has $k$ elements.
  %
  Then
  %
  \begin{displaymath}
    \mCircuit(\mVar{x}_1, \ldots, \mVar{x}_k)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \text{$d_1, \ldots, d_k$ is cyclic}
                }.
  \end{displaymath}
\end{definition}

As will be seen in \refChapter{modeling-block-ordering}, $\mCircuit$ can be used
to model \gls{block ordering}.

The last \gls{global.c} \gls{constraint} relevant for this dissertation is the
\gls{table constraint}, which constrains a vector of \glspl{variable} such that
the values appear as a row in a given matrix.
%
By encoding legal \gls{variable} assignments into the matrix, any relation can
be expressed using a \gls{table constraint}.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Table Constraint]
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable}, and
  let $T$ be an \mbox{$m \times k$} matrix, where \mbox{$m \in \mathbb{N}$}.
  %
  Then
  %
  \begin{displaymath}
    \mTable(\mVar{x}_1, \ldots, \mVar{x}_k, T)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\!i } \: d_i \in \mDomain(\mVar{x}_i),
                  d_1, \ldots, d_k \in T
                }.
  \end{displaymath}
\end{definition}

As will be seen in \refChapter{solving-techniques}, $\mTable$ can be used to
refining the modeling of cost.



\subsubsection{Optimization}

In \gls{CP}, an optimization problem is modeled by maximizing or minimizing a
\gls{variable}~$\mVar{c}$ whose value is constrained according to the objective
function.
%
For example, if \mbox{$\mVar{x}_m \in \mSet{0, 1}$} is \gls{variable}
representing whether match~$m$ is selected and $c_m$ denotes the cost of
selecting $m$, then a \gls{CP} idiom for modeling \gls{optimal.ps} \gls{pattern
  selection} is
%
\begin{equation}
  \begin{array}{rl}
      \text{minimize} & \mVar{c} \\
    \text{subject to} & \mVar{c} = \displaystyle\sum_m c_m \mVar{x}_m
  \end{array}
  \labelEquation{pattern-selection-in-cp}
\end{equation}
%
In this context, $\mVar{c}$ is called a \gls!{cost variable}.



\section{Solving}
\labelSection{cp-solving}

A \gls!{constraint solver} (or just \gls!{solver}) finds \glspl{solution} to a
\gls{constraint model} by interleaving \gls{propagation} and \gls{search}.
%
\Gls!{propagation} removes \gls{domain} values that are known not to appear in
any \gls{solution}, and \gls!{search} attempts several alternatives when
\gls{propagation} is not enough to find a \gls{solution}.

In practice, however, this alone is not enough for many problem instances
because the \gls{search space} is simply too large.
%
The \gls{search space} can be reduced by extending the \gls{constraint model}
with \gls{implied.c} and \gls{dominance breaking.c} \glspl{constraint} and by
performing \gls{presolving}.
%
An \gls!{implied.c}[ \gls{constraint}] is a \gls{constraint} that strengthens
propagation without removing any \glspl{solution}.
%
A \gls!{dominance breaking.c}[ \gls{constraint}] is a \gls{constraint} that
removes \glspl{solution} known to be dominated by another \gls{solution}.
%
\Gls!{presolving} applies problem-specific techniques before solving that shrink
the \gls{variable} \glspl{domain}.



\subsubsection{Propagation}

\Gls{propagation} is the process of removing values from the \glspl{variable}'
\glspl{domain}, which is discussed in detail by \textcite{Bessiere:2006}.
%
\Gls{propagation} is also discussed by \textcite{SchulteCarlsson:2006} when
describing how to build \glsdesc{CP} systems.


\Gls{constraint solver} typically keep track of \glspl{variable} and their
\glspl{domain} using \glspl{constraint store}.
%
A \gls!{constraint store} (or just \gls!{store}) is a data structure that maps a
set of \glspl{variable} to sets of \glspl{domain}.
%
A \gls{store}~$S_1$ is \gls!{stronger.cs} than another \gls{store}~$S_2$,
denoted \mbox{$S_1 \mStronger S_2$}, if \mbox{$\mDomain_1(\mVar{x}) \subseteq
  \mDomain_2(\mVar{x})$} for all \glspl{variable}~$\mVar{x}$, where
$\mDomain_i(\mVar{x})$ denotes the domain of \gls{variable}~$\mVar{x}$ in
store~$S_i$.

A function that takes a \gls{constraint store} as input and produces another
\gls{store} is called a \gls!{propagator} (or \gls!{filtering algorithm}).
%
A \gls{propagator} implements a \gls{constraint} if it does not remove any
\glspl{solution} to the \gls{constraint} and only keeps \gls{variable}
assignments that are part of a \gls{solution}.
%
For solving to be well-behaved, \glspl{propagator} are also expected to be
\gls!{decreasing.p} -- it does not add any values, hence \mbox{$p(S) \mStronger
  S$} -- and \gls!{monotonic.p} -- if \mbox{$S_1 \mStronger S_2$}, then
\mbox{$p(S_1) \mStronger p(S_2)$}.
%
A \gls{propagator} for which \mbox{$p(S) = S$} holds is said to be at
\gls!{fixpoint}, and a \gls{store} is at \gls{fixpoint} if all
\glspl{propagator} are at \gls{fixpoint} for that \gls{store}.
%
A \gls{propagator} that returns a \gls{store} with at least one empty
\gls{domain} has \glsshort!{failure}, meaning there are no \glspl{solution} in
this part of the \gls{search space}.

\Glspl{propagator} implementing the same \gls{constraint} can differ in the
amount of propagation they perform.
%
A \gls{propagator} is \glshyphened!{value consistency} if it only propagates
when one of its \glspl{variable} becomes \gls{assigned.v}, \glshyphened!{bounds
  consistency} if it only reduces the bounds of a \gls{domain}, and
\glshyphened!{domain consistency} if it removes all values that do not appear in
any \gls{solution} to the \gls{constraint}.
%
\begin{figure}
  \centering%
  \figureFont\figureFontSize%
  \newcolumntype{C}{>{$}c<{$}}%
  \subcaptionbox{%
                  Solving with value-consistent inequality constraints%
                  \labelFigure{cp-prop-strengths-example-inequality-cons}%
                }{%
                  \begin{tabular}{%
                                   l%
                                   C@{}C@{ }C@{}C%
                                   C@{}C@{ }C@{}C%
                                   C@{}C@{ }C@{ }C@{ }C@{}C%
                                 }
                    \toprule
                      \multicolumn{1}{c}{\tabhead Event}
                        & \multicolumn{14}{c}{\tabhead Store}\\
                      \cmidrule(lr){2-15}%
                        & \multicolumn{4}{c}{$\mVar{x}$}
                        & \multicolumn{4}{c}{$\mVar{y}$}
                        & \multicolumn{6}{c}{$\mVar{z}$}\\
                    \midrule
                      Initial store
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2, & 3, & 4 & \}\\
                      Propagate until fixpoint
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2, & 3, & 4 & \}\\
                      Search by attempting $\mVar{z} = 1$
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ & 1\phantom{,}
                                  &    &    &   & \}\\
                      Propagate $\mVar{y} \neq \mVar{z}$
                        & \{ & 1, & 2  & \}
                        & \{ &    & 2  & \}
                        & \{ & 1\phantom{,}
                                  &    &    &   & \}\\
                      Propagate $\mVar{x} \neq \mVar{z}$
                        & \{ &    & 2  & \}
                        & \{ &    & 2  & \}
                        & \{ & 1\phantom{,}
                                  &    &    &   & \}\\
                      Propagate $\mVar{x} \neq \mVar{y}$
                        & \{ &    &    & \}
                        & \{ &    & 2  & \}
                        & \{ & 1\phantom{,}
                                  &    &    &   & \}\\
                      Failure reached; backtrack
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ &    & 2, & 3, & 4 & \}\\
                      \qquad\raisebox{0pt}[10pt]{$\vdots$}
                        & & & & & & & & & & & & & & \\[-2pt]
                    \bottomrule
                  \end{tabular}%
                }

  \vspace{\betweensubfigures}

  \subcaptionbox{%
                  Solving with domain-consistent distinct constraint%
                  \labelFigure{cp-prop-strengths-example-distinct}%
                }{%
                  \begin{tabular}{%
                                   l%
                                   C@{}C@{ }C@{}C%
                                   C@{}C@{ }C@{}C%
                                   C@{}C@{ }C@{ }C@{ }C@{}C%
                                 }
                    \toprule
                      \multicolumn{1}{c}{\tabhead Event}
                        & \multicolumn{14}{c}{\tabhead Store}\\
                      \cmidrule(lr){2-15}%
                        & \multicolumn{4}{c}{$\mVar{x}$}
                        & \multicolumn{4}{c}{$\mVar{y}$}
                        & \multicolumn{6}{c}{$\mVar{z}$}\\
                    \midrule
                      Initial store
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2, & 3, & 4 & \}\\
                      Propagate $\mDistinct(\mVar{x}, \mVar{y}, \mVar{z})$
                        & \{ & 1, & 2  & \}
                        & \{ & 1, & 2  & \}
                        & \{ &    &    & 3, & 4 & \}\\
                      \qquad\raisebox{0pt}[10pt]{$\vdots$}
                        & & & & & & & & & & & & & & \\[-2pt]
                    \bottomrule
                  \end{tabular}%
                }

  \caption[Example illustrating propagation]%
          {%
            Example illustrating propagation for two versions of the model given
            in \refFigure{cp-model-example}, one using the distinct constraint
            and the other using a binary decomposition%
          }
  \labelFigure{cp-prop-strengths-example}
\end{figure}
%
For example, \refFigure{cp-prop-strengths-example} shows solving of two versions
of the \glsshort{constraint model} given in \refFigure{cp-model-example}, one
using $\mDistinct$ and another using inequality \glspl{constraint}.
%
Because only \gls{value consistency} can be achieved for inequality
\glspl{constraint}, they cannot propagate anything until at least one
\gls{variable} becomes \gls{assigned.v}.
%
As all \glspl{propagator} are already at \gls{fixpoint}, the \gls{solver} must
resort to \gls{search}.
%
In this case, the \gls{solver} makes a wrong guess and is forced to backtrack.
%
In comparison, a \glshyphened{domain consistency} \gls{propagator} for the
\gls{distinct constraint} can remove values~1 and~2 from the \gls{domain} of
\gls{variable}~$\mVar{z}$ as these values do not appear in any \glspl{solution}
(see \refFigure{cp-model-example-solutions}).
%
Maximizing \gls{propagation} is key in making solving tractable, as the
\gls{search space} grows exponentially with the number of \glspl{variable} and
size of the \glspl{domain}.

As to be expected, stronger propagation comes at a price of greater complexity.
%
For the \gls{distinct constraint}, there exist \glsshort{bounds consistency} and
\glshyphened{domain consistency} \glspl{propagator} with worst-case time
complexities~$\mBigO(n \log n)$~\cite{Lopez-OrtizEtAl:2003}
and~$\mBigO(n^{2.5})$~\cite{Regin:1994}, respectively, where $n$ denotes the
number of \glspl{variable}.
%
The same can be achieved for the \gls{global cardinality constraint} at similar
cost~\cite{QuimperEtAl:2005, Regin:1996}.

Many \glshyphened{domain consistency} \gls{propagator} exist for the \gls{table
  constraint} \cite{LecoutreSzymanek:2006, Lecoutre:2011, MairyEtAl:2014,
  PerezRegin:2014, LecoutreEtAl:2015, DemeulenaereEtAl:2016}, although these
exhibit worst-case time complexity.
%
\Gls{domain consistency} for \gls{circuit constraint} cannot be achieved in
polynomial time as it involves finding Hamiltonian cycles, which is an
NP-complete problem~\cite{GareyJohnson:1979}, although an incomplete
polynomial-time \gls{filtering algorithm} is given in~\cite{KayaHooker:2006}.



\subsubsection{Search}

When no more \gls{propagation} can be performed -- that is, when all
\glspl{propagator} are at \gls{fixpoint} -- the \gls{solver} resorts to
\gls{search}.
%
A detailed account on \gls{search} is given by \textcite{VanBeek:2006}.



\todo{explain search}

\Glspl{solution} to optimization problems are found using a method called
\gls!{branch and bound}.
%
During \gls{search}, the best \gls{solution} found so far is kept and a
\gls{constraint} is added to enforce all subsequent \glspl{solution} to have
strictly less (or greater) cost.
%
When the entire \gls{search space} has been explored, the last found
\gls{solution} is guaranteed to be optimal.



\subsubsection{Implied and Dominance Breaking Constraints}

\todo{write}



\subsubsection{Presolving}

\todo{write}

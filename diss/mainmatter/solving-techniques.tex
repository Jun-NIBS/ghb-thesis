% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Solving Techniques}
\labelChapter{solving-techniques}

\todo{write chapter overview}

\todo{state clearly Mats' contribution}


\section{Refined Define-Before-Use Constraint}
\labelSection{st-refined-def-before-use-constraint}

% Enforce that every datum is defined in a block such that the block dominates
% all blocks wherein the datum is used. This constraint shall not be applied to
% the generic phi patterns, nor to null instructions.
%
% This used to be enforced by the following constraint:
%   constraint
%     forall ( m in allMatches
%            , o in operandsUsedByMatch[m]
%              where not (m in phiInstrMatches)
%            )
%     ( dplace[alt[o]] in domSetsOfBlocksInFunction[place[m]] );
% but it has been reformulated using table constraints to avoid the use of set
% variables.
%
% [MC] Assumes that matches which use some data cover at least one operation.
% [GHB] This assumption should always hold.
%
%constraint
%  forall (p in nonPhiUseOperands)
%  ( table([uplace[p], dplace[Alt(p)]], domRelMatrix) );
%
%constraint
%  forall (p in allOperands diff nonPhiUseOperands)
%  ( uplace[p] = 1 );
%
%constraint
%  forall ( m in allMatches diff phiInstrMatches
%         , p in operandsUsedByMatch[m]
%         )
%  ( not sel[m] -> uplace[p] = dplace[Alt(p)] );
%
%constraint
%  forall ( m in allMatches diff phiInstrMatches
%         , o in operandsUsedByMatch[m]
%         , c in operationsCoveredByMatch[m]
%         )
%  ( sel[m] -> oplace[c] = uplace[o] );

\todo{write}


\section{Refined Kill Constraint}
\labelSection{st-refined-kill-constraint}

% If a datum d is used by at least one operand in at least one selected match,
% then d must not be defined by any kill match.  Otherwise, d must be
% defined by an kill match.
% constraint
%   forall ( mi in killInstrMatches
%          , oi in operandsDefinedByMatch[mi]
%          , d in operandAlternatives[oi]
%          )
%   ( exists ( m in allMatches
%            , o in operandsUsedByMatch[m]
%              where d in operandAlternatives[o]
%            )
%     ( sel[m] /\ alt[o] = d )
%     <->
%     not sel[mi]
%   );
%
% [MC 1]
% If and only if a datum d is used by at least one operand in at least
% one selected match, then d must not be defined by any kill
% match.  If and only if d is used by at least one external operand in
% at least one selected match, then d must not placed in the null
% location.
%
%constraint
%  forall ( mi in killInstrMatches
%         , oi in operandsDefinedByMatch[mi]
%         , d in operandAlternatives[oi]
%         )
%  ( let { var bool: ui,
%          var bool: ue } in
%    ( ui <-> exists ( m in allMatches
%                    , o in operandsUsedByMatch[m] intersect
%                           operandsInternalToMatch[m]
%                    where d in operandAlternatives[o]
%                    )
%             ( sel[m] /\ alt[o] = d ) ) /\
%    ( ue <-> exists ( m in allMatches
%                    , o in operandsUsedByMatch[m] intersect
%                           operandsExternalToMatch[m]
%                    where d in operandAlternatives[o]
%                    )
%             ( sel[m] /\ alt[o] = d ) ) /\
%    ( sel[mi] <-> not ui /\ not ue ) /\
%    ( loc[d] != locValueForNull <-> ue )
%  );

\todo{write}


\section{Refined Objective Function}
\labelSection{st-refined-objective-function}

As stated in \refChapter{constraint-model},
\refEquation{naive-objective-function} is a naive implementation of the
\gls{objective function} that offers poor \gls{propagation}.
%
This is because it fails to reason on how cost is distributed across the
\glspl{operation} that need to be covered.
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{UF graph\labelFigure{cost-example-graph}}%
                {%
                  \input{figures/solving-techniques/cost-example-graph}%
                }%
  \hfill%
  \subcaptionbox{Cost matrix\labelFigure{cost-example-matrix}}%
                {%
                  \figureFontSize%
                  \begin{minipage}{50mm}%
                    \centering%
                    \begin{displaymath}
                      \begin{adjblockarray}{cccccc}{1ex}
                          \text{\tabhead op}
                        & \text{\tabhead match}
                        & \text{\tabhead block}
                        & \multicolumn{3}{c}{%
                            \text{%
                              \parbox{20.5mm}{%
                                % The parbox is used to create a bit of space
                                % between the content and the right bracket
                                \centering\tabhead opcost%
                              }%
                            }%
                          } \\[-.5ex]
                        \begin{block}{[cccc@{\;\times\;}c@{\;=\;}c]}
                          \rule{0pt}{2.5ex}
                          o_1 & m_1 & b_1 & 4 & 10 & 40 \\
                          o_1 & m_1 & b_2 & 4 &  1 &  4 \\
                          o_1 & m_3 & b_1 & 3 & 10 & 30 \\
                          o_1 & m_3 & b_2 & 3 &  1 &  3 \\
                          o_2 & m_2 & b_1 & 1 & 10 & 10 \\
                          o_2 & m_2 & b_2 & 1 &  1 &  1 \\
                          o_2 & m_3 & b_1 & 2 & 10 & 20 \\
                          o_2 & m_3 & b_2 & 2 &  1 &  2 \\[.55ex]
                        \end{block}
                      \end{adjblockarray}
                    \end{displaymath}
                  \end{minipage}%
                }%
  \hfill%
  \mbox{}

  \caption[Example illustrating match cost distributed over operations]%
          {%
            Example illustrating match cost distributed over operations.
            %
            It is assumed that matches~$m_1$, $m_2$, and~$m_3$ have costs~4,
            1, and~5, respectively, and that they can be placed in one of two
            blocks, $b_1$ and $b_2$, with execution frequencies~10 and~1,
            respectively.
            %
            The cost of $m_3$ distributed over $o_1$ and $o_2$ is~3 and~2,
            respectively%
          }
  \labelFigure{cost-example}
\end{figure}
%
See for example \refFigure{cost-example}.
%
Assume a \gls{UF graph} that can be covered by three \glspl{match} -- $m_1$,
$m_2$, and~$m_3$ -- which have costs~4, 1, and~5, respectively, and that they
can be placed in one of two blocks, $b_1$ and $b_2$, with execution
frequencies~10 and~1, respectively (\refFigure{cost-example-graph}).
%
Because \refEquation{naive-objective-function} is modeled as a summation, it can
only propagate the bounds of the \gls{cost variable}.
%
Consequently, for any \glspl{match} where their $\mVar{sel}$~\gls{variable} have
yet to be decided, either all those \glspl{match} are selected and placed in the
\gls{block} with highest execution frequency, or none are selected.
%
In the example above, this means the \gls{cost variable} is initially bounded as
\mbox{$0 < \mVar{cost} < 100$}, which are very weak bounds as we know that the
\gls{UF graph} must at least be covered at a cost of~5 (either both $m_1$ and
$m_2$ are selected and placed in $b_2$, or $m_3$ is selected and placed in
$b_2$) and can at most be covered at a cost of~50 (the selected \glspl{match}
are placed in $b_1$).

Instead of reasoning about the cost incurred by the \glspl{match} -- which may
or may not be selected -- a better approach is to infer the cost incurred on the
\glspl{operation} since these must always be covered.
%
The idea is as follows.
%
First, for each \gls{match}~$m$, evenly divide the cost of $m$ over each
\gls{operation}~$o$ covered by $m$.
%
Let \mbox{$\mOpCost(m, o) \in \mNatNumSet$} denote this cost such that
\mbox{$\sum_{o \in \mCovers(m)} \mOpCost(m, o) = \mCost(m)$} holds for every
\gls{match}~$m$.\!%
%
\footnote{%
  \setlength{\abovedisplayskip}{1ex}%
  \setlength{\belowdisplayskip}{1ex}%
  %
  If a strict partial order $<$ exists over the set of \glspl{operation}, and
  $\mCovers(m)$ returns an ordered, 1-indexed list for which \mbox{$o_1 < o_2 <
    \cdots < o_k$} holds, then the cost can be divided as follows.
  %
  Given a match~$m$, let \mbox{$q = \lfloor \mCost(m) / \mCard{\!\mCovers(m)}
    \rfloor$} and \mbox{$r = \mCost(m) \! \mod \mCard{\!\mCovers(m)}$}.
  %
  Then
  %
  \begin{displaymath}
    \mOpCost(m, o) =
    \left\{
    \begin{array}{ll}
      q + 1 & \text{if $o < \mCovers(m)[r+1]$}, \\
      q     & \text{otherwise}. \\
    \end{array}
    \right.
  \end{displaymath}
}
%
Then, for each \gls{block}~$b$, weigh \mbox{$\mOpCost(m, o)$} with the execution
frequency of~$b$.
%
This information can be represented as a cost matrix
%
\begin{equation}
  \begin{bmatrix}
    \begin{array}{@{\:}c|c@{\:}}
        o, m, b, \big( \mOpCost(m, o) \times \mFreq(b) \big)
      & m \in \mMatchSet, o \in \mCovers(m), b \in \mBlockSet
    \end{array}
  \end{bmatrix}
  \labelEquation{cost-matrix}
\end{equation}
where each row denotes the cost of an \gls{operation}~$o$ if covered by a
\gls{match}~$m$ and placed in a \gls{block}~$b$.
%
An example of this cost matrix is given in \refFigure{cost-example}, from which
we can deduce that the cost of covering operations~$o_1$ and~$o_2$ is between~3
and~40 respectively between~1 and~20 (\refFigure{cost-example-matrix}).
%
Hence the total cost can be bounded as \mbox{$4 < \mVar{cost} < 60$}, which is a
much tighter bound compared to that achieved using the naive \gls{objective
  function}.
%
This in turn has a tremendous impact on solving time, for reasons that will
become clear in \refSection{st-cost-bounds}.\!%
%
\footnote{%
  For the experiments in \cite{HjortBlindellEtAl:2017:CASES}, the refined
  \gls{objective function} was actually implemented as \emph{first} multiply the
  \gls{match} cost with the execution frequency, and \emph{then} evenly divide
  the product over the covered \glspl{operation}.
  %
  While this scheme also greatly reduces solving time compared to the naive
  \gls{objective function}, it proves to be significantly inferior to dividing
  the cost as in \refEquation{cost-matrix}.
  %
  One possible explanation is that it may result in weaker bounds -- for the
  example given in \refFigure{cost-example}, using this scheme bounds the total
  cost as \mbox{$4 < \mVar{cost} < 65$} -- but this does not apply for every
  case.
  %
  Hence the intuition behind why it is better to first divide the \gls{match}
  cost and then multiply the execution frequency remains unclear, thus
  underscoring the fact that seemingly trivial changes to a \gls{constraint
    model} may have considerable impact.%
}


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{ocost}[o] \in \mNatNumSet$} models the
cost incurred by covering operation~$o$\hspace{-.8pt}.
%
It is assumed the \gls{domain} is the same as for the \gls{cost variable}.


\subsubsection{Constraints}

For each \gls{operation}~$o$\hspace{-.8pt}, the combination
\mbox{$o\hspace{-.8pt}, \mVar{omatch}[o], \mVar{oplace}[o], \mVar{ocost}[o]$}
must appear as a row in the cost matrix.
%
Hence, given a cost matrix~$\mCostMatrix$ this \gls{constraint} is modeled as
%
\begin{equation}
  \mTable\left(
    o\hspace{-1pt},
    \mVar{omatch}[o],
    \mVar{oplace}[o],
    \mVar{ocost}[o],
    \mCostMatrix
  \right)\!,
  \forall o \in \mOpSet \hspace{-.8pt}.
  \labelEquation{omatch-oplace-ocost-connection}
\end{equation}
%
The total cost is then modeled as
%
\begin{equation}
  \mVar{cost} = \sum_{o \in \mOpSet} \mVar{ocost}[o].
  \labelEquation{total-cost}
\end{equation}


\section{Tightening the Cost Bounds}
\labelSection{st-cost-bounds}

As explained in \refChapter{constraint-programming}, in \gls{CP} optimization
problems are solved using \gls{branch and bound}.
%
In other words, when a \gls{solution} is found a \gls{constraint} is added to
the \glsshort{constraint model}, forcing any subsequently found \glspl{solution}
to be strictly better.
%
This means that if a part of the \gls{search space} is known not to contain any
better \glspl{solution} -- this is achieved by checking the current lower bound
of the \gls{cost variable} -- then this part need not be explored during
\gls{search}.
%
For this to be effective, however, it must be possible to infer reasonable
bounds on the \gls{cost variable}, which asserts the need for the refined
\gls{objective function} introduced in
\refSection{st-refined-objective-function}.

By the same mechanism, solving can improved by tightening the lower and upper
bounds of the \gls{cost variable} before commencing \gls{search}.
%
A tight upper bound helps the \gls{constraint solver} to prune away parts of the
\gls{search space} that contains inferior \glspl{solution}, while a tight lower
bound helps the \gls{constraint solver} to prune away parts of the \gls{search
  space} that contains no \glspl{solution}.
%
A decent upper bound can be computed by solving the same problem using a greedy
but fast heuristic.
%
To this end, any modern \gls{compiler} can be used.
%
A decent lower bound be computed by solving a relaxed version of the
\gls{constraint model} that only models the \gls{global.is} \gls{instruction
  selection} and \gls{block ordering} problems, which obviously is simpler to
solve than the complete \glsshort{constraint model}.
%
Hence, the relaxed \glsshort{constraint model} consists of only the
$\mVar{omatch}$, $\mVar{opcosts}$, $\mVar{sel}$, $\mVar{succ}$, and
$\mVar{cost}$ variables, \refEquation{operation-coverage}, relaxed versions of
Eqs.\thinspace\refEquation*{block-order} and \refEquation*{fall-through} that
allow fall-throughs via non-empty \glspl{block}, and modified versions of
Eqs.\thinspace\refEquation*{cost-matrix}--\refEquation*{total-cost} that do not
take the execution frequencies into account.

If $\mRelaxedCost$ and $\mHeuristicCost$ denote the cost computed from the
relaxation and by the heuristic, respectively, then the \gls{cost variable} is
bounded as
%
\begin{equation}
  \mRelaxedCost \leq \mVar{cost} < \mHeuristicCost.
  \labelEquation{lower-bound}
\end{equation}


\section{Branching Strategies}
\labelSection{st-branching-strategies}

\todo{mention mimicking of maximum munch}

\todo{first branch on the $\mVar{ocost}$ variables}

\todo{then branch on the block order}


\section{Implied Constraints}
\labelSection{st-impl-constraints}

\todo{mention that \refEquation{pattern-selection-using-gcc} did not give for
  our model}


\subsubsection{TODO: rename (non-phi stuff)}

\todo{describe constraint}

% If all matches covering a non-phi-operation o do not span any blocks, use
% datum u, and define datum d, then the block defining u must dominate the block
% defining d, and o must be placed in the block defining d.

\begin{equation}
  \begin{array}{c}
    \mTable(\mVar{dplace}[d], \mVar{dplace}[e], \mDomMatrix)
    \mAnd
    \mVar{oplace}[o] = \mVar{dplace}[d], \\
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    o' \in \mOpCompSet{\mPhi},
                    m \in \mMatchSet[o'] \hspace{-1pt},
                    \mCard{\mConsumes(m)} = 0
                  }, \\
    \forall d \in
      \mSetBuilder{d'}%
                  {%
                    d' \in \mDataOf(o \hspace{-1pt}, \mDefines),
                    m \in \mMatchSet[o] \hspace{-1pt},
                    \exists p \in \mDefines(m),
                    \mDataSet[p] = \mSet{d'}
                  }, \\
    \forall e \in
      \mSetBuilder{e'}%
                  {%
                    e' \in \mDataOf(o \hspace{-1pt}, \mUses),
                    m \in \mMatchSet[o] \hspace{-1pt},
                    \exists p \in \mUses(m),
                    \mDataSet[p] = \mSet{e'}
                  }.
  \end{array}
  \labelEquation{todo}
\end{equation}
%
where
%
\begin{equation}
  \mDataOf(o \hspace{-1pt}, f) =
  \mSetBuilder{\mDataSet[p]}%
              {%
                m \in \mMatchSet[o] \hspace{-1pt},
                p \in f\hspace{-1pt}(m),
                \mCard{\mCovers(m)} = 1
              }
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% If all matches in the matchset covering a particular non-phi-operation have
% identical entry blocks, then the block defining d must dominate the entry
% block.

\begin{equation}
  \begin{array}{c}
    \mVar{oplace}[o] = b \hspace{-.8pt}, \\
    \forall b \in \mBlockSet \hspace{-1pt},
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    o' \in \mOpCompSet{\mPhi},
                    m \in \mMatchSet[o'] \hspace{-1pt},
                    \mEntry(m) = \mSet{b}
                  }.
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% If all matches in the matchset covering a particular non-phi-operation have
% identical spanned blocks and define datum d, then d must be placed in a
% spanned block.

\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in S \hspace{-.8pt}, \\
    \forall S \in \mPowerset{\mBlockSet} \!\!,
    \forall d \in \mDataSet \!,
    \forall o \in
      \mSetBuilder*{o'}%
                   {%
                     \begin{array}{@{}l@{}}
                       o' \in \mOpCompSet{\mPhi},
                       m \in \mMatchSet[o'] \hspace{-1pt},
                       \exists p \in \mDefines(m), \\
                       \mSpans(m) = S \mAnd \mDataSet[p] = \mSet{d}
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% If all matches in the matchset covering a non-phi-particular operation have
% identical entry blocks and use datum d, then the block defining d must
% dominate the entry block.

\begin{equation}
  \begin{array}{c}
    \mTable(b \hspace{-.8pt}, \mVar{dplace}[d], \mDomMatrix), \\
    \forall b \in \mBlockSet \hspace{-1pt},
    \forall d \in
      \mSetBuilder*{d'}%
                   {%
                     \begin{array}{@{}l@{}}
                       d' \in \mOpCompSet{\mPhi},
                       m \in \mMatchSet[d'] \hspace{-1pt},
                       \exists p \in \mUses(m), \\
                       \mEntry(m) = \mSet{b}
                       \mAnd \mDataSet[p] = \mSet{d}
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}

\subsubsection{TODO: rename (phi stuff)}

\todo{describe constraint}

% If all matches for an operation o are all phi instructions and have the same
% def operand, then the def operand as well as o itself must all be placed in
% the block mentioned in the output def edge.

\begin{equation}
  \begin{array}{c}
    \mVar{oplace}[o] = b \hspace{-.8pt}, \\
    \forall \mEdge{d}{b} \in \mDefEdgeSet,
    \forall o \in
      \mSetBuilder*{o'}%
                   {%
                     \begin{array}{@{}l@{}}
                       o' \in \mOpSet[\mPhi] \hspace{-1pt},
                       m \in \mMatchSet[o'] \hspace{-1pt},
                       p \in \mDefines(m), \\
                       m \in \mPhiMatchSet \mAnd \mDataSet[p] = \mSet{d}
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}
%
It is assumed that the \glspl{edge} in $\mDefEdgeSet$ have been reoriented such
that all \glspl{source} are either \glsshort{state node} or \glspl{value node}
and all \glspl{target} are \glspl{block node}.


\subsubsection{TODO: rename (?)}

\todo{describe constraint}

% For non-phi matches, no spanned blocks:
% if selected, blocks of outputs and blocks of use of inputs must be all equal.

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{uplace}[p] = \mVar{uplace}[q], \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  },
    \forall p \hspace{-.8pt}, q \in \mUses(m) \setminus \mDefines(m),
    p < q \hspace{-.8pt},
  \end{array}
  \labelEquation{todo}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\mVar{alt}[p]] = \mVar{dplace}[\mVar{alt}[q]], \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  },
    \forall p \hspace{-.8pt}, q \in \mDefines(m), p < q \hspace{-.8pt},
  \end{array}
  \labelEquation{todo}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{uplace}[p] = \mVar{dplace}[\mVar{alt}[q]], \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  }, \\
    \forall p \in \mUses(m) \setminus \mDefines(m),
    \forall q \in \mDefines(m).
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% For non-phi matches, spanned blocks:
% if selected, blocks of use of inputs must be all equal.

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{uplace}[p] = \mVar{uplace}[q], \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) \neq \mEmptySet
                  },
    \forall p \hspace{-.8pt}, q \in \mUses(m) \setminus \mDefines(m),
    p < q \hspace{-.8pt}.
  \end{array}
  \labelEquation{todo}
\end{equation}


\subsubsection{TODO: rename (loc stuff)}

\todo{describe constraint}

% If all matches in the matchset covering a particular operation uses some
% datum d as input, then d cannot be placed in the null location.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] \neq \mNullLocation, \\
    \forall S \in \mPowerset{\mStateDataCompSet} \hspace{-2pt},
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    o' \in \mOpSet \!,
                    m \in \mMatchSet[o'] \hspace{-1pt},
                    \exists p \in \mUses(m) \setminus \mDefines(m),
                    \mDataSet[p] = S
                  }, \\
    \exists d \in S.
  \end{array}
  \labelEquation{todo}
\end{equation}

Requires \mbox{$\mStores(m, d)$} of kill matches to allow null location.

\todo{describe constraint}

% [MC 3]
%
% If all matches in the matchset that defines a non-state datum d, are active,
% and define it in an external operand, then d must not be placed in the null
% location.
%
% [MC 3] does not dominate [MC 2], nor vice versa.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] \neq \mNullLocation, \\
    \forall d \in
      \mSetBuilder*{d'}%
                   {%
                     \begin{array}{@{}l@{}}
                       d' \in \mStateDataCompSet,
                       m \in \mMatchSet[d'] \hspace{-1pt},
                       \exists p \in \mDefines(m), \\
                       m \notin \mKillMatchSet
                       \mAnd
                       \mDataSet[p] = \mSet{d'}
                       \mAnd
                       \mNullLocation \notin \mStores(m, p)
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}


\subsubsection{TODO: rename (fall-through stuff)}

\todo{describe constraint}

% If for any two given blocks p and q, and fallThroughBlockOfMatch contains
% [_, p, q] but does not contain [_, p, q'] or [_, p', q], then succ[p] = q can
% only help, never hurt.

\begin{equation}
  \begin{array}{c}
    \mVar{succ}[b] = c, \\
    \forall b \hspace{-1pt}, c \in \mBlockSet \hspace{-1pt},
    \mSetBuilder{\mEntry(m)}{\mPair{m}{c} \in \mFallThroughSet} = \mSet{b}
    \mAnd
    \mSetBuilder{m}{\mPair{m}{b} \in \mFallThroughSet} = \mEmptySet.
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}


\subsubsection{TODO: remove?}

% Constrain the location of d to be where its definers can put it.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] = S, \\
    \forall d \in \mStateDataCompSet,
    \forall S \in
      \mPowerset{\mLocationSet \, \cup \, \mSet{\mNullLocation}} \!, \\
    S = \mSetBuilder{l}%
                    {%
                      m \in \mDataSet[d] \setminus \mKillMatchSet,
                      p \in \mDefines(m),
                      l \in \mStores(m, p),
                      d \in \mDataSet[p]
                    },
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% Disable users of input data that would access it elsewhere to where its
% definers can put them.

\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m], \\
    \forall m \in
      \mSetBuilder*{m'}%
                   {%
                     \begin{array}{@{}l@{}}
                       m' \in \mKillMatchCompSet,
                       p \in \mUses(m') \setminus \mDefines(m'),
                       d \in \mDataSet[p] \hspace{-1pt}, \\
                       \mStores(m, p) \cap \mDefLocsOf(d) = \mEmptySet
                     \end{array}
                   } \!,
  \end{array}
\end{equation}
%
where
%
\begin{equation}
  \mDefLocsOf(d)
  =
  \mSetBuilder{l}%
              {%
                m \in \mMatchSet[d] \setminus \mKillMatchSet,
                p \in \mDefines(m),
                l \in \mStores(m, p),
                d \in \mDataSet[p]
              }.
\end{equation}

\todo{describe constraint}

% Constrain the location of d to be where its users can access it. Valid for
% such d that are used at least once.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] = S, \\
    \forall d \in \mDataUsedOnceSet,
    \forall S \in
      \mPowerset{\mLocationSet \, \cup \, \mSet{\mNullLocation}} \!, \\
    S = \mSetBuilder{l}%
                    {%
                      m \in \mKillMatchCompSet,
                      p \in \mUses(m),
                      l \in \mStores(m, p),
                      d \in \mDataSet[p]
                    },
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% Disable definers of output data that would put it elsewhere to where its
% users can access them. Valid for data that are used at least once.

\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m], \\
    \forall m \in
      \mSetBuilder*{m'}%
                   {%
                     \begin{array}{@{}l@{}}
                       m' \in \mKillMatchCompSet,
                       p \in \mDefines(m'),
                       d \in \mDataSet[p] \hspace{-1pt}, \\
                       \mNullLocation \notin \mStores(m, p)
                       \mAnd
                       \mStores(m, p) \cap \mUseLocsOf(d) = \mEmptySet
                     \end{array}
                   } \!,
  \end{array}
\end{equation}
%
where
%
\begin{equation}
  \mUseLocsOf(d)
  =
  \mSetBuilder{l}%
              {%
                m \in \mKillMatchCompSet,
                p \in \mUses(m),
                l \in \mStores(m, p),
                d \in \mDataSet[p]
              }.
\end{equation}


\section{Symmetry and Dominance Breaking Constraints}
\labelSection{st-dom-breaking-constraints}

\todo{write intro}


\subsubsection{Location of State Nodes}

Since \glspl{datum} also includes the \glspl{state node}, this means a
$\mVar{loc}$~\gls{variable} will be allocated for each individual \gls{state
  node}.
%
However, since \glspl{state node} are abstract entities used only to capture
implicit dependencies between certain \gls{operation}, the assignment to these
\glspl{variable} has no actual bearing on the \gls{solution}, thus giving rise
to many symmetric \glspl{solution}.
%
Consequently, it makes sense to fix the location for each \gls{state node},
which is modeled as
%
\begin{equation}
  \mVar{loc}[d] = \mNullLocation,
  \forall d \in \mStateDataSet,
  \labelEquation{loc-of-state-nodes}
\end{equation}
%
where \mbox{$\mStateDataSet \subseteq \mDataSet$} denotes the set of
\glspl{state node}.


\subsubsection{Data of Non-Selected Matches}

The $\mVar{alt}$~\glspl{variable} of \glspl{match} that are not selected still
need to be assigned a value.
%
Since this assignment does not matter for the \gls{solution}, it gives rise to
many symmetric \glspl{solution}.
%
We therefore fix the $\mVar{alt}$ assignments in such cases, which is modeled as
%
\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m] \mImp \mVar{alt}[p] = \mMin(\mDataSet[\hspace{-1pt}p]), \\
    \forall m \in \mMatchSet,
    \forall p \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{operands-of-non-selected-matches}
\end{equation}

\todo{explain implied constraint below}

% If an external operand does not take its min value, then its match must be
% selected and hence the datum cannot be in the null location.

\begin{equation}
  \begin{array}{c}
    \mVar{alt}[p] \neq \mMin(\mDataSet[p])
    \mImp
    \mVar{alt}[p] \neq \mNullLocation, \\
    \forall m \in \mMatchSet,
    \forall p \in \mUses(m) \setminus \mDefines(m),
    \mCard{\mDataSet[p]} > 1
  \end{array}
  \labelEquation{todo}
\end{equation}


\subsubsection{Interchangeable Data}

As described in \refSection{modeling-value-reuse}, \glspl{datum} in the \gls{UF
  graph} that are copies of the same value are \gls{copy-related.d} and
therefore interchangeable.
%
\begin{figure}
  \begin{minipage}[b]{58mm}%
    \centering%
    \subcaptionbox{%
                    UF graph, where the values \irVar{v}[1] and \irVar{v}[2]
                    constitute a chain of interchangeable data%
                    \labelFigure{interchangeable-data-example-annotated-graph}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-annotated-graph%
                    }%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Symmetries due to how data can be connected to operands%
                    \labelFigure{interchangeable-data-example-alt-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-alt-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-alt-2%
                    }%
                  }%
  \end{minipage}%
  \hfill%
  \begin{minipage}[b]{58mm}%
    \centering%
    \subcaptionbox{%
                    Symmetries due to how null-copy matches can be selected%
                    \labelFigure{interchangeable-data-example-null-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-null-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-null-2%
                    }%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Symmetries due to how kill matches can be selected%
                    \labelFigure{interchangeable-data-example-kill-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-kill-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-kill-2%
                    }%
                  }%
  \end{minipage}

  \caption[Example of interchangeable data]%
          {%
            Example of interchangeable data and how these give rise to
            symmetries%
          }
  \labelFigure{interchangeable-data-example}
\end{figure}
%
This is another source for symmetric \glspl{solution}, which is illustrated in
\refFigure{interchangeable-data-example}.

Assume a \gls{UF graph} containing two \gls{copy-related.d} values, \irVar{v}[1]
and~\irVar{v}[2], that may both be connected to two \glspl{operand}~$p_1$
and~$p_2$ (\refFigure{interchangeable-data-example-annotated-graph}).
%
We say that a set of values constitute a chain of \gls!{interchangeable.d} if
they can be swapped in a \gls{solution} without affecting the \gls{program}
semantics, which is the case if the values are all \gls{copy-related.d} and none
is both \gls{define.d}[d] and \gls{use.d}[d] by some \gls{match}.
%
In the above example, \irVar{v}[1] and~\irVar{v}[2] constitute such a chain and
can therefore be swapped for $p_1$ and~$p_2$, giving rise to unwanted symmetric
\glspl{solution} (\refFigure{interchangeable-data-example-alt-solutions}).
%
The intuition here is to forbid \glspl{solution} containing ``cross-over''
connections between the values in a chain and the $\mVar{alt}$~\glspl{variable}.
%
As a precaution, however, we will exclude \glspl{operand} used by
\glspl{phi-match} due to the \gls{definition edge} which may require such
cross-over connections.

If we assume that there exists a partial order $\leq$ for~$\mDataSet$, then we
can remove these symmetries using the \gls!{value-precede-chain constraint},
which requires a sequence of \glspl{variable} to be sorted according to a given
chain of values.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Value-Precede-Chain Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a permutation of
  \glspl{variable}.
  %
  Let also $c$ be a 1-indexed sequence with $n$ elements.
  %
  Then
  %
  \begin{displaymath}
    \mValuePrecChain(c, \mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \bigcap_{1 \leq i < n}
    \mValuePrec(c[i], c[i+1], \mVar{x}[1], \ldots \mVar{x}[k]),
  \end{displaymath}
  %
  where
  \begin{displaymath}
    \mValuePrec(s, t, \mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \forall_{\! i} \: d_i = t
                  \mImp \exists_{j} \: j < i \mAnd d_j = s
                }.
  \end{displaymath}
\end{definition}
%
For example, \mbox{$\mValuePrecChain(\langle 6, 5, 4 \rangle, \mVar{x}_1 \in
  \mSet{6}, \mVar{x}_2 \in \mSet{1}, \mVar{x}_3 \in \mSet{5}, \mVar{x}_4 \in
  \mSet{4})$} holds because the~4 is preceded by a~5, which in turn is preceded
by a~6, in the permutation of $\mVar{x}$~\glspl{variable}.
%
Likewise, \mbox{$\mValuePrecChain(\langle 5, 4 \rangle, \mVar{x}_1 \in \mSet{5},
  \mVar{x}_2 \in \mSet{1})$} also holds because 4 does not appear among the
$\mVar{x}$~\glspl{variable} (the fact that 5 appears in the permutation does
not matter).
%
However, \mbox{$\mValuePrecChain(\langle 5, 4 \rangle, \mVar{x}_1 \in \mSet{1},
  \mVar{x}_2 \in \mSet{4})$} does not hold because the~4 is not preceded by a~5.

Hence, if $\mInterchDataSet$ denotes the set of chains of
\gls{interchangeable.d} \glspl{datum} and \mbox{$\mOperandSet[\mPhi] \subseteq
  \mOperandSet$} denotes the set of \glspl{operand} used by \glspl{phi-match},
then the \gls{symmetry breaking.c} \gls{constraint} described above is modeled
as
%
\begin{equation}
  \begin{array}{c}
    \mValuePrecChain(c, \mVar{alt}[p_1], \ldots, \mVar{alt}[p_k]), \\
    \forall c \in \mInterchDataSet,
    \forall p_1, \ldots, p_k \in \mOperandSet \setminus \mOperandSet[\mPhi],
    p_1 \neq \cdots \neq p_k
    \mAnd
    \forall_{\! i} \: \mDataSet[p_i] \! = c.
  \end{array}
  \labelEquation{interchangeable-data-chain-precedence}
\end{equation}

Additional symmetries may appear due to \glspl{null-copy match}.
%
Returning to the previous example, if one of the two \glspl{copy node} need to
be covered using a \gls{copy match} derived from actual copy \gls{instruction},
then we are free to decide which.
%
Intuitively, we want to forbid \glspl{solution} where selected \glspl{null-copy
  match} ``appear to the left'' of a non-\gls{null-copy match}.
%
To this end, we make use of the \gls!{increasing constraint}, which requires a
sequence of \glspl{variable} to be assigned values in a non-strictly increasing
order.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Increasing Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a permutation of
  \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mIncreasing(\mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \forall_{\! i < k} \: d_i \leq d_{i+1}
                }.
  \end{displaymath}
\end{definition}
%
Let $\mInterchDataSet[\mCopy]$ denote the set of chains of \glspl{datum} that
can only be defined by \glspl{copy match}, \mbox{$\mNullCopyMatchSet \subseteq
  \mMatchSet$} denote the set of \glspl{null-copy match}, and
\mbox{$\mMatchSet[d] \subseteq \mMatchSet$} denote the set of \glspl{match} that
can define a \gls{datum}~$d$.
%
Using these definitions, this \gls{symmetry breaking.c} \glspl{constraint} is
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mIncreasing(\mVar{sel}[m_1], \ldots, \mVar{sel}[m_k]), \\
    \forall c \in \mInterchDataSet[\mCopy],
    \forall 1 \leq i < k,
    \exists m_i \in \mMatchSet[c[i]] \cap \mNullCopyMatchSet.
  \end{array}
  \labelEquation{null-copy-matches-symmetry-breaking}
\end{equation}
%
It is assumed there exists exactly one \gls{null-copy match} to cover each
\gls{copy node}.

Similarly to \glspl{null-copy match}, symmetries can also arise due to
\glspl{kill match}.
%
In the previous example, for example, if only one of the two \glspl{copy node}
are needed, then we are free to decide which.
%
Intuitively, we want to forbid \glspl{solution} where \gls{inactive.d}
\glspl{datum} ``appear to the right'' of \gls{active.d} \glspl{datum}, and again
we make use of the \gls{increasing constraint} to model this \gls{symmetry
  breaking.c} \gls{constraint} as
%
\begin{equation}
  \begin{array}{c}
    \mIncreasing(\mVar{sel}[m_1], \ldots, \mVar{sel}[m_k]), \\
    \forall c \in \mInterchDataSet[\mCopy],
    \forall 1 \leq i < k,
    \exists m_i \in \mMatchSet[c[i]] \cap \mKillMatchSet,
  \end{array}
  \labelEquation{kill-matches-symmetry-breaking}
\end{equation}
%
where $\mKillMatchSet$ denotes the set of \glspl{kill match}.
%
It is assumed there exists exactly one \gls{kill match} to cover each \gls{copy
  node}.


\section{Presolving}
\labelSection{st-presolving}

\subsection{Dominated matches}
\subsection{Illegal matches}
\subsection{Redundant kill instructions}
\subsection{Redundant null-copy instructions}


\section{Experimental Evaluation}
\subsection{Refined Objective Function Vs. Naive Objective Function}
\subsection{With Or Without Presolving}
\subsection{With Or Without Lower And/Or Upper Cost Bound}
\subsection{With Or Without Implied and Dominance Breaking Constraints}

\section{Discussion}


\section{Summary}
\labelSection{st-summary}

\todo{write summary}

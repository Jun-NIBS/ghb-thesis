% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Solving Techniques}
\labelChapter{solving-techniques}

\todo{write chapter overview}

The material presented in Sects.\thinspace\refSection*{st-model-refinements},
\refSection*{st-branching-strategies}, \refSection*{st-impl-constraints},
\refSection*{st-dom-breaking-constraints}, and \refSection*{st-pre-dom-matches}
is based on ideas conceived by Mats~Carlsson, which have then been improved by
the author of this dissertation.
%
All other materials in this chapter, including the text and figures, are due
entirely to the author.


\section{Model Refinements}
\labelSection{st-model-refinements}

When introducing the \gls{constraint model} in \refChapter{constraint-model},
two parts were presented using naive implementations that are indeed correct but
give poor \gls{propagation}.
%
In this section, we fix these problems by refining the \glsshort{constraint
  model}.


\subsection{Refining the Define-Before-Use Constraint}

When describing the \gls{constraint} that all \glspl{datum} must be
\gls{define.d}[d] before \gls{use.d}[d], a simple but naive implementation was
used (\refEquation{dom-alt}).
%
First, it requires use of set~\glspl{variable},\!%
%
\footnote{%
  This is because the $\mVar{dplace}$~\glspl{variable} need to be members of the
  $\mDom$~\gls{function}, which is implemented as an array into which the
  $\mVar{oplace}$~\glspl{variable} are used as indices.%
}
%
which are expensive and typically results in poor \gls{propagation}.
%
Second, many \gls{implied.c} \glspl{constraint} can be applied by introducing
the notion of in which \glspl{block} \glspl{datum} are \gls{use.d}[d].
%
We first get rid the set~\glspl{variable} by capturing the information in the
$\mDom$~\gls{function} as a dominance relation matrix
%
\begin{equation}
  \begin{bmatrix}
    \begin{array}{@{\:}c|c@{\:}}
        b_1, b_2
      & b_1, b_2 \in \mBlockSet, b_1 \in \mDom(b_2)
    \end{array}
  \end{bmatrix}
  \labelEquation{dominance-matrix}
\end{equation}
%
where each row denotes the fact that a \gls{block}~$b_1$ is \gls{dominate.b}[d]
by another \gls{block}~$b_2$.
%
Next, we introduce the \glspl{variable} needed for capturing uses of
\glspl{datum}.


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{uplace}[p] \in \mBlockSet$} models in
which \gls{block} the \gls{datum} connected to \gls{operand}~$p$ is used.
%
Note that unlike the $\mVar{dplace}$~\glspl{variable}, which are indexed using a
\gls{datum}, the $\mVar{uplace}$~\glspl{variable} are indexed using an
\gls{operand}.


\subsubsection{Constraints}

Intuitively, every \gls{block} wherein a \gls{datum}~$d$ is \gls{use.d}[d] must
be dominated by the \gls{block} wherein $d$ is \gls{define.d}[d].
%
Given a dominance relation matrix~$\mDomMatrix$, this \gls{constraint} is
modeled as
%
\begin{equation}
  \mTable(\mVar{uplace}[p], \mVar{dplace}[e], \mDomMatrix)
  \mQuantSep
  \forall p \in \mPhiOperandCompSet.
  \labelEquation{refined-dom}
\end{equation}
%
where \mbox{$\mPhiOperandCompSet \subseteq \mOperandSet$} denotes the set of
\glspl{operand} not appearing in any \gls{phi-match}.
%
We exclude such \glspl{operand} for the same reasons \glspl{phi-match} are
excluded in \refEquation{naive-dom}.

Next, if a \gls{match}~$m$ is selected and placed in \gls{block}~$b$, then all
\gls{use.d}[s] of \glspl{datum} made by $m$ should also occur in~$b$.
%
This is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{oplace}[o] = \mVar{uplace}[p] \\
    \forall m \in \mPhiMatchCompSet,
    \forall o \in \mCovers(m),
    \forall p \in \mUses(m).
  \end{array}
  \labelEquation{refined-dom-selected}
\end{equation}
%
An example illustrating the interaction between \refEquation{refined-dom} and
\refEquation{refined-dom-selected} is shown in \refFigure{refined-dom-example}.

\begin{figure}
  \centering%
  \input{figures/solving-techniques/dom-example}%

  \caption[Example illustrating the refined define-before-use constraint]%
          {%
            Example illustrating the refined define-before-use constraint.
            %
            The assignments on the right-hand side show how these
            variables should be set if the two matches~$m_1$ and~$m_2$ are
            placed in blocks~$b_1$ respectively $b_2$, where $b_1$ is assumed to
            dominate~$b_2$%
          }
  \labelFigure{refined-dom-example}
\end{figure}

Due to \refEquation{refined-dom-selected}, the assignment to the
$\mVar{uplace}$~\glspl{variable} for non-selected \glspl{match} does not matter
as long as \refEquation{refined-dom} is satisfied, which gives rise to symmetric
\glspl{solution}.
%
To break these symmetries, we fix the assignments in such cases to the
\gls{block} wherein the \gls{datum} is \gls{define.d}[d] since a \gls{block}
always \gls{dominate.b}[s] itself.
%
This is modeled as
%
\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m] \mImp \mVar{uplace}[p] = \mVar{dplace}[\mVar{alt}[p]] \\
    \forall m \in \mPhiMatchCompSet,
    \forall p \in \mUses(m).
  \end{array}
  \labelEquation{refined-dom-not-selected}
\end{equation}

Since neither of the above \glspl{constraint} apply to \glspl{operand} belonging
to \glspl{phi-match}, the assignment to their $\mVar{uplace}$~\glspl{variable}
does not matter, again giving rise to symmetric \glspl{solution}.
%
We therefore fix the assignment in such cases, which is modeled as
%
\begin{equation}
  \mVar{uplace}[p] = \mMin(\mBlockSet)
  \mQuantSep
  \forall p \in \mPhiOperandSet.
  \labelEquation{refined-dom-phi-operands}
\end{equation}


\subsection{Refining the Objective Function}

The straightforward implementation of the \gls{objective function}
(\refEquation{naive-objective-function}) is naive because it fails to reason on
how cost is distributed across the \glspl{operation} that need to be covered,
which in turn results in poor \gls{propagation}.
%
\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{UF graph\labelFigure{cost-example-graph}}%
                {%
                  \input{figures/solving-techniques/cost-example-graph}%
                }%
  \hfill%
  \subcaptionbox{Cost matrix\labelFigure{cost-example-matrix}}%
                {%
                  \figureFontSize%
                  \begin{minipage}{50mm}%
                    \centering%
                    \begin{displaymath}
                      \begin{adjblockarray}{cccccc}{1ex}
                          \text{\tabhead op}
                        & \text{\tabhead match}
                        & \text{\tabhead block}
                        & \multicolumn{3}{c}{%
                            \text{%
                              \parbox{20.5mm}{%
                                % The parbox is used to create a bit of space
                                % between the content and the right bracket
                                \centering\tabhead opcost%
                              }%
                            }%
                          } \\[-.5ex]
                        \begin{block}{[cccc@{\;\times\;}c@{\;=\;}c]}
                          \rule{0pt}{2.5ex}
                          o_1 & m_1 & b_1 & 4 & 10 & 40 \\
                          o_1 & m_1 & b_2 & 4 &  1 &  4 \\
                          o_1 & m_3 & b_1 & 3 & 10 & 30 \\
                          o_1 & m_3 & b_2 & 3 &  1 &  3 \\
                          o_2 & m_2 & b_1 & 1 & 10 & 10 \\
                          o_2 & m_2 & b_2 & 1 &  1 &  1 \\
                          o_2 & m_3 & b_1 & 2 & 10 & 20 \\
                          o_2 & m_3 & b_2 & 2 &  1 &  2 \\[.55ex]
                        \end{block}
                      \end{adjblockarray}
                    \end{displaymath}
                  \end{minipage}%
                }%
  \hfill%
  \mbox{}

  \caption[Example illustrating match cost distributed over operations]%
          {%
            Example illustrating match cost distributed over operations.
            %
            It is assumed that matches~$m_1$, $m_2$, and~$m_3$ have costs~4,
            1, and~5, respectively, and that they can be placed in one of two
            blocks, $b_1$ and $b_2$, with execution frequencies~10 and~1,
            respectively.
            %
            The cost of $m_3$ distributed over $o_1$ and $o_2$ is~3 and~2,
            respectively%
          }
  \labelFigure{cost-example}
\end{figure}
%
See for example \refFigure{cost-example}.
%
Assume a \gls{UF graph} that can be covered by three \glspl{match} -- $m_1$,
$m_2$, and~$m_3$ -- which have costs~4, 1, and~5, respectively, and that they
can be placed in one of two blocks, $b_1$ and $b_2$, with execution
frequencies~10 and~1, respectively (\refFigure{cost-example-graph}).
%
Because \refEquation{naive-objective-function} is modeled as a summation, it can
only propagate the bounds of the \gls{cost variable}.
%
Consequently, for any \glspl{match} where their $\mVar{sel}$~\gls{variable} have
yet to be decided, either all those \glspl{match} are selected and placed in the
\gls{block} with highest execution frequency, or none are selected.
%
In the example above, this means the \gls{cost variable} is initially bounded as
\mbox{$0 < \mVar{cost} < 100$}, which are very weak bounds as we know that the
\gls{UF graph} must at least be covered at a cost of~5 (either both $m_1$ and
$m_2$ are selected and placed in $b_2$, or $m_3$ is selected and placed in
$b_2$) and can at most be covered at a cost of~50 (the selected \glspl{match}
are placed in $b_1$).

Instead of reasoning about the cost incurred by the \glspl{match} -- which may
or may not be selected -- a better approach is to infer the cost incurred on the
\glspl{operation} since these must always be covered.
%
The idea is as follows.
%
First, for each \gls{match}~$m$, evenly divide the cost of $m$ over each
\gls{operation}~$o$ covered by $m$.
%
Let \mbox{$\mOpCost(m, o) \in \mNatNumSet$} denote this cost such that
\mbox{$\sum_{o \in \mCovers(m)} \mOpCost(m, o) = \mCost(m)$} holds for every
\gls{match}~$m$.\!%
%
\footnote{%
  \setlength{\abovedisplayskip}{1ex}%
  \setlength{\belowdisplayskip}{1ex}%
  %
  If a strict partial order $<$ exists over the set of \glspl{operation}, and
  $\mCovers(m)$ returns an ordered, 1-indexed list for which \mbox{$o_1 < o_2 <
    \cdots < o_k$} holds, then the cost can be divided as follows.
  %
  Given a match~$m$, let \mbox{$q = \lfloor \mCost(m) / \mCard{\!\mCovers(m)}
    \rfloor$} and \mbox{$r = \mCost(m) \! \mod \mCard{\!\mCovers(m)}$}.
  %
  Then
  %
  \begin{displaymath}
    \mOpCost(m, o) =
    \left\{
    \begin{array}{ll}
      q + 1 & \text{if $o < \mCovers(m)[r+1]$}, \\
      q     & \text{otherwise}. \\
    \end{array}
    \right.
  \end{displaymath}
}
%
Then, for each \gls{block}~$b$, weigh \mbox{$\mOpCost(m, o)$} with the execution
frequency of~$b$.
%
This information can be represented as a cost matrix
%
\begin{equation}
  \begin{bmatrix}
    \begin{array}{@{\:}c|c@{\:}}
        o, m, b, \big( \mOpCost(m, o) \times \mFreq(b) \big)
      & m \in \mMatchSet, o \in \mCovers(m), b \in \mBlockSet
    \end{array}
  \end{bmatrix}
  \labelEquation{cost-matrix}
\end{equation}
where each row denotes the cost of an \gls{operation}~$o$ if covered by a
\gls{match}~$m$ and placed in a \gls{block}~$b$.
%
An example of this cost matrix is given in \refFigure{cost-example}, from which
we can deduce that the cost of covering operations~$o_1$ and~$o_2$ is between~3
and~40 respectively between~1 and~20 (\refFigure{cost-example-matrix}).
%
Hence the total cost can be bounded as \mbox{$4 < \mVar{cost} < 60$}, which is a
much tighter bound compared to that achieved using the naive \gls{objective
  function}.
%
This in turn has a tremendous impact on solving time, for reasons that will
become clear in \refSection{st-cost-bounds}.\!%
%
\footnote{%
  For the experiments in \cite{HjortBlindellEtAl:2017:CASES}, the refined
  \gls{objective function} was actually implemented as \emph{first} multiply the
  \gls{match} cost with the execution frequency, and \emph{then} evenly divide
  the product over the covered \glspl{operation}.
  %
  While this scheme also greatly reduces solving time compared to the naive
  \gls{objective function}, it proves to be significantly inferior to dividing
  the cost as in \refEquation{cost-matrix}.
  %
  One possible explanation is that it may result in weaker bounds -- for the
  example given in \refFigure{cost-example}, using this scheme bounds the total
  cost as \mbox{$4 < \mVar{cost} < 65$} -- but this does not apply for every
  case.
  %
  Hence the intuition behind why it is better to first divide the \gls{match}
  cost and then multiply the execution frequency remains unclear, thus
  underscoring the fact that seemingly trivial changes to a \gls{constraint
    model} may have considerable impact.%
}


\subsubsection{Variables}

The set of \glspl{variable} \mbox{$\mVar{ocost}[o] \in \mNatNumSet$} models the
cost incurred by covering \gls{operation}~$o$\hspace{-.8pt}.
%
It is assumed the \gls{domain} is the same as for the \gls{cost variable}.


\subsubsection{Constraints}

For each \gls{operation}~$o$\hspace{-.8pt}, the combination
\mbox{$o\hspace{-.8pt}, \mVar{omatch}[o], \mVar{oplace}[o], \mVar{ocost}[o]$}
must appear as a row in the cost matrix.
%
Hence, given a cost matrix~$\mCostMatrix$ this \gls{constraint} is modeled as
%
\begin{equation}
  \mTable(
    o\hspace{-1pt},
    \mVar{omatch}[o],
    \mVar{oplace}[o],
    \mVar{ocost}[o],
    \mCostMatrix
  )
  \mQuantSep
  \forall o \in \mOpSet \hspace{-.8pt}.
  \labelEquation{omatch-oplace-ocost-connection}
\end{equation}
%
The total cost is then modeled as
%
\begin{equation}
  \mVar{cost} = \sum_{o \in \mOpSet} \mVar{ocost}[o].
  \labelEquation{total-cost}
\end{equation}


\section{Tightening the Cost Bounds}
\labelSection{st-cost-bounds}

As explained in \refChapter{constraint-programming}, in \gls{CP} optimization
problems are solved using \gls{branch and bound}.
%
In other words, when a \gls{solution} is found a \gls{constraint} is added to
the \glsshort{constraint model}, forcing any subsequently found \glspl{solution}
to be strictly better.
%
This means that if a part of the \gls{search space} is known not to contain any
better \glspl{solution} -- this is achieved by checking the current lower bound
of the \gls{cost variable} -- then this part need not be explored during
\gls{search}.
%
For this to be effective, however, it must be possible to infer reasonable
bounds on the \gls{cost variable}, which asserts the need for the refined
\gls{objective function} introduced in
\refSection{st-refined-objective-function}.

By the same mechanism, solving can improved by tightening the lower and upper
bounds of the \gls{cost variable} before commencing \gls{search}.
%
A tight upper bound helps the \gls{constraint solver} to prune away parts of the
\gls{search space} that contains inferior \glspl{solution}, while a tight lower
bound helps the \gls{constraint solver} to prune away parts of the \gls{search
  space} that contains no \glspl{solution}.
%
A decent upper bound can be computed by solving the same problem using a greedy
but fast heuristic.
%
To this end, any modern \gls{compiler} can be used.
%
A decent lower bound be computed by solving a relaxed version of the
\gls{constraint model} that only models the \gls{global.is} \gls{instruction
  selection} and \gls{block ordering} problems, which obviously is simpler to
solve than the complete \glsshort{constraint model}.
%
Hence, the relaxed \glsshort{constraint model} consists of only the
$\mVar{omatch}$, $\mVar{opcosts}$, $\mVar{sel}$, $\mVar{succ}$, and
$\mVar{cost}$ variables, \refEquation{operation-coverage}, relaxed versions of
Eqs.\thinspace\refEquation*{block-order} and \refEquation*{fall-through} that
allow fall-throughs via non-empty \glspl{block}, and modified versions of
Eqs.\thinspace\refEquation*{cost-matrix}--\refEquation*{total-cost} that do not
take the execution frequencies into account.

If $\mRelaxedCost$ and $\mHeuristicCost$ denote the cost computed from the
relaxation and by the heuristic, respectively, then the \gls{cost variable} is
bounded as
%
\begin{equation}
  \mRelaxedCost \leq \mVar{cost} < \mHeuristicCost.
  \labelEquation{lower-bound}
\end{equation}


\section{Branching Strategies}
\labelSection{st-branching-strategies}

As explained in \refChapter{constraint-programming}, the \gls{branching
  strategy} decides how to explore the \gls{search space}.
%
In optimization problems, it is generally a good approach to try to find the
optimal \gls{solution} first as that will allow pruning of the still unexplored
parts of the \gls{search space}.
%
To this end, we first branch on the $\mVar{ocost}$~\glspl{variable}, selecting
the \gls{variable}~$v$ with the maximum \gls!{regret} -- that is, the
\gls{variable} with the largest difference between the two smallest values in
its \gls{domain} -- and the smallest value in the \gls{domain} of~$v$.
%
The intuition here is that, because our \gls{objective function} strives to
minimize the total cost, we wish to minimize the cost incurred per
\gls{operation}.
%
By selecting the \gls{variable} with the maximum \gls{regret}, we try to cover
the \glspl{operation} for which to cost of bad decisions is largest, and for
these we obviously try to cover these at least cost.
%
Note that this \gls{branching strategy} is only possible due to the refined
\gls{objective function} described earlier in this chapter.

Remaining decisions are left to the \gls{constraint solver}.
%
To improve \gls{match} selection, however, we make sure to arrange them in
order of increasing latency.
%
If there is a tie between two \glspl{match}, and either of them is a \gls{kill
  match}, then the \gls{kill match} comes first.
%
Otherwise, the \gls{match} covering more \glspl{operation} comes first (hence
mimicking the scheme of \gls{maximum munch}).
%
This is because the \gls{constraint solver} will most likely attempt to select
\glspl{match} in the order given to the \glsshort{constraint model}.
%
In such a setting, it is generally a good approach to first try a \gls{kill
  match}, which incurs no cost and encourages value reuse, and then the
\gls{match} which incurs the least cost.


\section{Implied Constraints}
\labelSection{st-impl-constraints}

As explained in \refChapter{constraint-programming}, \gls{implied.c}
\glspl{constraint} are \glspl{constraint} that strengthen the \gls{propagation}
while preserving all \glspl{solution}.
%
Stronger \gls{propagation} leads to less \gls{search}, which in turn leads to
shorter solving times.
%
In this section, we discuss such \glspl{constraint} that have been added to the
\glsshort{constraint model}.


\todo{mention that \refEquation{pattern-selection-using-gcc} did not give for
  our model}


\subsubsection{TODO: rename (non-phi stuff)}

\todo{describe constraint}

% If all matches covering a non-phi-operation o do not span any blocks, use
% datum u, and define datum d, then the block defining u must dominate the block
% defining d, and o must be placed in the block defining d.

\begin{equation}
  \begin{array}{c}
    \mTable(\mVar{dplace}[d_1], \mVar{dplace}[d_2], \mDomMatrix)
    \mAnd
    \mVar{oplace}[o] = \mVar{dplace}[d_1] \\
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    o' \in \mOpCompSet{\mPhi},
                    m \in \mMatchSet[o'] \hspace{-1pt}
                    \text{ \st }
                    \mConsumes(m) = \mEmptySet
                  }, \\
    \forall d_1 \in
      \mSetBuilder{d}%
                  {%
                    d \in \mDataOf(o \hspace{-1pt}, \mDefines),
                    m \in \mMatchSet[o] \hspace{-1pt},
                    \exists p \in \mDefines(m)
                    \text{ \st }
                    \mDataSet[p] = \mSet{d}
                  }, \\
    \forall d_2 \in
      \mSetBuilder{d}%
                  {%
                    d \in \mDataOf(o \hspace{-1pt}, \mUses),
                    m \in \mMatchSet[o] \hspace{-1pt},
                    \exists p \in \mUses(m)
                    \text{ \st }
                    \mDataSet[p] = \mSet{d}
                  }.
  \end{array}
  \labelEquation{todo}
\end{equation}
%
where
%
\begin{equation}
  \mDataOf(o \hspace{-1pt}, f)
  \equiv
  \mSetBuilder{\mDataSet[p]}%
              {%
                m \in \mMatchSet[o] \hspace{-1pt},
                p \in f\hspace{-1pt}(m)
                \text{ \st }
                \mCovers(m) = \mSet{o}
              }
  \labelEquation{todo}
\end{equation}

If the non-\glspl{phi-match} covering \gls{operation}~$o$ all have the same
\gls{entry block}~$b$, then $o$ must for sure be placed in~$b$ (due to
\refEquation{preventing-control-flow-op-moves}).
%
This is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{oplace}[o] = b \\
    \forall b \in \mBlockSet \hspace{-1pt},
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    o' \in \mOpCompSet{\mPhi},
                    m \in \mMatchSet[o'] \hspace{-1pt}
                    \text{ \st }
                    \mEntry(m) = \mSet{b}
                  }.
  \end{array}
  \labelEquation{place-ops-same-as-entry-block}
\end{equation}

If a \gls{datum}~$d$ appears in a \gls{definition edge}~$\mEdge{b}{d}$ and is
\gls{define.d}[d] by \glspl{phi-match} only, then the \gls{operation} covered by
these \glspl{match} must be placed $b$ (due to \refEquation{def-edges}).
%
This is modeled as
%
\begin{equation}
  \begin{array}{c}
    \mVar{oplace}[o] = b \\
    \forall \mEdge{d}{b} \in \mDefEdgeSet,
    \forall o \in
      \mSetBuilder{o'}%
                  {%
                    \begin{array}{@{}l@{}}
                      m \in \mMatchSet[d] \cap \mPhiMatchSet,
                      o' \in \mCovers(m)
                    \end{array}
                  }.
  \end{array}
  \labelEquation{place-phi-ops-same-as-def-edge}
\end{equation}
%
It is assumed that the \glspl{edge} in $\mDefEdgeSet$ have been reoriented such
that all \glspl{source} are either \glsshort{state node} or \glspl{value node}
and all \glspl{target} are \glspl{block node}.





\todo{describe constraint}

% If all matches in the matchset covering a particular non-phi-operation have
% identical spanned blocks and define datum d, then d must be placed in a
% spanned block.

\begin{equation}
  \begin{array}{c}
    \mVar{dplace}[d] \in S \\
    \forall S \in \mPowerset{\mBlockSet} \hspace{-2pt},
    \forall d \in \mDataSet \!,
    \forall o \in
      \mSetBuilder*{o'}%
                   {%
                     \begin{array}{@{}l@{}}
                       o' \in \mOpCompSet{\mPhi},
                       m \in \mMatchSet[o'] \hspace{-1pt},
                       \exists p \in \mDefines(m) \\
                       \text{\st }
                       \mSpans(m) = S \mAnd \mDataSet[p] = \mSet{d}
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% If all matches in the matchset covering a non-phi-particular operation have
% identical entry blocks and use datum d, then the block defining d must
% dominate the entry block.

\begin{equation}
  \begin{array}{c}
    \mTable(b \hspace{-.8pt}, \mVar{dplace}[d], \mDomMatrix) \\
    \forall b \in \mBlockSet \hspace{-1pt},
    \forall d \in
      \mSetBuilder*{d'}%
                   {%
                     \begin{array}{@{}l@{}}
                       d' \in \mOpCompSet{\mPhi},
                       m \in \mMatchSet[d'] \hspace{-1pt},
                       \exists p \in \mUses(m) \\
                       \text{ \st}
                       \mEntry(m) = \mSet{b} \mAnd \mDataSet[p] = \mSet{d}
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}

\subsubsection{TODO: rename (phi stuff)}

\todo{describe constraint}


\subsubsection{TODO: rename (?)}

\todo{describe constraint}

% For non-phi matches, no spanned blocks:
% if selected, blocks of outputs and blocks of use of inputs must be all equal.

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{uplace}[p_1] = \mVar{uplace}[p_2] \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  },
    \forall p_1, p_2 \in \mUses(m) \setminus \mDefines(m) \\
    \text{\st } p_1 < p_2,
  \end{array}
  \labelEquation{todo}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\mVar{alt}[p_1]] = \mVar{dplace}[\mVar{alt}[p_2]] \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  },
    \forall p_1, p_2 \in \mDefines(m) \text{ \st } p_1 < p_2,
  \end{array}
  \labelEquation{todo}
\end{equation}

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m]
    \mImp
    \mVar{uplace}[p_1] = \mVar{dplace}[\mVar{alt}[p_2]] \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) = \mEmptySet
                  }, \\
    \forall p_1 \in \mUses(m) \setminus \mDefines(m),
    \forall p_2 \in \mDefines(m).
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% For non-phi matches, spanned blocks:
% if selected, blocks of use of inputs must be all equal.

\begin{equation}
  \begin{array}{c}
    \mVar{sel}[m] \mImp \mVar{uplace}[p_1] = \mVar{uplace}[p_2] \\
    \forall m \in
      \mSetBuilder{m'}%
                  {%
                    m \in \mPhiMatchCompSet \hspace{-1pt},
                    \mSpans(m) \neq \mEmptySet
                  },
    \forall p_1, p_2 \in \mUses(m) \setminus \mDefines(m) \\
    \text{\st } p_1 < p_2.
  \end{array}
  \labelEquation{todo}
\end{equation}


\subsubsection{TODO: rename (loc stuff)}

\todo{describe constraint}

% If all matches in the matchset covering a particular operation uses some
% datum d as input, then d cannot be placed in the intermediate value nor killed
% location.

\begin{equation}
  \begin{array}{c}
    \exists d \in S,
    \mVar{loc}[d] \notin \mSet{\mIntLocation, \mKilledLocation} \\
    \forall S \in \mPowerset{\mStateDataCompSet} \hspace{-2pt},
    \forall o \in
      \mSetBuilder*{o'}%
                   {%
                     \begin{array}{@{}l@{}}
                       o' \in \mOpSet \!,
                       m \in \mMatchSet[o'] \hspace{-1pt},
                       \exists p \in \mUses(m) \setminus \mDefines(m) \\
                       \text{\st }
                       \mDataSet[p] = S
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}

Requires \mbox{$\mStores(m, d)$} of kill matches to allow kill location.

\todo{describe constraint}

% [MC 3]
%
% If all matches in the matchset that defines a non-state datum d, are active,
% and define it in an external operand, then d must not be placed in the
% intermediate value nor killed location.
%
% [MC 3] does not dominate [MC 2], nor vice versa.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] \notin \mSet{\mIntLocation, \mKilledLocation} \\
    \forall d \in
      \mSetBuilder*{d'}%
                   {%
                     \begin{array}{@{}l@{}}
                       d' \in \mStateDataCompSet,
                       m \in \mMatchSet[d'] \setminus \mKillMatchSet,
                       \exists p \in \mDefines(m) \text{ \st} \\
                       \mDataSet[p] = \mSet{d'}
                       \mAnd
                       \neg\mIsInt(m, p)
                     \end{array}
                   } \!.
  \end{array}
  \labelEquation{todo}
\end{equation}


\subsubsection{TODO: rename (fall-through stuff)}

\todo{describe constraint}

% If for any two given blocks p and q, and fallThroughBlockOfMatch contains
% [_, p, q] but does not contain [_, p, q'] or [_, p', q], then succ[p] = q can
% only help, never hurt.

\begin{equation}
  \begin{array}{c}
    \mVar{succ}[b_1] = b_2 \\
    \forall b_1, b_2 \in \mBlockSet
    \text{ \st }
    \mSetBuilder{\mEntry(m)}{\mPair{m}{b_2} \in \mFallThroughSet} = \mSet{b_1}
    \mAnd
    \mSetBuilder{m}{\mPair{m}{b_1} \in \mFallThroughSet} = \mEmptySet.
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}


\subsubsection{TODO: remove?}

% Constrain the location of d to be where its definers can put it.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] = S \\
    \forall d \in \mStateDataCompSet,
    \forall S \in
      \mPowerset{\mLocationSet
      \, \cup \,
      \mSet{\mIntLocation, \mKilledLocation}} \text{ \st} \\
    S = \mSetBuilder{l}%
                    {%
                      m \in \mDataSet[d] \setminus \mKillMatchSet,
                      p \in \mDefines(m),
                      l \in \mStores(m, p)
                      \text{ \st }
                      d \in \mDataSet[p]
                    },
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}

% Constrain the location of d to be where its users can access it. Valid for
% such d that are used at least once.

\begin{equation}
  \begin{array}{c}
    \mVar{loc}[d] = S \\
    \forall d \in \mDataUsedOnceSet,
    \forall S \in
      \mPowerset{\mLocationSet
      \, \cup \,
      \mSet{\mIntLocation, \mKilledLocation}} \text{ \st} \\
    S = \mSetBuilder{l}%
                    {%
                      m \in \mKillMatchCompSet,
                      p \in \mUses(m),
                      l \in \mStores(m, p)
                      \text{ \st }
                      d \in \mDataSet[p]
                    },
  \end{array}
  \labelEquation{todo}
\end{equation}

\todo{describe constraint}


\section{Symmetry and Dominance Breaking Constraints}
\labelSection{st-dom-breaking-constraints}

As explained in \refChapter{constraint-programming}, \glsshort{symmetry
  breaking.c} and \gls{dominance breaking.c} \glspl{constraint} are
\glspl{constraint} that remove \glspl{solution} from the \gls{search space} that
are either symmetric to one another or dominated by some other \gls{solution}.
%
Since this leads to a smaller \gls{search space}, the solving time is reduced.
%
In this section, we discuss such \glspl{constraint} that have been added to the
\glsshort{constraint model}.


\subsubsection{Location of State Nodes}

Since \glspl{datum} also includes the \glspl{state node}, this means a
$\mVar{loc}$~\gls{variable} will be allocated for each individual \gls{state
  node}.
%
However, since \glspl{state node} are abstract entities used only to capture
implicit dependencies between certain \gls{operation}, the assignment to these
\glspl{variable} has no actual bearing on the \gls{solution}, thus giving rise
to many symmetric \glspl{solution}.
%
Consequently, it makes sense to fix the location for each \gls{state node},
which is modeled as
%
\begin{equation}
  \mVar{loc}[d] = \mIntLocation
  \mQuantSep
  \forall d \in \mStateDataSet,
  \labelEquation{loc-of-state-nodes}
\end{equation}
%
where \mbox{$\mStateDataSet \subseteq \mDataSet$} denotes the set of
\glspl{state node}.


\subsubsection{Operands of Non-Selected Matches}

The $\mVar{alt}$~\glspl{variable} of \glspl{match} that are not selected still
need to be assigned a value.
%
Since this assignment does not matter for the \gls{solution}, it gives rise to
many symmetric \glspl{solution}.
%
We therefore fix the $\mVar{alt}$ assignments in such cases, which is modeled as
%
\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m] \mImp \mVar{alt}[p] = \mMin(\mDataSet[\hspace{-1pt}p]) \\
    \forall m \in \mMatchSet,
    \forall p \in \mDefines(m) \cup \mUses(m).
  \end{array}
  \labelEquation{operands-of-non-selected-matches}
\end{equation}

The \gls{symmetry breaking.c} \gls{constraint} above also implies that if an
\gls{operand} representing input with multiple \glspl{datum} does not take its
minimum value, then the corresponding \gls{match} must be selected, which means
that the corresponding \gls{datum} must be in a usable location.
%
This is modeled as
\begin{equation}
  \begin{array}{c}
    \mVar{alt}[p] \neq \mMin(\mDataSet[p])
    \mImp
    \mVar{alt}[p] \notin \mSet{\mIntLocation, \mKilledLocation} \\
    \forall m \in \mMatchSet,
    \forall p \in \mUses(m) \setminus \mDefines(m)
    \text{ \st }
    \mCard{\mDataSet[p]} > 1.
  \end{array}
  \labelEquation{input-operands-not-taking-min-value}
\end{equation}


\subsubsection{Interchangeable Data}

As described in \refSection{modeling-value-reuse}, \glspl{datum} in the \gls{UF
  graph} that are copies of the same value are \gls{copy-related.d} and
therefore interchangeable.
%
\begin{figure}
  \begin{minipage}[b]{58mm}%
    \centering%
    \subcaptionbox{%
                    UF graph, where the values \irVar{v}[1] and \irVar{v}[2]
                    constitute a chain of interchangeable data%
                    \labelFigure{interchangeable-data-example-annotated-graph}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-annotated-graph%
                    }%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Symmetries due to how data can be connected to operands%
                    \labelFigure{interchangeable-data-example-alt-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-alt-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-alt-2%
                    }%
                  }%
  \end{minipage}%
  \hfill%
  \begin{minipage}[b]{58mm}%
    \centering%
    \subcaptionbox{%
                    Symmetries due to how null-copy matches can be selected%
                    \labelFigure{interchangeable-data-example-null-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-null-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-null-2%
                    }%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Symmetries due to how kill matches can be selected%
                    \labelFigure{interchangeable-data-example-kill-solutions}%
                  }%
                  [\textwidth]%
                  {%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-kill-1%
                    }%
                    \hspace{8mm}%
                    \input{%
                      figures/solving-techniques/%
                      interchangeable-data-example-kill-2%
                    }%
                  }%
  \end{minipage}

  \caption[Example of interchangeable data]%
          {%
            Example of interchangeable data and how these give rise to
            symmetries%
          }
  \labelFigure{interchangeable-data-example}
\end{figure}
%
This is another source for symmetric \glspl{solution}, which is illustrated in
\refFigure{interchangeable-data-example}.

Assume a \gls{UF graph} containing two \gls{copy-related.d} values, \irVar{v}[1]
and~\irVar{v}[2], that may both be connected to two \glspl{operand}~$p_1$
and~$p_2$ (\refFigure{interchangeable-data-example-annotated-graph}).
%
We say that a set of values constitute a chain of \gls!{interchangeable.d} if
they can be swapped in a \gls{solution} without affecting the \gls{program}
semantics, which is the case if the values are all \gls{copy-related.d} and none
is both \gls{define.d}[d] and \gls{use.d}[d] by some \gls{match}.
%
In the above example, \irVar{v}[1] and~\irVar{v}[2] constitute such a chain and
can therefore be swapped for $p_1$ and~$p_2$, giving rise to unwanted symmetric
\glspl{solution} (\refFigure{interchangeable-data-example-alt-solutions}).
%
The intuition here is to forbid \glspl{solution} containing ``cross-over''
connections between the values in a chain and the $\mVar{alt}$~\glspl{variable}.
%
As a precaution, however, we will exclude \glspl{operand} used by
\glspl{phi-match} due to the \gls{definition edge} which may require such
cross-over connections.

If we assume that there exists a partial order $\leq$ for~$\mDataSet$, then we
can remove these symmetries using the \gls!{value-precede-chain constraint},
which requires a sequence of \glspl{variable} to be sorted according to a given
chain of values.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Value-Precede-Chain Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a permutation of
  \glspl{variable}.
  %
  Let also $c$ be a 1-indexed sequence with $n$ elements.
  %
  Then
  %
  \begin{displaymath}
    \mValuePrecChain(c, \mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \bigcap_{1 \leq i < n}
    \mValuePrec(c[i], c[i+1], \mVar{x}[1], \ldots \mVar{x}[k]),
  \end{displaymath}
  %
  where
  %
  \begin{displaymath}
    \mValuePrec(s, t, \mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \forall_{\! i} \: d_i = t
                  \mImp \exists_{j} \: j < i \mAnd d_j = s
                }.
  \end{displaymath}
\end{definition}
%
For example, \mbox{$\mValuePrecChain(\langle 6, 5, 4 \rangle, \mVar{x}_1 \in
  \mSet{6}, \mVar{x}_2 \in \mSet{1}, \mVar{x}_3 \in \mSet{5}, \mVar{x}_4 \in
  \mSet{4})$} holds because the~4 is preceded by a~5, which in turn is preceded
by a~6, in the permutation of $\mVar{x}$~\glspl{variable}.
%
Likewise, \mbox{$\mValuePrecChain(\langle 5, 4 \rangle, \mVar{x}_1 \in \mSet{5},
  \mVar{x}_2 \in \mSet{1})$} also holds because 4 does not appear among the
$\mVar{x}$~\glspl{variable} (the fact that 5 appears in the permutation does
not matter).
%
However, \mbox{$\mValuePrecChain(\langle 5, 4 \rangle, \mVar{x}_1 \in \mSet{1},
  \mVar{x}_2 \in \mSet{4})$} does not hold because the~4 is not preceded by a~5.

Hence, if $\mInterchDataSet$ denotes the set of chains of
\gls{interchangeable.d} \glspl{datum} and \mbox{$\mOperandSet[\mPhi] \subseteq
  \mOperandSet$} denotes the set of \glspl{operand} used by \glspl{phi-match},
then the \gls{dominance breaking.c} \gls{constraint} described above is modeled
as
%
\begin{equation}
  \begin{array}{c}
    \mValuePrecChain(c, \mVar{alt}[p_1], \ldots, \mVar{alt}[p_k]) \\
    \forall c \in \mInterchDataSet,
    \forall p_1, \ldots, p_k \in \mOperandSet \setminus \mOperandSet[\mPhi]
    \text{ \st }
    p_1 \neq \cdots \neq p_k
    \mAnd
    \forall_{\! i} \: \mDataSet[p_i] \! = c.
  \end{array}
  \labelEquation{interchangeable-data-chain-precedence}
\end{equation}

Additional symmetries may appear due to \glspl{null-copy match}.
%
Returning to the previous example, if one of the two \glspl{copy node} need to
be covered using a \gls{copy match} derived from actual copy \gls{instruction},
then we are free to decide which.
%
Intuitively, we want to forbid \glspl{solution} where selected \glspl{null-copy
  match} ``appear to the left'' of a non-\gls{null-copy match}.
%
To this end, we make use of the \gls!{increasing constraint}, which requires a
sequence of \glspl{variable} to be assigned values in a non-strictly increasing
order.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Increasing Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a permutation of
  \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mIncreasing(\mVar{x}_1, \ldots, \mVar{x}_k)
    \equiv
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \forall_{\! i < k} \: d_i \leq d_{i+1}
                }.
  \end{displaymath}
\end{definition}
%
Let $\mInterchDataSet[\mCopy]$ denote the set of chains of \glspl{datum} that
can only be defined by \glspl{copy match}, \mbox{$\mNullCopyMatchSet \subseteq
  \mMatchSet$} denote the set of \glspl{null-copy match}, and
\mbox{$\mMatchSet[d] \subseteq \mMatchSet$} denote the set of \glspl{match} that
can define a \gls{datum}~$d$.
%
Using these definitions, this \gls{dominance breaking.c} \glspl{constraint} is
modeled as
%
\begin{equation}
  \begin{array}{c}
    \mIncreasing(\mVar{sel}[m_1], \ldots, \mVar{sel}[m_k]) \\
    \forall c \in \mInterchDataSet[\mCopy],
    \forall 1 \leq i < k,
    \exists m_i \in \mMatchSet[c[i]] \cap \mNullCopyMatchSet.
  \end{array}
  \labelEquation{null-copy-matches-symmetry-breaking}
\end{equation}
%
It is assumed there exists exactly one \gls{null-copy match} to cover each
\gls{copy node}.

Similarly to \glspl{null-copy match}, symmetries can also arise due to
\glspl{kill match}.
%
In the previous example, for example, if only one of the two \glspl{copy node}
are needed, then we are free to decide which.
%
Intuitively, we want to forbid \glspl{solution} where \gls{killed.d}
\glspl{datum} ``appear to the right'' of non-\gls{killed.d} \glspl{datum}, and
again we make use of the \gls{increasing constraint} to model this
\gls{dominance breaking.c} \gls{constraint} as
%
\begin{equation}
  \begin{array}{c}
    \mIncreasing(\mVar{sel}[m_1], \ldots, \mVar{sel}[m_k]) \\
    \forall c \in \mInterchDataSet[\mCopy],
    \forall 1 \leq i < k,
    \exists m_i \in \mMatchSet[c[i]] \cap \mKillMatchSet,
  \end{array}
  \labelEquation{kill-matches-symmetry-breaking}
\end{equation}
%
where $\mKillMatchSet$ denotes the set of \glspl{kill match}.
%
It is assumed there exists exactly one \gls{kill match} to cover each \gls{copy
  node}.


\section{Presolving}
\labelSection{st-presolving}

\subsection{Dominated matches}
\labelSection{st-pre-dom-matches}

\subsection{Illegal matches}

% Disable definers of output data that would put it elsewhere to where its
% users can access them. Valid for data that are used at least once.

\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m] \\
    \forall m \in
      \mSetBuilder*{m'}%
                   {%
                     \begin{array}{@{}l@{}}
                       m' \in \mKillMatchCompSet,
                       p \in \mDefines(m'),
                       d \in \mDataSet[p] \hspace{-1pt} \text{ \st} \\
                       \neg\mIsInt(m, p)
                       \mAnd
                       \mStores(m, p) \cap \mUseLocsOf(d) = \mEmptySet
                     \end{array}
                   } \!,
  \end{array}
\end{equation}
%
where
%
\begin{equation}
  \mUseLocsOf(d)
  \equiv
  \mSetBuilder{l}%
              {%
                m \in \mKillMatchCompSet,
                p \in \mUses(m),
                l \in \mStores(m, p)
                \text{ \st }
                d \in \mDataSet[p]
              }.
\end{equation}

% Disable users of input data that would access it elsewhere to where its
% definers can put them.

\begin{equation}
  \begin{array}{c}
    \neg\mVar{sel}[m] \\
    \forall m \in
      \mSetBuilder*{m'}%
                   {%
                     \begin{array}{@{}l@{}}
                       m' \in \mKillMatchCompSet,
                       p \in \mUses(m') \setminus \mDefines(m'),
                       d \in \mDataSet[p] \hspace{-1pt} \\
                       \text{\st }
                       \mStores(m, p) \cap \mDefLocsOf(d) = \mEmptySet
                     \end{array}
                   } \!,
  \end{array}
\end{equation}
%
where
%
\begin{equation}
  \hspace*{-1em}
  \mDefLocsOf(d)
  \equiv
  \mSetBuilder{l}%
              {%
                m \in \mMatchSet[d] \setminus \mKillMatchSet,
                p \in \mDefines(m),
                l \in \mStores(m, p)
                \text{ \st }
                d \in \mDataSet[p]
              }.
\end{equation}


\subsection{Redundant kill instructions}
\subsection{Redundant null-copy instructions}

\section{Experimental Evaluation}
\subsection{Refined Objective Function Vs. Naive Objective Function}
\subsection{With Or Without Presolving}
\subsection{With Or Without Lower And/Or Upper Cost Bound}
\subsection{With Or Without Implied and Dominance Breaking Constraints}

\section{Discussion}


\section{Summary}
\labelSection{st-summary}

\todo{write summary}

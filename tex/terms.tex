% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\makeglossaries

%================
% COMPILER TERMS
%================

\newTerm{addressing mode}
\newTerm{assembly code}
\newAcronym{AST}%
           {abstract syntax tree}%
           [firstplural={abstract syntax trees~(ASTs)}]
\newTerm{backend}
\newTerm{block ordering}
\newTerm{bootstrapping}
\newTerm{bundling}
\newTerm{callee}
\newTerm{caller}
\newTerm{calling convention}
\newTerm{code generation}
\newTerm[integrated.cg]{integrated}[parent={code generation}]
\newTerm[interpretative.cg]{interpretative}[parent={code generation}]
\newTerm{common subexpression elimination}
\newTerm{compiler}
\newTerm{compiler intrinsic}
\newTerm{condition code}[see={status flag}]
\newTerm{condition flag}[see={status flag}]
\newTerm{constant folding}
\newTerm{data copying}
\newTerm{dead code elimination}
\newTerm{fall-through}
\newTerm{frontend}
\newTerm{global code motion}
\newTerm{global code mover}
\newTerm{if-conversion}
\newTerm{instruction compaction}
\newTerm{instruction selection}
\newTerm[local.is]{local}[parent={instruction selection}]
\newTerm[global.is]{global}[parent={instruction selection}]
\newTerm{instruction selector}
\newTerm{instruction scheduler}
\newTerm{instruction scheduling}
\newAcronym{IR}{intermediate representation}
\newTerm{issue slot}
\newTerm{live range}
\newTerm{loop unrolling}
\newTerm{middle-end}[see={optimizer}]
\newTerm{optimizer}[see={middle-end}]
\newTerm{peephole optimization}
\newTerm{peephole optimizer}
\newTerm{register allocation}
\newTerm[local.ra]{local}[parent={register allocation}]
\newTerm[global.ra]{global}[parent={register allocation}]
\newTerm{register allocator}
\newTerm{recomputation}[user1={recompute}]
\newTerm{saturation arithmetic}
\newAcronym{SSA}{static single assignment}
\newTerm{status flag}
\newTerm{value reuse}[user1={reuse}]

\newTerm{basic block}[see={block}]
\newTerm{block}[see={basic block}]
\newTerm[consume.b]{consume}[parent={block}, user1={consum}]
\newTerm[dominate.b]{dominate}[parent={block}, user1={domin}]
\newTerm[span.b]{span}[parent={block}]
\newTerm{entry block}[user1={entry}]
\newTerm{function}
\newTerm[phi-function]{$\mPhi$-function}
\newTerm[phi-node]{$\mPhi$-node}
\newTerm{program}


%===============
% MACHINE TERMS
%===============

\newTerm{ARM}
\newAcronym{ASIP}{application-specific instruction set processor}
\newAcronym{AVX}{Advanced Vector Extensions}[see={Intel}]
\newAcronym{CISC}{complex instruction-set computer}
\newTerm{Cortex-M7}[see={ARM}]
\newAcronym{DSP}{digital signal processor}
\newTerm{Hexagon}
\newTerm{IBM}
\newTerm{instruction}
\newAcronym[SIMD.instr]%
           {SIMD}%
           {single-instruction, multiple-data}%
           [parent={instruction}]
\newTerm{instruction set}
\newTerm{Intel}
\newTerm{LLVM}
\newTerm{machine description}
\newToolTerm{MediaBench}
\newTerm{MIPS}
\newTerm{register}
\newTerm{register class}%
        [plural={register classes}, user1={class}, user2={classes}]
\newTerm[spilling.r]{spilling}[parent={register}, user1={spill}, user2={spills}]
\newAcronym{RISC}{reduced instruction-set computer}
\newAcronym{SSE}{Streaming SIMD Extensions}[see={Intel}]
\newTerm{target machine}[user1={target}]
\newTerm{temporary}[plural={temporaries}]
\newTerm[virtual.temp]{virtual}[parent={temporary}]
\newTerm{TI}
\newTerm{TMS320C55x}[see={TI}]
\newAcronym{VLIW}{very long instruction word}
\newTerm{X86}[see={Intel}]


%=============
% GRAPH TERMS
%=============

\newTerm{child}[see={node}]
\newTerm{cycle}
\newAcronym{DAG}{directed acyclic graph}
\newTerm{edge}
\newTerm[inbound.e]{inbound}[parent={edge}, see={ingoing.e}]
\newTerm[ingoing.e]{ingoing}[parent={edge}, see={inbound.e}]
\newTerm[outbound.e]{outbound}[parent={edge}, see={outgoing.e}]
\newTerm[outgoing.e]{outgoing}[parent={edge}, see={outbound.e}]
\newTerm{edge number}
\newTerm[inbound.en]{inbound}[parent={edge number}]
\newTerm[outbound.en]{outbound}[parent={edge number}]
\newTerm{edge splitting}[user1={split}]
\newTerm{forest}
\newTerm{graph}
\newTerm[connected.g]{connected}[parent={graph}]
\newTerm[directed.g]{directed}[parent={graph}]
\newTerm[ordered.g]{ordered}[parent={graph}]
\newTerm[simple.g]{simple}[parent={graph}]
\newTerm[strongly connected.g]{strongly connected}[parent={graph}]
\newTerm[undirected.g]{undirected}[parent={graph}]
\newTerm[weakly connected.g]{weakly connected}[parent={graph}]
\newTerm{graph homomorphism}
\newTerm{graph isomorphism}
\newTerm{independent set}
\newTerm{isomorphism}[see={subgraph isomorphism}, user1={isomorphic}]
\newTerm{leaf}[plural={leaves}, see={node}]
\newTerm{loop edge}[see={loop}]
\newTerm{loop}[see={loop edge}]
\newTerm{multigraph}
\newTerm{node}
\newTerm[adjacent.n]{adjacent}[parent={node}]
\newTerm[connected.n]{connected}[parent={node}]
\newTerm[fixed.n]{fixed}[parent={node}]
\newTerm{node duplication}[user1={duplicat}]% The short term is without the
                                            % ending 'e' in order to be used in
                                            % words like 'duplicate' and
                                            % 'duplicating'.
\newTerm{parent}[see={node}]
\newTerm{path}
\newTerm{root}[see={node}]
\newTerm{source}
\newTerm{subgraph}
\newTerm{subgraph isomorphism}[see={isomorphism}, user3={subgraph-isomorphism}]
\newTerm{subtree}[see={tree}]
\newTerm{super node}
\newTerm{target}
\newTerm{topological sort}
\newTerm{tree}
\newTerm[directed.t]{directed}[parent={tree}]
\newTerm[rooted directed.t]{rooted directed}[parent={tree}]
\newTerm{vertex}[plural={vertices}, see={node}]


%========================
% CONSTRAINT MODEL TERMS
%========================

\newTerm{alternative value}[user1={alternative}]
\newTerm{block node}[user1={block}]
\newTerm{branch extension}
\newTerm{copy extension}
\newTerm{computation node}[user1={computation}]
\newTerm{control node}[user1={control}]
\newTerm{copy match}[plural={copy matches}]
\newTerm{copy node}[user1={copy}]
\newTerm{datum}[plural={data}]
\newTerm[available.d]{available}[parent={datum}]
\newTerm[copy-related.d]{copy-related}[parent={datum}]
\newTerm[define.d]{define}[parent={datum}, user1={defin}]
\newTerm[interchangeable.d]{interchangeable}[parent={datum}]
\newTerm[killed.d]{killed}[parent={datum}]
\newTerm[use.d]{use}[parent={datum}, user1={us}]
\newTerm{definition edge}
\newTerm{dependency graph}
\newTerm{divide-then-multiply method}[see={multiply-then-divide method}]
\newTerm{DTB pattern}%
        [first={dual-target branch (DTB) pattern},
         user4={dual-target branch pattern},
         user5={dual-target branch patterns}]
\newTerm{extension node}[user1={extension}]
\newTerm{exterior value}[user1={exterior}]
\newTerm{intermediate value}[user1={intermediate}]
\newTerm{input datum}[plural={input data}]
\newTerm{kill match}[plural={kill matches}]
\newTerm{kill pattern}
\newTerm{location}
\newTerm[canonical.l]{canonical}[parent={location}]
\newTerm{location set}
\newTerm{match duplication}
\newTerm{multiply-then-divide method}[see={divide-then-multiply method}]
\newTerm{null-copy match}[plural={null-copy matches}]
\newTerm{null-copy pattern}
\newTerm{null-def pattern}
\newTerm{null-extend pattern}
\newTerm{null-jump pattern}
\newTerm{null match}[plural={null matches}, user1={null}]
\newTerm{operand}
\newTerm{operation}
\newTerm[phi-match]{{}$\mPhi$-match}[plural={{}$\mPhi$-matches}]
% The {} is used to avoid problems with \Gls commands
\newTerm[phi-pattern]{$\mPhi$-pattern}
\newTerm{state node}[user1={state}, user2={states}]
\newTerm{state-flow edge}[user1={state-flow}]
\newTerm{universal instruction selection}
\newTerm{universal representation}
\newTerm{UF graph}[first={universal function (UF) graph}, user1={UF}]
\newTerm{UP graph}[first={universal pattern (UP) graph}, user1={UP}]
\newTerm{value node}[user1={value}]


%==========
% CP TERMS
%==========

\newTerm{decision variable}[see={variable}, user1={variable}, user2={variables}]
\newTerm{solver}

\newTerm{all-different constraint}[user1={all-different}]
\newTerm{branch and bound}[user3={branch-and-bound}]
\newTerm{branching strategy}[plural={branching strategies}]
\newToolTerm{Chuffed}
\newTerm{circuit constraint}[user1={circuit}]
\newTerm{cost variable}
\newTerm{cumulative constraint}[user1={cumulative}]
\newTerm{constraint}
\newTerm[binary.c]{binary}[parent={constraint}]
\newTerm[dominance breaking.c]{dominance breaking}[parent={constraint}]
\newTerm[global.c]{global}[parent={constraint}]
\newTerm[implied.c]{implied}[parent={constraint}]
\newTerm[symmetry breaking.c]%
        {symmetry breaking}%
        [parent={constraint}, user1={symmetry}]
\newTerm{constraint propagation}[see={propagation}]
\newTerm{constraint model}[user1={model}, user2={models}]
\newTerm[compositional.cm]{compositional}[parent={constraint model}]
\newTerm{constraint solver}[user1={solver}, see={solver}]
\newTerm{constraint store}[see={store}]
\newTerm[stronger.cs]{stronger}[parent={constraint store}]
\newAcronym{CP}{constraint programming}
\newTerm{diffn constraint}[see={no-overlap constraint}]
\newTerm{domain}
\newTerm{extensional constraint}[see={table constraint}]
\newTerm{failure}[user1={failed}]
\newTerm{filtering algorithm}[see={propagator}]
\newTerm{first-fail principle}
\newTerm{fixpoint}
\newTerm{global cardinality constraint}
\newTerm{minimax}
\newToolTerm{MiniZinc}
\newTerm{no-overlap constraint}[see={diffn constraint}]
\newTerm{objective function}
\newTerm{presolving}
\newTerm{propagation}[see={constraint propagation}, user1={propagat}]
\newTerm{propagator}[see={filtering algorithm}]
\newTerm{bounds consistency}[user1={bounds}, user3={bounds-consistent}]
\newTerm[decreasing.p]{decreasing}[parent={propagator}]
\newTerm{domain consistency}[user1={domain}, user3={domain-consistent}]
\newTerm[monotonic.p]{monotonic}[parent={propagator}]
\newTerm{value consistency}[user1={value}, user3={value-consistent}]
\newTerm{regret}
\newTerm{search}
\newTerm{search space}
\newTerm{search tree}
\newTerm{solution}
\newTerm{solution space}
\newTerm{store}[see={constraint store}]
\newTerm{table constraint}[user1={table}]
\newTerm{value-precede-chain constraint}
\newTerm{variable}
\newTerm[assigned.v]{assigned}[parent={variable}]

\newTerm{magic sequence problem}


%===================
% OP RESEARCH TERMS
%===================

\newAcronym{MIS}%
           {maximal independent set}%
           [firstplural={maximal independent sets~(MISs)}]
\newAcronym{MWIS}%
           {maximal/minimal weighted independent set}%
           [firstplural={maximal/minimal weighted independent sets~(MWISs)}]

\newAcronym{PBQP}{partitioned Boolean quadratic problem}
\newAcronym{QAP}{quadratic assignment problem}

\newAcronym{IP}{integer programming}
\newTerm{Horn clause}
\newTerm{integer linear programming}

\newAcronym{SAT}{Boolean satisfiability}
\newTerm{literal}
\newAcronym{LCG}{lazy clause generation}
\newTerm{implication graph}
\newTerm{no-good}
\newTerm{unit propagation}


%===============
% GRAMMAR TERMS
%===============

\newTerm{action}
\newTerm{context-free grammar}
\newTerm{grammar}[see={machine grammar}]
\newTerm[normal form.g]{normal form}[parent={grammar}, user1={normal-form}]
\newTerm{machine grammar}[see={grammar}]
\newTerm{nonterminal}
\newTerm{production}
\newTerm{rule}
\newTerm[base.r]{base}[parent={rule}]
\newTerm[chain.r]{chain}[parent={rule}]
\newTerm[complex.r]{complex}[parent={rule}]
\newTerm[proxy.r]{proxy}[parent={rule}]
\newTerm[simple.r]{simple}[parent={rule}]
\newTerm[split.r]{split}[parent={rule}]
\newTerm{rule pattern}[user1={pattern}]
\newTerm{rule reduction}
\newTerm{rule result}[user1={result}]
\newTerm{state}
\newTerm{state table}
\newTerm{terminal}


%==================
% STATISTICS TERMS
%==================

\newTerm{baseline}
\newAcronym{CI}{confidence interval}
\newAcronym{CV}{coefficient of variation}
\newAcronym{GMI}{geometric mean improvement}
\newTerm[{k-means clustering}]{$k$-means clustering}
\newTerm{percentile bootstrapping}
\newTerm{speedup}
\newTerm{subject}
\newTerm{zero-centered normalization}


%====================
% RELATED WORK TERMS
%====================

\newTerm{principle}
\newTerm{macro expansion}
\newTerm[naive.me]{naive}[parent={macro expansion}]
\newTerm{tree covering}
\newTerm{DAG covering}
\newTerm{graph covering}

\newTerm{instruction characteristic}%
        [user1={characteristic}, user2={characteristics}]
\newTerm[single-output.ic]%
        {single-output}%
        [parent={instruction characteristic}]
\newTerm[multi-output.ic]%
        {multi-output}%
        [parent={instruction characteristic}]
\newTerm[disjoint-output.ic]%
        {disjoint-output}%
        [parent={instruction characteristic}]
\newTerm[inter-block.ic]%
        {inter-block}%
        [parent={instruction characteristic}]
\newTerm[interdependent.ic]%
        {interdependent}%
        [parent={instruction characteristic}]

\newTerm{block DAG}[user1={block}]
\newTerm{control-flow edge}[user1={control-flow}]
\newTerm{control-flow graph}[user1={control-flow}]
\newTerm{cover}
\newTerm[least-cost.c]{least-cost}[parent={cover}]
\newTerm{data-flow edge}[user1={data-flow}]
\newTerm{data-flow graph}[user1={data-flow}]
\newTerm{expression tree}
\newTerm{function graph}[user1={function}]
\newTerm{interference graph}
\newTerm{match}[plural=matches]
\newTerm[complex.m]{complex}[parent={match}]
\newTerm[dominate.m]{dominate}[parent={match}, user1={domin}]
\newTerm[illegal.m]{illegal}[parent={match}]
\newTerm{match set}
\newTerm{matching}[see={pattern matching}]
\newTerm{overlap}
\newTerm{pattern}[see={pattern graph}]
\newTerm[complex.p]{complex}[parent={pattern}]
\newTerm[proxy.p]{proxy}[parent={pattern}]
\newTerm[simple.p]{simple}[parent={pattern}]
\newTerm{pattern DAG}[see={pattern}]
\newTerm{pattern graph}[see={pattern}]
\newTerm{pattern tree}[see={pattern}]
\newTerm{pattern matching}[user3={pattern-matching}, see={matching}]
\newTerm{pattern selection}[see={selection}]
\newTerm[optimal.ps]{optimal}[parent={pattern selection}]
\newTerm{pattern set}
\newTerm{sea-of-nodes IR}
\newTerm{selection}[see={pattern selection}]
\newTerm{SSA graph}

\newTerm{Click-Paleczny graph}
\newTerm{Davidson-Fraser approach}
\newTerm{expand procedure}
\newTerm{finite state automaton}%
        [plural={finite state automata}, see={state machine}]
\newTerm{finite tree automaton}[plural={finite tree automata}]
\newTerm{macro}
\newTerm{macro expander}[user3={macro-expan}]% The short term is without the
                                             % ending 'sion' in order to be used
                                             % in words like 'expanding'.
\newTerm{maximum munch}
\newTerm{product automaton}[plural={product automata}]
\newTerm{pushdown automaton}[plural={pushdown automata}]
\newTerm[SLM instruction]%
        {SLM~instruction}%
        [first={source language machine (SLM) instruction}]
\newTerm{state machine}[see={finite state automaton}]
\newTerm{template}
\newTerm{tree series transducer}

\newAcronym{BURS}{bottom-up rewriting system}
\newAcronym{CGPL}{Code Generator Preprocessor Language}
\newAcronym{FRT}%
           {factorized register transfer}%
           [firstplural={factorized register transfers~(FRTs)}]
\newAcronym{ICL}{Interpretive Coding Language}
\newAcronym{MIML}{Machine-Independent Macro Language}
\newAcronym{OMML}{Object Machine Macro Language}
\newAcronym{TEL}{Template Language}
\newAcronym{XL}{Extensible Language}

\newToolTerm{Dmacs}
\newToolTerm{Firm}
\newToolTerm{Glasgow}
\newToolTerm{GCL}
\newToolTerm{LAD}
\newToolTerm{Simcmp}
\newToolTerm{Ucode}
\newToolTerm{Ugen}
\newToolTerm{VF2}


%================
% LANGUAGE TERMS
%================

\newTerm{C}
\newTerm{Pascal}
\newTerm{PL/1}
\newTerm{PL/C}
